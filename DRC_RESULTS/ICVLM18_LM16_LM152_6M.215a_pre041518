// #!TSMC
// *****************************************************************************
// * 0.18um/0.16um/0.152um IC Validator DRC COMMAND FILE - ICVLM18_LM16_LM152_6M.215a_pre041518  (04/15/2018) *
// * FOR TSMC 0.18UM CMOS LOGIC/MS/RF AND 0.16UM/0.152UM CMOS LOGIC/MS 1P6M PROCESS DESIGN RULE*
// *          (CL018G/LV/LP, CM018G, CR018G, CL016G, CM016G, CL0152G, CM0152)  *
// * (DESIGN RULE DOCUMENT: T-018-LO-DR-001 Rev 2.15)                          *
// * (DRC COMMAND FILE DOCUMENT: T-018-LO-DR-001-J1 Rev 2.15a_pre041518)         	       *
// *****************************************************************************

//************************************************************************************
//* TSMC developed this deck using Synopsys proprietary PXL formats.
//* The deck is to be used only in IC Validator tools.
//************************************************************************************
//
//  DISCLAIMER
//
//  The information contained herein is provided by TSMC on an "AS IS" basis
//  without any warranty, and TSMC has no obligation to support or otherwise
//  maintain the information.  TSMC disclaims any representation that the
//  information does not infringe any intellectual property rights or proprietary
//  rights of any third parties.  There are no other warranties given by TSMC,
//  whether express, implied or statutory, including, without limitation, implied
//  warranties of merchantability and fitness for a particular purpose.
//
//  STATEMENT OF USE
//
//  This information contains confidential and proprietary information of TSMC.
//  No part of this information may be reproduced, transmitted, transcribed,
//  stored in a retrieval system, or translated into any human or computer
//  language, in any form or by any means, electronic, mechanical, magnetic,
//  optical, chemical, manual, or otherwise, without the prior written permission
//  of TSMC.  This information was prepared for informational purpose and is for
//  use by TSMC's customers only.  TSMC reserves the right to make changes in the
//  information at any time and without notice.
//
//-------------------------------------------------------------------------------------------
//
//  NOTICE: (Read Me First!)
//
//  1. If the input GDS file does not include all the layers in the
//     INPUT LAYER BLOCK, for example, they are generated by logic
//     operations, please make sure the consistence with original
//     layer definition.
//
//  2. The runset is tested and developed on IC Validator 2014.12-SP2, please use 
//     this or newer TSMC qualified version of IC Validator to execute this runset.
//


//----------------------------------------------------------------------------------------
//
// REVISION:
// 
// 2.12a 06/11/2015 - R. Zhou
//	1) New created
// 2.14a 03/20/2017 -L.L.Cao
//  1) Add rules:3DMIM.A.2,	3DMIM.DN.1,	3DMIM.EX.1,	3DMIM.EX.2,	3DMIM.EX.3,	3DMIM.EX.4,	3DMIM.S.1,	3DMIM.S.2,	3DMIM.S.3, 3DMIM.S.8	
//               3DMIM.S.4,	3DMIM.S.5,	3DMIM.S.6,	3DMIM.S.7,	3DMIM.W.1,	3DMIM.W.3,	3DMIM.W.4,	3DMIM.W.5,	3DMIM.W.6, 3DMIM.S.9
//               3DMIM.S.10	,MOM.A.1, MOM.R.1,	MOM.R.2,	MOM.S.2,	ANALOGDMY.A.1,	ANALOGDMY.EX.1,	ANALOGDMY.EX.2,	ANALOGDMY.R.1,	
//               ANALOGDMY.S.1, ANALOGDMY.S.2,	ANALOGDMY.S.3,	ANALOGDMY.S.4,	ANALOGDMY.W.1,	MIM_Mx.O.1,	MIM_Mx.R.1,	OD.EX.1	,OD.R.5,
//             	 RPO.A.2, 3DMIM.R.10, 3DMIM.EX.5		
//  2) modify 3DMIM CBM definition
//  3) Official release
//  4) modify ENSD_SOURCE and EPSD_SOURCE definition
//  5) Modify 3DMIM CTM_3D CBM_3D and 2DMIM CTM CBM definition
//
// 2.15a 01/31/2018 - L.L.Cao
//	1) Add switch : DEFINE ALL_AREA_IO
//	2) Modify rules : ESD.5g, ESD.18g_2.5V_P, ESD.10g, ESD.WARN.2, LUP.2g, LUP.3.1g_1.8V, LUP.3.1g_1.5V, LUP.3.2g_2.5V, LUP.3.3g_3.3V, LUP.3.4g_5V,
//					  LUP.5.1g_1.8V, LUP.5.1g_1.5V, LUP.5.2g_2.5V, LUP.5.3g_3.3V, LUP.5.4g_5V, LUP.10g__LUP.13g, LUP.14g,
//				      OD.EX.1, ANALOGDMY.W.1, ESD.40g, OD.R.5, MIM_Mx.R.1, MIM_Mx.O.1, DNW.S.2, ESD.10g
//  3) Add rules : ESD.5.1g, ESD.WARN.4, ESD.WARN.5, ESD.40g, HIA.1g, HIA.2g, HIA.3g, HIA.4g, HIA.9g, HIA.17g, HIA.18g, LUP.WARN.1,
//                 NT_N.S.2, OD.S.3, OD.S.4, OD2.R.1, DOD.DN.1, DOD.DN.2,ULLNW.S.1, ULLNW.S.2, ULLNW.S.3, ULLNW.S.4, ULLNW.W.1, ULLNW.W.2,
//                 ODLL.A.1, ODLL.E.1, ODLL.E.2, ODLL.E.3, ODLL.O.1, ODLL.R.1, ODLL.S.1, ODLL.S.2, ODLL.S.3,
//				   ODLL.S.4, ODLL.S.5, ODLL.S.6, ODLL.S.7, ODLL.W.1
//  4) Delete rules: MIM_Mx.O.1, MIM_Mx.R.1
//  5) Add MD pin text
//  6) Modify layer definition : NTAPux, PTAPux, POST_DRIVER_ACT, PAD_EXD
//  7) Modify connectivity: connect PWEL/RW with PTAP for i, j, k, u connectivity, deleted duplicated connectivity i for IFNEF C0152, remove metal slot area for connectivity
//
//-------------------------------------------------------------------------------------------


//-------------------------------------------------------------------------------------------
//
// DUMMY LAYER REQUIRED:
//
//  1) HOTWL   - Hot N-Well
//               N-Well not connected to the most positive voltage Vdd is defined as Hot N-Well. 
//               It must follow different width and space rules from the N-Well connected to 
//               Vdd (Cold N-Well). Use "HOTWL" layer to exactly cover the Hot N-Well area for 
//               correct N-Well DRC.
//
//  2) EXCL    - UN-DRC area
//               If there's any area with different rules and not to be checked in this run, 
//               use the "EXCL" layer to exactly cover the area to be excluded.
//
//  3) SDI     - I/O ESD Protection Circuit
//               For I/O guidance rule checking, use "SDI" layer to designate the ESD area to 
//               checked. The whole ESD devices should be covered by "SDI".
//
//  4) DPDMY   - Dummy Pad area
//               For chip corner dummy pad, use "DPDUMMY" layer to cover dummy pad area.
//
//  5) PLDMY   - Power Line
//               For chip corner power line, use "PLDUMMY" layer to cover whole power line area.
//
//  6) RWDMY   - NWell Resistor
//               The N-Well region covered by both RWDMY and RPO is the NW within OD resistor.
//               The N-Well region covered by only RWDMY is the NW under STI resistor.
//
//  7) DRCDMY  - TSMC reserved layer.
// 
//  8) ESD1DMY - IO ESD region dummy layer, RPO must enclose whole gate.
//     ESD2DMY - RPO enclose gate 0.05 for 3.3V.
//	   RES200  - 200ohm resistor dummy layer
//
//  9) DMN2V   - Dummy layer to ensure N2V in N+ poly/od resistor.
//     DMP2V   - Dummy layer to ensure P2V in P+ poly/od resistor.
//
// 10) RLPPDMY - LPP high resistance poly resistor
//               Use "RLPPDMY" to exactly cover LPP high resistance poly resistor area.
//
// 11) WBDMY   - Dummy layer to cover the CUP pad.
//
// 12) CTMDMY  - Capacitor bottom plate
//               Use "CTMDMY" to cover capacitor bottom plate in mixed-signal process.
// 13) INDDMY  - Dummy layer for inductor recognition in mixed-signal process.
//
// 14) LUPWDMY - DRC dummy layer to waive Latch-Up rules for verified IP. 
//
// 15) SBDDMY   - dummy layer to fully cover schottky barrier diode.
//
// 16) VSSDMY   - dummy layer to cover VSS PAD
//
// 17) VDDDMY   - dummy layer to cover VDD PAD
//-------------------------------------------------------------------------------------------
//
//                      CURRENT STATUS
//
//  RULES NOT IMPLEMENTED:
//
//  The following rules are not coded in this rule file:
//
//  rule                      description/explanation/alternate file
//  ------------------------  ----------------------------------------------------
//  Part I recommendations    Not coded (page 3 of spec.)
//
//  Antenna rules             Please refer to Antenna DRC deck.
//
//  Passivation rules         Please refer to Bond PAD DRC deck.
//
//  Metal Fuse rules          Please refer to Metal Fuse DRC deck.
//
//  SRAM rules                Not coded.
//
//  Chip Corner Power Line    Only ADP.W.1, ADP.W.2, ADP.S.1, ADP.E.1, ADP.E.2, ADP.C.1 and ADP.C.2 are coded.
//  and Dummy PAD             
//

//  Un-Checkable rules        RES.1(R), DNW.R.3(R), DNW.R.6, RES.HRI.6(R), SBD.R.7(R), CTM.R.4(R), 
//							  MIMVIA.S.1/S.2(R), MIMVIA.R.1(R), DOD.C.3(R) and DPO.C.3(R) 
//
//  * Guidelines implemented :
//
//    1) Partial I/O ESD GuideLines are implemented: 1,3-10,18-39
//       Others are not implemented because of guideline.
//
//    2) Partial LatchUp GuideLines are implemented: 1-6
//       Others are not implemented because of guideline.
//
//    3) Dummy PAD Guidlines implemented: ADP.S.2, ADP.W.3 and ADP.W.4
//
//    4) Metal stress relief guideline rules are not implemented.
//





//-------------------------------------------------------------------------------------------
//	
//  * To correctly use this DRC deck, the following settings are very important in
//    this DRC command file:
//	
//  (0) IC Validator 2014.12-SP2 is used to develop and QA this command file. 
//      Please execute the DRC with this or newer TSMC qualified version of IC Validator.
//
//==================================================================================================================
//
//
//  Pay attention to!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//     
//     Pls turn on switch (#define C016) if you use 0.16um process, Otherwise, It will cause a big risk.        
//     Pls turn on switch (#define C0152) if you use 0.152um process, Otherwise, It will cause a big risk.
//
//
//
//
//******************************************************************************************************************
//  This drc deck can be used to do check for C018 and C016 process as below:
//     
//       a. For 0.18um process
// 
//             1) C018 logic 1.8V/3.3V process (general purpose)     
//             2) C018 logic 1.8V/3.3V process (low power)           
//             3) C018 logic 1.8V/5V process   (general purpose)     
//             4) C018 logic 1.8V/5V process   (low power)           
//             5) C018 logic 1.5V/3.3V process (low voltage)         
//             6) C018 logic 1.5V/2.5V process (low voltage)         
//             7) C018 Mixed-Singal/RF 1.8V/3.3V process              
//	           8) C018 RF SBD 1.8V/3.3V process
//
//       b. For 0.16um process
// 
//             1) C016 logic/Mixed-Singal 1.8V/3.3V process          
//
//       c. For 0.152um process
// 
//             1) C0152 logic/Mixed-Singal 1.8V/3.3V process          
//
//     Note: The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule
//           you can turn on/off relted switch correctly if other process are used,.
//                  
//                    turn on in ICV drc  means remove "//" in the front of "#define XXXX"
//                    turn off in ICV drc means add "//" in the front of "#define XXXX"  
//
//********************************************************************************************************************
// 
//  There are some MUST switchs and OPTIONAL switchs in this drc deck. You must keep MUST switch turn on or trun off correctly.
//  Otherwise, you could not check drc correctly. As to OPTIONAL switch, you can turn on/off according to you requirement.
//  The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule
//  
//
//   MUST switch: 
//              
//     #define _3_3V 	    // turn on only when HIGH_VOLTAGE is 3.3V,otherwise please turn off it.
//   //#define _2_5V 	    // turn on only when HIGH_VOLTAGE is 2.5V,otherwise please turn off it
//   //#define _5V 	    // turn on only when HIGH_VOLTAGE is 5V  ,otherwise please turn off it
//     
//     #define _1_8V         // turn on only when CORE_VOLTAGE is 1.8V,otherwise please turn off it
//   //#define _1_5V 	    // turn on only when CORE_VOLTAGE is 1.5V,otherwise please turn off it
//
//   //#define LP           // turn on only when you use Low Power process,otherwise please turn off it 
//   //#define C016         // turn on only when you use 0.16um process,otherwise please turn off it
//   //#define C0152        // turn on only when you use 0.152um process,otherwise please turn off it
//   //#define MIX_MODE     // turn on only when you use Mixed-Singal/RF process,otherwise please turn off it
//                 
//   //#define THICK_40K    // turn on only when 40KA Thick Top Metal is used.otherwise please turn off it
//   //#define THICK_20K    // turn on only when 20KA Thick Top Metal is used.otherwise please turn off it   

//                          
// OPTIONAL switch:
//
//   //#define CHECK_SRAM_EXCL  // turn on  when M2 and upward layers in SRAM region covered by EXCL are checked.
//     #define CHECK_ALRDL      // turn off when MD&VIAD rules are not checked.

//     #define CHECK_DUMMY_ODPO // turn off when Dummy OD&PO are not checked.
//   //#define RECOMMEND        // turn on  when Recommended rules are checked.
//     #define GUIDELINE_LUP    // turn off when you don't want check latchup guideline rules.   
//     #define GUIDELINE_ESD    // turn off when you don't want check ESD guideline rules.
//   //#define CHECK_LATCHUP_BY_TEXT        	// Turn on to recognize IO PAD by following text
//
// For example:
//  
//    1) If your design use 0.18um Mixed-Singal/RF 1.8V/3.3V process.
// 
// Please turn on MUST switchs (#define _3_3V ; #define _1_8V; #define MIX_MODE; #define THICK_40K or #define THICK_20K) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//    
//    2) If your design use 0.18um logic 1.8V/5V Low Power process.
// 
// Please turn on MUST switchs (#define _5V; #define _1_8V; #define LP ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//
//    3) If your design use 0.18um logic 1.5V/3.3V low voltage process.
// 
// Please turn on MUST switchs (#define _1_5V; #define _3_3V ). 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement
//
//    
//    4) If your design use 0.16um logic 1.8V/3.3V process.
// 
// Please turn on MUST switchs (#define _3_3V ; #define _1_8V; #define C016 ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//
//    5) If your design use 0.16um Mixed-Singal 1.8V/3.3V process.
// 
// Please turn on MUST switchs (#define _3_3V ; #define _1_8V; #define C016; #define MIX_MODE ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//    
//    6) If your design use 0.152um Mixed-Singal 1.8V/3.3V process.
// Please turn on MUST switchs (#define _3_3V ; #define _1_8V; #define C0152; #define MIX_MODE ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//
//********************************************************************************************************************
//
//  (1) Process selection:
//      
//      The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule(T-018-LO-DR-001)
//      If other process are used, Pls turn on you use process switch and turn off other process switch.
//
//              //#define LP       // turn on only when you use Low Power process,otherwise please turn off it  
//              //#define C016     // turn on only when you use 0.16um process,otherwise please turn off it
//              //#define C0152     // turn on only when you use 0.152um process,otherwise please turn off it

//  (2) Variable for High Voltage:
//
//	The default of this DRC command file assumes 3.3V is used as high (I/O) voltage.
//	If other high voltages are used, please DEFINE other variables. For example,
//	if 2.5V is used as high voltage, then the settings should be:
//
//		//#define _3_3V 	// when HIGH_VOLTAGE is 3.3V
//		#define _2_5V 	// when HIGH_VOLTAGE is 2.5V
//		//#define _5V 	// when HIGH_VOLTAGE is 5V
//	
//
//  (3) Variable for Core Voltage:
//
//	The default of this DRC command file assumes 1.8V is used as core voltage.
//	If other core voltages are used, please DEFINE other variables. For example,
//	if 1.5V is used as core voltage, then the settings should be:
//
//		//#define _1_8V 	// when CORE_VOLTAGE is 1.8V
//		#define _1_5V 	// when CORE_VOLTAGE is 1.5V
//
//  (4) Variable for High Voltage & Core Voltage:
//
//	Please choose proper voltages for the core and I/O devices in the logic section.
//	The setting should be:
//
//		#define _3_3V 	// when HIGH_VOLTAGE is 3.3V
//		//#define _2_5V 	// when HIGH_VOLTAGE is 2.5V
//		//#define _5V 	// when HIGH_VOLTAGE is 5V
//		#define _1_8V 	// when CORE_VOLTAGE is 1.8V
//		//#define _1_5V 	// when CORE_VOLTAGE is 1.5V
//
//	To execute the runset with I/O voltage equals 3.3V and core voltage as 1.8V.
//

//  (5) Variable for check SRAM inside layer EXCL:
//
//	By default, we include DRC check inside SRAM region covered by exclude layer "EXCL(55)".
//	However, customers could turn off this option to check M2 and upward layers inside EXCL
//	in order to check logic rules inside SRAM.
//	Please notice that by default, this option will disable the waiving function of EXCL, 
//	and the region covered by EXCL will be examined with M2 and upward layers' rules.
//	Please add // to this option:
//
//		//#define CHECK_SRAM_EXCL
//
//  (6) Sealring option: 
//  By default, this option is enable for whole chip layout with sealring structure.
//  Chip corner, Sealring, Assembly isolation, chip edge, and exclusion for density check will be affected 
//  by this options. If sealring is not assembled in chip layout, please turn off this option.     
//  If the option "FULL_CHIP" is disable, this option does not work.
//		//#define WITH_SEALRING
//
//  (7) Variable for MD&VIAD rule checking:
//
//	By default, MD&VIAD rules are checked in this deck. If MD&VIAD rules are not required
//	to check, please add // to this option:
//
//		//#define CHECK_ALRDL
//

//  (8) Variable for dummy OD&PO rule checking:
//
//	By default, dummy OD&PO are not checked by rules in this deck. But some unnecessary rule 
//	checks may induce false alarm. If dummy OD&PO are required to check, please
//	remove // to this option:
//
//		#define CHECK_DUMMY_ODPO
//
//	Note: If this option is disabled, please make sure the LVS result is correct after 
//	      dummy insertion to prevent from dummy pattern induced layout circuit short.
//
//  (9) Variable for Mixed-Signal/RF circuit design:
//
//	By default, this DRC deck is used for Mixed-Signal/RF process. When this DRC deck is
//	used for general Logic process, please add // to this option:
//
//		//#define MIX_MODE
//

//  (10) FULL_CHIP :
//    By default, this option is for whole chip layout for the rules about sealring and dummy PAD.   
//    If the layout is a cell, please add // to this option.
//            
//              //#define FULL_CHIP
//
//  (11) Variable for Thick Top Metal check:
//
//	By default, the Top Metal is Normal Top Metal. If customer uses 20KA or 40KA Thick Top 
//	Metal, please remove // to the option 'THICK_40K' or 'THICK_20K',But only one should be turn on every time.
//
//	For 20k Top metal:
//		//#define THICK_40K
//		#define THICK_20K
//
//	For 40k Top metal:
//		#define THICK_40K
//		//#define THICK_20K

//  (12) Variable for recommended rule check:
//
//	By default, recommended rules are not checked, but it is suggested to remove // to 
//	enable this option from the point of view of noise isolation and SPICE model accuracy.

//	The recommended rule check includes NW.R.1, NWR.R.7, OD.C.7, VIAx.E.3, VIAn.E.3, CB.W.3, UTM20K/40K.I.3, 
//  UTM20K/40K.C.1, ESDIMP.EN.1, DNW.E.1, DNW.S.2, AN.R.41m, DPO.R.1, and RES rules.
//
//		#define RECOMMEND
//

//  (13) Latch-up guideline check:
//
//	By default, This command file will check Latch-up guideline rules,
//	please add // if you don't want check these rules:
//
//		//#define GUIDELINE_LUP
//
//  (14) DISCONNECT_ALL_RESISTOR & CONNECT_ALL_RESISTOR:
//  By default, the connection is broken by resistors with dummy layer RES200 for Latch-Up rule checks. 
//  The switches of DISCONNECT_ALL_RESISTOR and CONNECT_ALL_RESISTOR can control the connectivity of resistor.
//  Turn on DISCONNECT_ALL_RESISTOR option will disconnect all resistors between pad and device for Latch-Up rule check.
//  Turn on CONNECT_ALL_RESISTOR option will connect all resistors between pad and device for Latch-Up rule check.
//	    //#define DISCONNECT_ALL_RESISTOR 
//		//#define CONNECT_ALL_RESISTOR
//
//  (15) ESD guideline check:
//
//	By default, This command file will check ESD guideline rules,
//	please add // if you don't want check these rules:
//
//      	//#define GUIDELINE_ESD
//
//  (16) Variable CHECK_LATCHUP_BY_TEXT:
//     DRC uses CB/CBD/CB2/UBM layer to recognize PAD, and uses the connection
//     of well strap to distinguish IO PAD and VDD/VSS PAD. So latch-up rules can not be
//     checked in cell level if no CB/CBD/CB2/UBM layer exists. Also,if VDD/VSS pad is not
//     connected to strap, it will be falsely recognized as IO pad. 
//     You can remove // this option to solve these inconveniences. Assign the PAD/VDD/VSS pin name in
//     Variables (PAD_TEXT/VDD_TEXT/VSS_TEXT). Notice that only text by metal pin layer in top cell
//     is used for latch-up check.
//
//     By default, the switch CHECK_LATCHUP_BY_TEXT is off. If you want to recognize VDD/VSS/PAD by pin name,
//     you could remove // this switch as follow:
//
//              #define CHECK_LATCHUP_BY_TEXT
//
//  (17) DENSITY_IN_BLOCKAGE :
//      By default, this option is for local density check. 
//      If customer want to check local density within blockage layers only, please remove // to this option.
//
//              #define DENSITY_IN_BLOCKAGE
//
//  (18) BigSealringCorner option:
//      If customer requests TSMC to add chip corner stress relief pattern, seal ring and CDU,
//	    empty areas in 4 chip corners must be reserved and no layout is allowed inside. 
//	    By default, this option is enabled and "big seal-ring corner" will be used as chip 
//      corner stress relief patterns.
//	            #define BIGSEALRINGCORNER
//	            // #define SMALLSEALRINGCORNER  
//
//  (19) SmallSealringCorner option:
//  	If customer requests TSMC to add chip corner stress relief pattern, seal ring and CDU,
//	    empty areas in 4 chip corners must be reserved and no layout is allowed inside. 
//      If "SmallSealringCorner" structure is used as chip corner stress relief patterns in 
//      your design, please remove // this option for proper checking as below :
//              // #define BIGSEALRINGCORNER  
//              #define SMALLSEALRINGCORNER  
//     
//  (20) AAIO :
//		Plese remove // to turn on for treat OD injector as same as AAIO .
//		#define ALL_AREA_IO
//      
//---------------------------------------------------------------------


//-------------------------------------------------------------------------------------------
#include <icv.rh>

#ifdef VERSION_LT
#if VERSION_LT(2014, 12, 2, 0)
#error This PXL runset was generated to run with ICV versions 2014.12-SP2 and newer.
#endif
#endif


// OPTION SETUP
//===============

//#define CHECK_SRAM_EXCL                   /* turn on only when you want check M2 and upward layers in SRAM region covered by EXCL. otherwise please turn off it */ 
#define CHECK_ALRDL                       /* turn on only when you want check MD&VIAD rules. otherwise please turn off it */ 
//#define CHECK_DUMMY_ODPO                /* turn on only when you want check Dummy OD&PO. otherwise please turn off it */ 
#define GUIDELINE_LUP                     /* turn on only when you want check latchup guideline rules. otherwise please turn off it */ 
//#define DISCONNECT_ALL_RESISTOR         /* turn on only when you want to disconnect all resistors to check latchup rules, otherwise please turn off it */ 
//#define CONNECT_ALL_RESISTOR            /* turn on only when you want to connect all resistors to check latchup rules, otherwise please turn off it */ 
#define GUIDELINE_ESD                     /* turn on only when you want check ESD guideline rules. otherwise please turn off it */ 
//#define RECOMMEND                       /* turn on only when you want to check Recommended rules. otherwise please turn off it */ 
//#define MIX_MODE                        /* turn on only when you use Mixed-Singal/RF process. otherwise please turn off it */ 
//#define THICK_40K                       /* turn on only when 40KA Thick Top Metal is used. otherwise please turn off it */ 
//#define THICK_20K                       /* turn on only when 20KA Thick Top Metal is used. otherwise please turn off it */ 
//#define LP                              /* turn on only when you use Low Power process. otherwise please turn off it  */ 
//#define C016                            /* turn on only when you use 0.16um process. otherwise please turn off it */ 
//#define C0152                           /* turn on only when you use 0.152um process. otherwise please turn off it */ 
#define _3_3V                              /* turn on only when HIGH_VOLTAGE is 3.3V. otherwise please turn off it */ 
//#define _5V                              /* turn on only when HIGH_VOLTAGE is 5V. otherwise please turn off it */ 
//#define _2_5V                            /* turn on only when HIGH_VOLTAGE is 2.5V. otherwise please turn off it */ 
#define _1_8V                              /* turn on only when CORE_VOLTAGE is 1.8V. otherwise please turn off it */ 
//#define _1_5V                            /* turn on only when CORE_VOLTAGE is 1.5V. otherwise please turn off it */ 
//#define CHECK_LATCHUP_BY_TEXT           /* Turn on to recognize IO PAD by following text   */ 
v_ci_PAD_TEXT : list of string = { "*" };
PAD_TEXT : list of string = { "*" };    /* pin name of PAD */ 
v_ci_VDD_TEXT : list of string = { "[A][V][dD][dD][bB][G]", "[A][V][dD][dD][rR]", "[A][V][dD][wW][eE][lL][lL]", "[V][dD][wW][eE][lL][lL]", "[V][dD]33[A][pP][S][T]", "[V][dD][dD]5[V]", "[T][A][V][dD]33", "[V][dD]33[pP][S][T]", "[A][V][dD][dD]", "[T][A][V][dD][dD]", "[T][A][V][dD]33[pP][S][T]", "[T][A][V][dD][dD][pP][S][T]", "[A][V][dD]33[bB]", "[V][dD][dD]", "[A][V][dD]33[G]", "[dD][V][dD][dD]", "[A][V][dD][dD][G]", "[A][V][dD][dD][bB]", "[V][dD][dD][G]", "[V][dD][dD][pP][S][T]", "[V][dD]33[rR][eE][fF]", "[V][dD]33", "[A][V][dD]33[rR]", "[V][dD][dD][S][A]" }; 
VDD_TEXT : list of string = { "AVDDBG", "AVDDR", "AVDWELL", "VDWELL", "VD33APST", "VDD5V", "TAVD33", "VD33PST", "AVDD", "TAVDD", "TAVD33PST", "TAVDDPST", "AVD33B", "VDD", "AVD33G", "DVDD", "AVDDG", "AVDDB", "VDDG", "VDDPST", "VD33REF", "VD33", "AVD33R", "VDDSA" };    /* pin name of VDD */ 
v_ci_VSS_TEXT : list of string = { "[V][S][S][pP][S][T]", "[A][V][S]33[rR]", "[A][V][S][S][uU][bB]", "[V][S][S][rR][eE][fF]", "[V][S][S][A][pP][S][T]", "[V][S]33[A][pP][S][T]", "[dD][V][S][S]", "[A][V][S]33[G]", "[A][V][S][S][bB][G]", "[T][A][V][S][S]", "[A][V][S]33[bB]", "[A][V][S][S][bB]", "[G][nN][dD]", "[V][S][S][G]", "[V][S][S][uU][bB]", "[V][S][S]", "[A][V][S][S]", "[T][A][V][S][S][pP][S][T]", "[A][G][nN][dD]", "[A][V][S][S][rR]", "[A][V][S][S][G]" }; 
VSS_TEXT : list of string = { "VSSPST", "AVS33R", "AVSSUB", "VSSREF", "VSSAPST", "VS33APST", "DVSS", "AVS33G", "AVSSBG", "TAVSS", "AVS33B", "AVSSB", "GND", "VSSG", "VSSUB", "VSS", "AVSS", "TAVSSPST", "AGND", "AVSSR", "AVSSG" };    /* pin name of VSS  */ 
//#define FULL_CHIP                       /* Turn on for chip level design of sealring and dummy PAD, otherwise please turn off it. */ 
//#define DENSITY_IN_BLOCKAGE             /* turn on only when to check density within blockage layers */ 
#define BIGSEALRINGCORNER                 /* Turn on to use big seal-ring corner for whole chip design */ 
//#define SMALLSEALRINGCORNER             /* Turn on to use small seal-ring corner for whole chip design */ 
//#define WITH_SEALRING                   /* Turn on to check sealring rules */ 
//#define ALL_AREA_IO                     /* Turn on for treat OD injector as same as AAIO */ 
GRID : double = 0.005; 
G_1 : double = 5; 
UTM40K_W_1 : double = 2.6; 
UTM40K_S_1 : double = 2.5; 
UTM40K_A_1 : double = 6.76; 
UTM40K_C_1 : double = 50.0; 
UTM40K_R_1 : double = 30; 
UTM40K_R_2 : double = 80; 
UTM40K_R_3 : double = 5; 
UTM40K_A_2 : double = 75; 
UTM40K_A_2_S : double = 10; 
UTM40K_E_3 : double = 10.0; 
UTM20K_W_1 : double = 1.5; 
UTM20K_S_1 : double = 1.5; 
UTM20K_A_1 : double = 2.25; 
UTM20K_C_1 : double = 50.0; 
UTM20K_E_3 : double = 10.0; 
MHOLE : double = 10.0; 
NT_N_S_1 : double = 0.86; 
NT_N_E_1 : double = 0.26; 
NT_N_C_1 : double = 0.52; 
NT_N_C_2 : double = 1.66; 
OD_W_3_J : double = 0.42; 
OD_W_3_T : double = 0.8; 
OD_C_7 : double = 0.36; 
OD_C_2_1 : double = 0.6; 
OD_C_4_1 : double = 0.8; 
OD2_W_1 : double = 0.6; 
PO_C_2 : double = 0.32; 
PP_W_1 : double = 0.44; 
PP_S_1 : double = 0.44; 
PP_C_1 : double = 0.26; 
PP_C_5 : double = 0.32; 
PP_E_1 : double = 0.18; 
PP_E_6 : double = 0.18; 
PP_E_6_2 : double = 0.18; 
NP_W_1 : double = 0.44; 
NP_S_1 : double = 0.44; 
NP_C_1 : double = 0.26; 
NP_C_5 : double = 0.32; 
NP_E_1 : double = 0.18; 
RPO_S_1 : double = 0.43; 
RPO_C_2 : double = 0.22; 
CO_E_3 : double = 0.12; 
CO_E_4 : double = 0.12; 
M1_S_2 : double = 0.6; 
M1_S_2_1 : double = 0.6; 
M1_S_2_2 : double = 0.6; 
M1_S_2_L : double = 35.0; 
M2_S_2_1 : double = 0.6; 
M2_S_2_2 : double = 0.6; 
M2_S_2_L : double = 35.0; 
M3_S_2_1 : double = 0.6; 
M3_S_2_2 : double = 0.6; 
M3_S_2_L : double = 35.0; 
M4_S_2_1 : double = 0.6; 
M4_S_2_2 : double = 0.6; 
M4_S_2_L : double = 35.0; 
M5_S_2_1 : double = 0.6; 
M5_S_2_2 : double = 0.6; 
M5_S_2_L : double = 35.0; 
M6_S_2_1 : double = 0.6; 
M6_S_2_2 : double = 0.6; 
M6_S_2_L : double = 35.0; 
MD_S_2_1 : double = 0.6; 
MD_S_2_2 : double = 0.6; 
MD_S_2_L : double = 35.0; 
M1_A_1 : double = 0.202; 
MX_A_1 : double = 0.202; 
VIAN_W_1 : double = 0.36; 
VIAN_S_1 : double = 0.35; 
VIAD_W_1 : double = 0.36; 
VIAD_S_1 : double = 0.35; 
NT_N_S_2 : double = 1.66; 
DOD_DN_1_W : double = 150; 
DOD_DN_1_S : double = 75; 
DOD_DN_1 : double = 0.2; 
DOD_DN_2_W : double = 150; 
DOD_DN_2_S : double = 75; 
DOD_DN_2 : double = 0.8; 
#ifdef C016 
   SR_S_1 : double = 5.5; 
#else
   #ifdef C0152 
      SR_S_1 : double = 5.95; 
   #else
      SR_S_1 : double = 5.0; 
   #endif
#endif
SR_E_1 : double = 0.6; 
SR_E_2 : double = 4.1; 
CO_W_2 : double = 0.22; 
VIA1_W_2 : double = 0.26; 
VIA2_W_2 : double = 0.26; 
VIA3_W_2 : double = 0.26; 
VIA4_W_2 : double = 0.26; 
VIAN_W_2 : double = 0.36; 
NW_S_3 : double = 2.0; 
NW_S_4 : double = 2.0; 
NT_N_W_1 : double = 0.74; 
PO_C_3 : double = 0.15; 
PO_C_4 : double = 0.15; 
RES_2_W : double = 1.0; 
RES_13 : double = 0.2; 
RES_14 : double = 0.6; 
RES_2_NSQ : double = 5.0; 
RES_12_W : double = 2.0; 
RES_12_NSQ : double = 5.0; 
RES_HRI_9 : double = 0.6; 
RES_HRI_12 : double = 0.25; 
VIA2_E_3 : double = 0.06; 
VIA3_E_3 : double = 0.06; 
VIA4_E_3 : double = 0.06; 
VIA5_E_3 : double = 0.06; 
VIAD_E_3 : double = 0.06; 
ESD_3G : double = 360.0; 
ESD_5G : double = 2000.0; 
ESD_5_1G : double = 1800.0; 
ESD_10G : double = 2.4; 
ESDIMP_W_1 : double = 0.6; 
ESDIMP_S_1 : double = 0.6; 
ESDIMP_S_2 : double = 0.6; 
ESDIMP_EN_1 : double = 0.4; 
ESDIMP_A_1 : double = 1.0; 
ESDIMP_A_2 : double = 1.0; 
DNW_W_1_0152 : double = 3.570; 
DNW_S_1_0152 : double = 5.950; 
PO_R_2 : double = 50.0; 
MIM_M5_W_1 : double = 35.0; 
MIM_M5_S_1 : double = 0.80; 
MIM_M5_S_2 : double = 0.80; 
MIM_M5_E_3 : double = 0.40; 
CTM_W_1 : double = 4.0; 
CTM_W_2 : double = 0.4; 
CTM_S_1 : double = 1.2; 
CTM_S_2 : double = 0.8; 
CTM_W_4 : double = 30.0; 
CTM_A_1 : double = 0.202; 
MIMVIA_S_1 : double = 2.00; 
MIMVIA_S_2 : double = 4.00; 
MIMVIA_E_1 : double = 0.24; 
MIMVIA_E_2 : double = 0.12; 
MIMVIA_C_1 : double = 0.40; 
ANALOGDMY_A_1 : double = 1.71; 
ANALOGDMY_EX_1 : double = 0.32; 
ANALOGDMY_EX_2 : double = 0.4; 
ANALOGDMY_S_1 : double = 0.45; 
ANALOGDMY_S_2 : double = 0.32; 
ANALOGDMY_S_3 : double = 0.4; 
ANALOGDMY_S_4 : double = 0.26; 
ANALOGDMY_W_1 : double = 1.26; 
_3DMIM_A_1 : double = 0.202; 
_3DMIM_A_2 : double = 0.202; 
_3DMIM_EX_1 : double = 0.4; 
_3DMIM_EX_2 : double = 0.24; 
_3DMIM_EX_3 : double = 0.4; 
_3DMIM_EX_4 : double = 0.24; 
_3DMIM_EX_5 : double = 0.12; 
_3DMIM_S_1 : double = 0.4; 
_3DMIM_S_2 : double = 2; 
_3DMIM_S_3 : double = 2; 
_3DMIM_S_4 : double = 1.2; 
_3DMIM_S_5 : double = 0.8; 
_3DMIM_S_6 : double = 4; 
_3DMIM_S_7 : double = 0.4; 
_3DMIM_S_8 : double = 0.8; 
_3DMIM_S_9 : double = 0.8; 
_3DMIM_S_10 : double = 4; 
_3DMIM_W_1 : double = 4.0; 
_3DMIM_W_2 : double = 0.4; 
_3DMIM_W_3 : double = 0.6; 
_3DMIM_W_4 : double = 0.8; 
_3DMIM_W_5 : double = 30.0; 
_3DMIM_W_6 : double = 4.0; 
MOM_S_2 : double = 0.5; 
MOM_A_1 : double = 1.64E15; 
RPO_A_2 : double = 1.0; 
OD_EX_1 : double = 0.18; 
M1_W_1 : double = 0.23; 
M1_S_1 : double = 0.23; 
M2_W_1 : double = 0.28; 
M2_S_1 : double = 0.28; 
M3_W_1 : double = 0.28; 
M3_S_1 : double = 0.28; 
M4_W_1 : double = 0.28; 
M4_S_1 : double = 0.28; 
M5_W_1 : double = 0.28; 
M5_S_1 : double = 0.28; 
#ifdef THICK_40K 
   M6_W_1 : double = 2.6; 
   M6_S_1 : double = 2.5; 
#else
   #ifdef THICK_20K 
      M6_W_1 : double = 1.5; 
      M6_S_1 : double = 1.5; 
   #else
      M6_W_1 : double = 0.44; 
      M6_S_1 : double = 0.46; 
   #endif
#endif
M1_THICKNESS : double = 0.53;        /* The Thickness of Inter Metal is 4K A */ 
M2_THICKNESS : double = 0.53;        /* The Thickness of Inter Metal is 4K A */ 
M3_THICKNESS : double = 0.53;        /* The Thickness of Inter Metal is 4K A */ 
M4_THICKNESS : double = 0.53;        /* The Thickness of Inter Metal is 4K A */ 
M5_THICKNESS : double = 0.53;        /* The Thickness of Inter Metal is 4K A */ 
#ifdef THICK_40K 
   M6_THICKNESS : double = 4.6;      /* The Thickness of Top Metal is 40K A */ 
#else
   #ifdef THICK_20K 
      M6_THICKNESS : double = 2.34;    /* The Thickness of Top Metal is 20K A */ 
   #else
      M6_THICKNESS : double = 0.99;    /* The Thickness of Top Metal is 8K A */ 
   #endif
#endif
RPO_A_2PRE : double = ( ( RPO_A_2 + ( RPO_S_1 * RPO_S_1 * 3.142 ) ) / ( 2 * RPO_S_1 ) ) * ( ( RPO_A_2 + ( RPO_S_1 * RPO_S_1 * 3.142 ) ) / ( 2 * RPO_S_1 ) ) / 3.141; 

// Density check M5.R.1 included at the end of this file
/* ****  Variables for IMD crack check **** */
VIA_W_1 : double = 5.0;              /* The width of ViaArray */ 
VIA_S_1 : double = 5.0;              /* VIA ARAAY interal space.  */ 
VIA_S_2 : double = 2.7;              /* Space of metal between via array */ 
MX_S_3_7 : double = 1.2;             /* Space of both metal with larger via array area */ 
VIA_S_2L : double = 15.0;            /* via array parrallel run length */ 
VIA_S_4 : double = 5.0;              /* Metal extension space  */ 
VIA_S_5 : double = 12.7;             /* Space of VIA array (5.0+2.7+5.0) */ 
VIA_A_5 : double = 300.0;            /* The overlap area of 5 level continuous stack via array. */ 
VIA_A_5_B : double = 500.0;          /* The overlap area of 5 level continuous stack via array for viax.s.6. */ 
VIA_A_4 : double = 725.0;            /* The overlap area of 4 level continuous stack via array. */ 
VIA_A_4_B : double = 1000.0;         /* The overlap area of 4 level continuous stack via array for viax.s.7. */ 
VIA_A_3 : double = 960.0;            /* The overlap area of 3 level continuous stack via array. */ 
VIA_A_3_B : double = 2000.0;         /* The overlap area of 3 level continuous stack via array for viax.s.8. */ 
VIA_A_2 : double = 3000.0;           /* The overlap area of 2 level continuous stack via array. */ 
VIA_A_2_B : double = 4000.0;         /* The overlap area of 2 level continuous stack via array for viax.s.9. */ 
VIA_A_1 : double = 4900.0;           /* The region area of single layer via array for viax.s.10. */ 
VIA_MERGE : double = 2.505;          /* The Merge error VIAs and highlight error vias region */ 
VIA_D_1 : double = 0.10;             /* The highlight array minimum density */ 
VIA_S_3 : double = 0.49;             /* Space of via in via array. */ 
VIA_FILTER : double = 3.0;           /* Shrink via arrary For broken small metal connection. */ 
HIA_1G : double = 2.0; 
HIA_2G : double = 10; 
HIA_3G : double = 300.000; 
HIA_4G : double = 0.28; 
HIA_5G : double = 0.28; 
LUP_2 : double = 20.0; 
LUP_2_S : double = 8.0; 
LUP_3_1 : double = 3.0; 
LUP_3_2 : double = 6.0; 
LUP_3_3 : double = 12.0; 
LUP_3_4 : double = 23.0; 
LUP_4 : double = 0.42; 
LUP_5_1 : double = 3.0; 
LUP_5_2 : double = 6.0; 
LUP_5_3 : double = 12.0; 
LUP_5_4 : double = 23.0; 
LUP_5_4_1 : double = 40.0;           /* limitation */ 
LUP_6 : double = 30.0; 
LUP_6_SRAM : double = 40.0; 
LUP_10 : double = 75.0; 
LUP_13 : double = 15.0; 
LUP_14 : double = 0.42; 
NW_S_1 : double = 0.6; 

//DUMMY OD RULE
//================
//DOD VARIABLE
DOD_W_1 : double = 2.0; 
DOD_S_1 : double = 1.2; 
DOD_C_1 : double = 1.2; 
DOD_C_2 : double = 1.2; 
DOD_C_4 : double = 0.6; 
DOD_C_5 : double = 1.2; 
DOD_C_6 : double = 1.2; 
DOD_C_7 : double = 1.2; 
DOD_C_8 : double = 3.0; 
DOD_C_9 : double = 1.2; 
DOD_C_13 : double = 1.2; 
DOD_C_14 : double = 10.0; 
DOD_C_15 : double = 10.0; 
DOD_E_1 : double = 0.6; 
DOD_E_2 : double = 5.0; 
OD_R_1 : double = 0.2; 
OD_R_2 : double = 0.8; 
OD_R_W : double = 500.0; 
OD_R_S : double = 250.0; 
OD_R_A : double = 62500.0; 
OD_R_3 : double = 0.25; 
OD_R_4 : double = 0.75; 
OD_S_3 : double = 0.43; 
OD_S_4 : double = 0.43; 

//DUMMY PO RULE
//================
//DPO VARIABLE
DPO_W_1 : double = 0.6; 
DPO_S_1 : double = 0.3; 
DPO_C_1 : double = 1.2; 
DPO_C_2 : double = 1.2; 
DPO_C_4 : double = 1.2; 
DPO_C_5 : double = 1.2; 
DPO_C_6 : double = 3.0; 
DPO_C_7 : double = 1.2; 
DPO_C_9 : double = 0.3; 
DPO_C_12 : double = 10.0; 
DPO_C_13 : double = 1.2; 
DPO_C_14 : double = 10.0; 
DPO_E_1 : double = 5.0; 
DPO_A_1 : double = 1.2; 
PO_R_5 : double = 0.14; 

library( 
    cell         = "TOPCELLNAME",
    format       = GDSII,
    library_name = "GDSFILENAME"
);
error_options( 
    error_limit_per_check   = 10000    /* MAXIMUM RESULTS limited from 'ALL' */
);
gds_options( 
    box            = CONVERT_TO_RECT,
    duplicate_cell = DROP
);
resolution_options( 
    internal_resolution = 0.001
);
layout_drawn_options( 
    self_intersect        = true,
    self_intersect_action = FILL
);
layout_grid_options( 
    check_45   = {POLYGON, PATH},
    check_90   = {},
    resolution = 0.005
);
text_options( 
    colon_text     = REGULAR_TEXT,
    semicolon_text = REGULAR_TEXT
);
run_options( 
    uppercase = true
);

#ifdef OVERRIDE_FILE
#include "override_file.rs"
#endif

CONNECT_DB : connect_database = NULL_CONNECT_DATABASE;
_den_con : constraint of double;
_den_polygon_area_clip : boolean;
_den_print : boolean;
_den_print_only : boolean;

/* Begin of Equation Code-Based Functions definitions */

#define dblnp(value) (((value) > 0.0) ? 0.0 : 1.0)

#define dblz(value) ((((value) < 0.0) || ((value) > 0.0)) ? 0.0 : 1.0)

#define dblnz(value) ((((value) < 0.0) || ((value) > 0.0)) ? 1.0 : 0.0)
size_inside_wrapper : published function (
    layer1           : polygon_layer,
    bounding         : polygon_layer,
    distance         : double,
    increment        : double = 0.0,
    corner_extension : corner_extension_e = INTERSECTION,
    radial_sectors   : integer = 0
)
    returning size_inside_wrapper_result : polygon_layer
{
    size_pl : polygon_layer;

    if (dblge(increment, distance) || dbleq(increment, 0.0)) {
        size_pl  = size(layer1, distance, clip_acute = BISECTOR, corner_extension = corner_extension, radial_sectors   = radial_sectors);
        size_inside_wrapper_result = and(size_pl, bounding);
    }
    else {
        size_pl  = size(layer1, increment, clip_acute = BISECTOR, corner_extension = corner_extension, radial_sectors   = radial_sectors);
        size_inside_wrapper_result =
            size_inside(size_pl,
                        bounding,
                        distance         = distance - increment,
                        increment        = increment,
                        output_type      = OVERSIZE,
                        corner_extension = corner_extension,
                        radial_sectors   = radial_sectors);
    }
}


double_constraint_contains_density : published function (
    con : constraint of double,
    val : double
)
    returning result : boolean
{
    cat = con.category();

    result = false;

    if (cat == CONSTRAINT_EQ) {
        result = dbleq((val-con.lo())*1e8,0);
    }
    elif (cat == CONSTRAINT_NE) {
        result = dblne((val-con.lo())*1e8,0);
    }
    elif (cat == CONSTRAINT_GE) {
        result = dblge((val-con.lo())*1e8,0);
    }
    elif (cat == CONSTRAINT_GT) {
        result = dblgt((val-con.lo())*1e8,0);
    }
    elif (cat == CONSTRAINT_LE) {
        result = dblle((val-con.hi())*1e8,0);
    }
    elif (cat == CONSTRAINT_LT) {
        result = dbllt((val-con.hi())*1e8,0);
    }
    elif (cat == CONSTRAINT_GELE) {
        result = (dblge((val-con.lo())*1e8,0) && dblle((val-con.hi())*1e8,0));
    }
    elif (cat == CONSTRAINT_GELT) {
        result = (dblge((val-con.lo())*1e8,0) && dbllt((val-con.hi())*1e8,0));
    }
    elif (cat == CONSTRAINT_GTLE) {
        result = (dblgt((val-con.lo())*1e8,0) && dblle((val-con.hi())*1e8,0));
    }
    elif (cat == CONSTRAINT_GTLT) {
        result = (dblgt((val-con.lo())*1e8,0) && dbllt((val-con.hi())*1e8,0));
    }
}
    
double_constraint_contains : published function (
    con : constraint of double,
    val : double
)
    returning result : boolean
{
    cat = con.category();

    result = false;

    if (cat == CONSTRAINT_EQ) {
        result = dbleq(val, con.lo());
    }
    elif (cat == CONSTRAINT_NE) {
        result = dblne(val, con.lo());
    }
    elif (cat == CONSTRAINT_GE) {
        result = dblge(val, con.lo());
    }
    elif (cat == CONSTRAINT_GT) {
        result = dblgt(val, con.lo());
    }
    elif (cat == CONSTRAINT_LE) {
        result = dblle(val, con.hi());
    }
    elif (cat == CONSTRAINT_LT) {
        result = dbllt(val, con.hi());
    }
    elif (cat == CONSTRAINT_GELE) {
        result = (dblge(val, con.lo()) && dblle(val, con.hi()));
    }
    elif (cat == CONSTRAINT_GELT) {
        result = (dblge(val, con.lo()) && dbllt(val, con.hi()));
    }
    elif (cat == CONSTRAINT_GTLE) {
        result = (dblgt(val, con.lo()) && dblle(val, con.hi()));
    }
    elif (cat == CONSTRAINT_GTLT) {
        result = (dblgt(val, con.lo()) && dbllt(val, con.hi()));
    }
}

nar_funcs_e : newtype enum of {
    UNKNOWN,
    NAR_SAVE_NET_1,
    NAR_SAVE_NET_2,
    NAR_SAVE_NET_3,
    NAR_SAVE_NET_4,
    NAR_SAVE_NET_5,
    NAR_SAVE_NET_6,
    NAR_SAVE_NET_8,
    NAR_SAVE_NET_9,
    NAR_SAVE_NET_10,
    NAR_SAVE_NET_11,
    NAR_SAVE_NET_12,
    NAR_SAVE_NET_13,
    NAR_SAVE_NET_14,
    NAR_SAVE_NET_15,
    NAR_SAVE_NET_19
};
nar_void_func_s : newtype struct of {
    func : function (void) returning void;
};
nar_void_func_h : newtype hash of nar_funcs_e to nar_void_func_s;
nar_constrained_area_s : newtype struct of {
    area    : constraint of double = > 0;
    layer1  : string               = "";
    factor1 : double               = 1.0;
    layer2  : string               = "";
    factor2 : double               = 1.0;
};
nar_constrained_areas_h : newtype hash of string to nar_constrained_area_s;

net_area_ratio : published function (
    cdb_in            : connect_database,
    con               : constraint of double,
    layer_groups      : layer_groups_h,
    denominator_start : integer,
    denominator_end   : integer,
    constrained_areas : nar_constrained_areas_h = { },
    func_enum         : nar_funcs_e             = UNKNOWN,
    expr_is_default   : boolean                 = false
)
    returning net_area_ratio_result : polygon_layer
{
    nar_funcs   : nar_void_func_h = { };
    nar_func    : function (void) returning void;
    con2any     : list of polygon_layer = { };
    not_con2any : list of polygon_layer = { };
    n_layer_0   : polygon_layer;

    /* Declare and register equation code function. */
    nar_save_net_1 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");

        ratio = dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_1] = { nar_save_net_1 };
 
    /* Declare and register equation code function. */
    nar_save_net_2 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");

        ratio = dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) + dblnz(areaL5) + dblnz(areaL6) + dblnz(areaL7) + dblnz(areaL8);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_2] = { nar_save_net_2 };
 
    /* Declare and register equation code function. */
    nar_save_net_3 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");

        ratio = dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) + dblnz(areaL5) + dblnz(areaL6) + dblnz(areaL7);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_3] = { nar_save_net_3 };
 
    /* Declare and register equation code function. */
    nar_save_net_4 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");
        areaL9 = ns_net_area("layer9");

        ratio = dblz(areaL2) * dblz(areaL3) * dblz(areaL4) * dblz(areaL5) * dblz(areaL6) * dblz(areaL7) * dblz(areaL8) + dblz(areaL9);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_4] = { nar_save_net_4 };
 
    /* Declare and register equation code function. */
    nar_save_net_5 : function (void) returning void
    {
        countL1 = ns_net_data_count("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");

        ratio = dblnp( countL1 - 1 ) * dblz(areaL2) * dblz(areaL3) * dblz(areaL4) * dblz(areaL5) * dblz(areaL6) * dblz(areaL7) * dblz(areaL8);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_5] = { nar_save_net_5 };
 
    /* Declare and register equation code function. */
    nar_save_net_6 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        con_eq_zero : boolean = ((con.category() == CONSTRAINT_EQ) && dbleq(con.lo(), 0));
        if (( areaL2 > 0) || con_eq_zero) {
            ratio = ( areaL2 > 0) ? (areaL1 / areaL2) : 0;

            if (double_constraint_contains(con, ratio)) {
                ns_save_net({"ratio"}, {ratio});
            }
        }
    }
    nar_funcs[NAR_SAVE_NET_6] = { nar_save_net_6 };
 
    /* Declare and register equation code function. */
    nar_save_net_8 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        con_eq_zero : boolean = ((con.category() == CONSTRAINT_EQ) && dbleq(con.lo(), 0));
        if (( areaL1 > 0) || con_eq_zero) {
            ratio = ( areaL1 > 0 ) ? areaL2 / areaL1 : 0;

            if (double_constraint_contains(con, ratio)) {
                ns_save_net({"ratio"}, {ratio});
            }
        }
    }
    nar_funcs[NAR_SAVE_NET_8] = { nar_save_net_8 };
 
    /* Declare and register equation code function. */
    nar_save_net_9 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        ratio = dblnz(areaL1) * dblnz(areaL2);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_9] = { nar_save_net_9 };
 
    /* Declare and register equation code function. */
    nar_save_net_10 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");

        ratio = dblnz(areaL1) * dblz(areaL5) * ( dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) );

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_10] = { nar_save_net_10 };
 
    /* Declare and register equation code function. */
    nar_save_net_11 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        ratio = dblnz(areaL1) * dblz(areaL2);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_11] = { nar_save_net_11 };
 
    /* Declare and register equation code function. */
    nar_save_net_12 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");

        ratio = dblnz(areaL2) + areaL3 + dblnz(areaL4);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_12] = { nar_save_net_12 };
 
    /* Declare and register equation code function. */
    nar_save_net_13 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");

        ratio = areaL1 / GRID; 

        if (double_constraint_contains(con, ratio) && !isinf(ratio) && !isnan(ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_13] = { nar_save_net_13 };
 
    /* Declare and register equation code function. */
    nar_save_net_14 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");

        ratio = dblnz(areaL1) * ( dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) );

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_14] = { nar_save_net_14 };
 
    /* Declare and register equation code function. */
    nar_save_net_15 : function (void) returning void
    {
        perimeterL1 = ns_net_perimeter("layer1");

        ratio = perimeterL1;

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_15] = { nar_save_net_15 };
 
    /* Declare and register equation code function. */
    nar_save_net_19 : function (void) returning void
    {
        perimeterL2 = ns_net_perimeter("layer2");
        perimeterL3 = ns_net_perimeter("layer3");
        perimeterL4 = ns_net_perimeter("layer4");
        perimeterL5 = ns_net_perimeter("layer5");
        perimeterL6 = ns_net_perimeter("layer6");
        perimeterL7 = ns_net_perimeter("layer7");

        ratio = ( perimeterL2 * M1_THICKNESS + perimeterL3 * M2_THICKNESS + perimeterL4 * M3_THICKNESS + perimeterL5 * M4_THICKNESS + perimeterL6 * M5_THICKNESS + perimeterL7 * M6_THICKNESS ) / 4; 

        if (double_constraint_contains(con, ratio) && !isinf(ratio) && !isnan(ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_19] = { nar_save_net_19 };

    /* Lookup the net_function to use in this num/den instance. */
    nar_func = nar_funcs[func_enum].func;

    n_layer_0 = layer_groups["layer1"][0];

    if (expr_is_default && (layer_groups.size() > 1)) {
        d_layers : list of polygon_layer = { };

        for (i = denominator_start to denominator_end) {
            d_layers.push_back(layer_groups["layer" + i][0]);
        }

        if ((con.category() == CONSTRAINT_EQ) && !((con.lo() > 0.0) || (con.lo() < 0.0))) {
            not_con2any = d_layers;
        }
        else {
            con2any = d_layers;
        }
    }

    net_area_ratio_result = net_select(
        connect_sequence     = cdb_in,
        net_function         = nar_func,
        layer_groups         = layer_groups,
        connected_to_all     = { n_layer_0 },
        connected_to_any     = con2any,
        not_connected_to_any = not_con2any,
        output_from_layers   = { n_layer_0 }
    );
}

net_area_ratio : published function (
    cdb_in            : connect_database,
    con               : constraint of double,
    layer_groups      : layer_groups_h,
    denominator_start : integer,
    denominator_end   : integer,
    constrained_areas : nar_constrained_areas_h = { },
    func_enum         : nar_funcs_e             = UNKNOWN,
    expr_is_default   : boolean                 = false
)
    returning void
{
    nar_funcs   : nar_void_func_h = { };
    nar_func    : function (void) returning void;
    con2any     : list of polygon_layer = { };
    not_con2any : list of polygon_layer = { };
    n_layer_0   : polygon_layer;

    /* Declare and register equation code function. */
    nar_save_net_1 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");

        ratio = dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_1] = { nar_save_net_1 };
 
    /* Declare and register equation code function. */
    nar_save_net_2 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");

        ratio = dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) + dblnz(areaL5) + dblnz(areaL6) + dblnz(areaL7) + dblnz(areaL8);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_2] = { nar_save_net_2 };
 
    /* Declare and register equation code function. */
    nar_save_net_3 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");

        ratio = dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) + dblnz(areaL5) + dblnz(areaL6) + dblnz(areaL7);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_3] = { nar_save_net_3 };
 
    /* Declare and register equation code function. */
    nar_save_net_4 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");
        areaL9 = ns_net_area("layer9");

        ratio = dblz(areaL2) * dblz(areaL3) * dblz(areaL4) * dblz(areaL5) * dblz(areaL6) * dblz(areaL7) * dblz(areaL8) + dblz(areaL9);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_4] = { nar_save_net_4 };
 
    /* Declare and register equation code function. */
    nar_save_net_5 : function (void) returning void
    {
        countL1 = ns_net_data_count("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");

        ratio = dblnp( countL1 - 1 ) * dblz(areaL2) * dblz(areaL3) * dblz(areaL4) * dblz(areaL5) * dblz(areaL6) * dblz(areaL7) * dblz(areaL8);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_5] = { nar_save_net_5 };
 
    /* Declare and register equation code function. */
    nar_save_net_6 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        con_eq_zero : boolean = ((con.category() == CONSTRAINT_EQ) && dbleq(con.lo(), 0));
        if (( areaL2 > 0) || con_eq_zero) {
            ratio = ( areaL2 > 0) ? (areaL1 / areaL2) : 0;

            if (double_constraint_contains(con, ratio)) {
                ns_save_net({"ratio"}, {ratio});
            }
        }
    }
    nar_funcs[NAR_SAVE_NET_6] = { nar_save_net_6 };
 
    /* Declare and register equation code function. */
    nar_save_net_8 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        con_eq_zero : boolean = ((con.category() == CONSTRAINT_EQ) && dbleq(con.lo(), 0));
        if (( areaL1 > 0) || con_eq_zero) {
            ratio = ( areaL1 > 0 ) ? areaL2 / areaL1 : 0;

            if (double_constraint_contains(con, ratio)) {
                ns_save_net({"ratio"}, {ratio});
            }
        }
    }
    nar_funcs[NAR_SAVE_NET_8] = { nar_save_net_8 };
 
    /* Declare and register equation code function. */
    nar_save_net_9 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        ratio = dblnz(areaL1) * dblnz(areaL2);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_9] = { nar_save_net_9 };
 
    /* Declare and register equation code function. */
    nar_save_net_10 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");

        ratio = dblnz(areaL1) * dblz(areaL5) * ( dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) );

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_10] = { nar_save_net_10 };
 
    /* Declare and register equation code function. */
    nar_save_net_11 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        ratio = dblnz(areaL1) * dblz(areaL2);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_11] = { nar_save_net_11 };
 
    /* Declare and register equation code function. */
    nar_save_net_12 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");

        ratio = dblnz(areaL2) + areaL3 + dblnz(areaL4);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_12] = { nar_save_net_12 };
 
    /* Declare and register equation code function. */
    nar_save_net_13 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");

        ratio = areaL1 / GRID; 

        if (double_constraint_contains(con, ratio) && !isinf(ratio) && !isnan(ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_13] = { nar_save_net_13 };
 
    /* Declare and register equation code function. */
    nar_save_net_14 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");

        ratio = dblnz(areaL1) * ( dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) );

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_14] = { nar_save_net_14 };
 
    /* Declare and register equation code function. */
    nar_save_net_15 : function (void) returning void
    {
        perimeterL1 = ns_net_perimeter("layer1");

        ratio = perimeterL1;

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_15] = { nar_save_net_15 };
 
    /* Declare and register equation code function. */
    nar_save_net_19 : function (void) returning void
    {
        perimeterL2 = ns_net_perimeter("layer2");
        perimeterL3 = ns_net_perimeter("layer3");
        perimeterL4 = ns_net_perimeter("layer4");
        perimeterL5 = ns_net_perimeter("layer5");
        perimeterL6 = ns_net_perimeter("layer6");
        perimeterL7 = ns_net_perimeter("layer7");

        ratio = ( perimeterL2 * M1_THICKNESS + perimeterL3 * M2_THICKNESS + perimeterL4 * M3_THICKNESS + perimeterL5 * M4_THICKNESS + perimeterL6 * M5_THICKNESS + perimeterL7 * M6_THICKNESS ) / 4; 

        if (double_constraint_contains(con, ratio) && !isinf(ratio) && !isnan(ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_19] = { nar_save_net_19 };

    /* Lookup the net_function to use in this num/den instance. */
    nar_func = nar_funcs[func_enum].func;

    n_layer_0 = layer_groups["layer1"][0];

    if (expr_is_default && (layer_groups.size() > 1)) {
        d_layers : list of polygon_layer = { };

        for (i = denominator_start to denominator_end) {
            d_layers.push_back(layer_groups["layer" + i][0]);
        }

        if ((con.category() == CONSTRAINT_EQ) && !((con.lo() > 0.0) || (con.lo() < 0.0))) {
            not_con2any = d_layers;
        }
        else {
            con2any = d_layers;
        }
    }

    net_select(
        connect_sequence     = cdb_in,
        net_function         = nar_func,
        layer_groups         = layer_groups,
        connected_to_all     = { n_layer_0 },
        connected_to_any     = con2any,
        not_connected_to_any = not_con2any,
        output_from_layers   = { n_layer_0 },
        error_net_output     = ALL
    );
}
size_outside_wrapper : published function (
    layer1           : polygon_layer,
    outside          : polygon_layer,
    distance         : double,
    increment        : double = 0.0,
    corner_extension : corner_extension_e = INTERSECTION,
    radial_sectors   : integer = 0
)
    returning size_outside_wrapper_result : polygon_layer
{
    if (dblge(increment, distance) || dbleq(increment, 0.0)) {
        increment = distance;
    }

    size_out : polygon_layer = layer1;
    steps : integer = dtoi(distance / increment);
    remainder : double = distance - (steps * increment);

    for (i = 1 to steps) {
        size_out = size(size_out, distance = increment, corner_extension = corner_extension, radial_sectors   = radial_sectors);
        size_out = not(size_out, outside);
    }

    if (dblgt(remainder, 0.0)) {
        size_out = size(size_out, distance = remainder, corner_extension = corner_extension, radial_sectors   = radial_sectors);
        size_out = not(size_out, outside);
    }

    size_outside_wrapper_result = size_out;
}

/* Declare and register equation code function. */
den_save_window_7 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaW = den_window_area();
    
    ratio = areaL1 / areaW;

    if (double_constraint_contains_density(_den_con, ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaW" },
                            values      = { ratio, areaL1, areaW }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaW" },
                values      = { ratio, areaL1, areaW }
            );
        }
    }

    den_generate_next_step(ratio, _den_con, RATIO);
}


/* Declare and register equation code function. */
den_save_window_16 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    
    ratio = areaL1 / areaL2;

    if (double_constraint_contains_density(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2" },
                            values      = { ratio, areaL1, areaL2 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2" },
                values      = { ratio, areaL1, areaL2 }
            );
        }
    }
}


/* Declare and register equation code function. */
den_save_window_17 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    areaL3 = den_polygon_area("layer3", clip = _den_polygon_area_clip);
    
    ratio = dblz(areaL1) + ( areaL2 / areaL3 );

    if (double_constraint_contains_density(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2", "areaL3" },
                            values      = { ratio, areaL1, areaL2, areaL3 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2", "areaL3" },
                values      = { ratio, areaL1, areaL2, areaL3 }
            );
        }
    }
}


/* Declare and register equation code function. */
den_save_window_18 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    areaL3 = den_polygon_area("layer3", clip = _den_polygon_area_clip);
    
    ratio = dblnz(areaL1) * ( ( areaL2 / areaL3 ) );

    if (double_constraint_contains_density(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2", "areaL3" },
                            values      = { ratio, areaL1, areaL2, areaL3 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2", "areaL3" },
                values      = { ratio, areaL1, areaL2, areaL3 }
            );
        }
    }
}

/* End of Equation Code-Based Functions definitions */

// DRAWN LAYER DEFINITIONS
//------------------------
/* Nwell technology */
NWELII      = assign({ { 2 } }); 
/* Nwell for ULL devices */
ULLNWI      = assign({ { 128 } }); 
/* Define LL device region */
ODLLI       = assign({ { 101 } }); 
/* Active areas */
DIFFI       = assign({ { 3, 0 }, { 3, >= 2 } }); 
/* Dummy OD (DIFF) */
DOD         = assign({ { 3, 1 } }); 
/* DOD blocking for insertion */
ODBLK       = assign({ { 150, 20 } }); 
/* Active areas */
PDIFFI      = assign({ { 11 } }); 
/* Active areas */
NDIFFI      = assign({ { 12 } }); 
/* Define thick gate oxides */
OD2I        = assign({ { 4 } }); 
/* Polysilicon gates, interconnect */
POLYI       = assign({ { 13, 0 }, { 13, >= 2 } }); 
/* Dummy Poly */
DPO         = assign({ { 13, 1 } }); 
/* DPO blocking for insertion */
POBLK       = assign({ { 150, 21 } }); 
/* P+ S/D imlant */
PPI         = assign({ { 7 } }); 
/* N+ S/D imlant */
NPI         = assign({ { 8 } }); 
NLVTI       = assign({ { 141, 63 } }); 
/* Deep trench  */
DTI         = assign({ { 171, <= 1 }, { 171, >= 3 } }); 
/* Deep trench block */
DTBLK       = assign({ { 171, 2 } }); 
/* FLASH IP outline */
FLASH       = assign({ { 94 } }); 
/* BJT dummy LAYER */
BJTDUMMY    = assign({ { 49 } }); 
/* Diode dummy layer */
DIODUMMY    = assign({ { 56 } }); 
RPDUMMY     = assign({ { 54 } }); 
/* Define connection from M1 to S/D and Gate */
COI         = assign({ { 15 } }); 
/* First Metal layer */
M1I         = assign({ { 16, 0 }, { 16, >= 3 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Define connection from M2 to M1 */
VIA1I       = assign({ { 17 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Second Metal layer */
M2I         = assign({ { 18, 0 }, { 18, >= 3 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Define connection from M3 to M2 */
VIA2I       = assign({ { 27 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Third Metal layer */
M3I         = assign({ { 28, 0 }, { 28, >= 3 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Define connection from M4 to M3 */
VIA3I       = assign({ { 29 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Fourth Metal layer */
M4I         = assign({ { 31, 0 }, { 31, >= 3 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Define connection from M5 to M4 */
VIA4I       = assign({ { 32 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Fifth Metal layer */
M5I         = assign({ { 33, 0 }, { 33, >= 3 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Define connection from M6 to M5 */
VIA5I       = assign({ { 39 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Sixth Metal layer   */
M6I         = assign({ { 38, 0 }, { 38, >= 3 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
tM1_PIN_TEXT = assign_text({ { 40, 0 } });
tM2_PIN_TEXT = assign_text({ { 41, 0 } });
tM3_PIN_TEXT = assign_text({ { 42, 0 } });
tM4_PIN_TEXT = assign_text({ { 43, 0 } });
tM5_PIN_TEXT = assign_text({ { 44, 0 } });
tM6_PIN_TEXT = assign_text({ { 45, 0 } });
/* Define connect from MD to Top Metal */
VIADI       = assign({ { 167 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* RDL Metal layer above Top Metal */
MDI         = assign({ { 168, 0 }, { 168, >= 3 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
tMD_PIN_TEXT = assign_text({ { 159, 0 } });
/* Passivation opening for Bond Pad */
CBI         = assign({ { 19 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Definition of passivation window for bump */
CBDI        = assign({ { 169 } }); 
/* Bond Pad definition for RDL */
UBMI        = assign({ { 170 } }); 
/* Post Passivation RDL */
PPII        = assign({ { 189 } }); 
/* Salicided Block Layer */
RPOI        = assign({ { 34 } }); 
/* Native NMOS blocked implantation */
NTNI        = assign({ { 129 } }); 
/* Polymide (if drawn) */
PLMIDEI     = assign({ { 89 } }); 

//LAYER  FUSEi	235	// Fuse window
/* Deep N-WELL */
DNWI        = assign({ { 82 } }); 
/* Blocking region of PMOS VT implantation */
VTMPI       = assign({ { 23 } }); 
/* Blocking region of NMOS VT implantation */
VTMNI       = assign({ { 24 } }); 
/* PV_P pmos varactor p+ implant layer */
PV_P        = assign({ { 71 } }); 
/* PV_N pmos varactor n+ blocking layer */
PV_N        = assign({ { 72 } }); 
/* High Resistor implant */
HRII        = assign({ { 48 } }); 

// Dummy Metal layers
//-------------------
/* Metal1 dummy (if drawn) */
M1DMY       = assign({ { 16, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal2 dummy (if drawn) */
M2DMY       = assign({ { 18, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal3 dummy (if drawn) */
M3DMY       = assign({ { 28, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal4 dummy (if drawn) */
M4DMY       = assign({ { 31, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal5 dummy (if drawn) */
M5DMY       = assign({ { 33, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal6 dummy (if drawn) */
M6DMY       = assign({ { 38, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* MD dummy (if drawn) */
MDDMY       = assign({ { 168, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 

// Metal Slot layers
//------------------
/* Metal1 slot (if drawn) */
M1SLOTI     = assign({ { 16, 2 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal2 slot (if drawn) */
M2SLOTI     = assign({ { 18, 2 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal3 slot (if drawn) */
M3SLOTI     = assign({ { 28, 2 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal4 slot (if drawn) */
M4SLOTI     = assign({ { 31, 2 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal5 slot (if drawn) */
M5SLOTI     = assign({ { 33, 2 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal6 slot (if drawn) */
M6SLOTI     = assign({ { 38, 2 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* MD slot (if drawn) */
MDSLOTI     = assign({ { 168, 2 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 

// Capacitor Top Metal Layers
//---------------------------
/* Capacitor Top Metal-2 */
CTM2I       = assign({ { 67, 2 } }); 
/* Capacitor Top Metal-3 */
CTM3I       = assign({ { 67, 3 } }); 
/* Capacitor Top Metal-4 */
CTM4I       = assign({ { 67, 4 } }); 
/* Capacitor Top Metal-5 */
CTM5I       = assign({ { 67, 5 } }); 

// Dummy Layers
//-------------
/* Hot N-Well (SEE README HOT_NWEL NOTES) */
HOTWL       = assign({ { 51 } }); 
/* Exclude layer */
EXCLI       = assign({ { 55 } }); 
/* DRC I/O waiver */
DRCDMY      = assign({ { 60 } }); 
/* NWEL Resistor dummy layer */
RWDMY       = assign({ { 52 } }); 
/* Dummy Pad area dummy layer */
DPDMY       = assign({ { 65 } }); 
/* Power Line area dummy layer */
PLDMY       = assign({ { 66 } }); 
/* IO ESD region dummy layer */
SDI         = assign({ { 58, <= 2 }, { 58, >= 4 } }); 
HIADMY      = assign({ { 58, 3 } }); 
/* IO ESD region dummy layer, RPO must enclose whole gate */
ESD1DMY     = assign({ { 136 } }); 
/* IO ESD region dummy layer, RPO enclose gate 0.05 for 3.3V */
ESD2DMY     = assign({ { 137 } }); 
ESD3DMY     = assign({ { 234 } }); 
/* Cover metal as a capacitor bottom plate */
CTMDMY      = assign({ { 131 } }); 
/* HRI high Poly resistor dummy layer */
RLPPDMY     = assign({ { 134 } }); 
/* Dummy layer to ensure N2V in N+ poly/OD resistor */
DMN2V       = assign({ { 184 } }); 
/* Dummy layer to ensure P2V in P+ poly/OD resistor */
DMP2V       = assign({ { 149 } }); 
/* Dummy layer to cover varactor device */
VARDMY      = assign({ { 138 } }); 
/* Dummy layer to cover fuse window and protection ring structur */
PMDMY       = assign({ { 236 } }); 
/* Fuse window when x, (x+1) = 3  */
FWI         = assign({ { 235 } }); 
/* L target window for bump process */
LMARK       = assign({ { 63, 1 } }); 
/* L target window for bump process */
LWI         = assign({ { 63, 2 } }); 
/* Dummy layer to cover the CUP pad */
WBDMY       = assign({ { 183 } }); 
/* For 0.18um 1.8V/5V on i/o esd's implant only. */
ESDI        = assign({ { 30 } }); 
/* For 0.18um 3.3V esd NMOS only. */
ESDIMPI     = assign({ { 250, 4 } }); 
/* Dummy layer to define inductor */
INDDMY      = assign({ { 139, 0 } }); 
/* SEAL-RING Layer used for SR.S.1 check */
SEALRING    = assign({ { 126 } }); 
/* Dummy layer for product labels and LOGO */
LOGO        = assign({ { 178 } }); 
/* DRC dummy layer to waive Latch-Up rules for verified IP. */
LUPWDMY     = assign({ { 255, 1 } }); 
/* Area Array IO LUP rules check */
LUPWDMY_2   = assign({ { 255, 18 } }); 
/* A layer for DRC,LVS and creating mask logic operation Use "SBDDMY" to fully cover schottky barrier diode. */
SBDDMY      = assign({ { 144, 0 } }); 
/* recognize RF dummy layer for LVS purpose. */
RFDUMMY     = assign({ { 160, 1 } }); 
/* dummy layer to recognize 200 ohm or above resistor */
RES200      = assign({ { 255, 9 } }); 
/* dummy layer to enable pair check */
MATCHING    = assign({ { 182, 11 } }); 
VDDDMY      = assign({ { 255, 4 } }); 
VSSDMY      = assign({ { 255, 5 } }); 
/* TSV region define layer. */
TSVI        = assign({ { 251 } }); 
ANALOGDMY   = assign({ { 203, 2 } }); 
CMM         = assign({ { 73, <= 1 }, { 73, >= 6 } }); 
/* Capacitor Top Metal-2 */
CMM2I       = assign({ { 73, 2 } }); 
/* Capacitor Top Metal-3 */
CMM3I       = assign({ { 73, 3 } }); 
/* Capacitor Top Metal-4 */
CMM4I       = assign({ { 73, 4 } }); 
/* Capacitor Top Metal-5 */
CMM5I       = assign({ { 73, 5 } }); 
MOMDMY      = assign({ { 145, 0 }, { 145, [7, 99] }, { 145, >= 101 } }); 
MOMDMY_1    = assign({ { 145, 1 } }); 
MOMDMY_2    = assign({ { 145, 2 } }); 
MOMDMY_3    = assign({ { 145, 3 } }); 
MOMDMY_4    = assign({ { 145, 4 } }); 
MOMDMY_5    = assign({ { 145, 5 } }); 
MOMDMY_6    = assign({ { 145, 6 } }); 
MOMDMY_ALL  = assign({ { 145, 100 }, { 145, [1, 6] } }); 
DM1EXCL     = assign({ { 150, 1 } }); 
DM2EXCL     = assign({ { 150, 2 } }); 
DM3EXCL     = assign({ { 150, 3 } }); 
DM4EXCL     = assign({ { 150, 4 } }); 
DM5EXCL     = assign({ { 150, 5 } }); 
DM6EXCL     = assign({ { 150, 6 } }); 
DMDEXCL     = assign({ { 150, 15 } }); 

//


//-------- Patch definition --------
#pragma ICV patch_insert patch_assigns

#pragma ICV patch_insert patch_unselects


// ENVIRONMENT SETUP
//------------------
/* Set layout grid  check to 0.005 */

/* For layout grid check. default grid value is resolution size */

// Dummy Pad
//==========
violation_name_group( "rDUMMY_PAD_CHECK", { "rADP_S_2G", "rADP_W_3G", "rADP_W_4G" } );
rFLAG_ACUTE @= { @ "FLAG ACUTE";
    internal1_edge( NWELII, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( NWELII, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( ULLNWI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( ULLNWI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( ODLLI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( ODLLI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( DIFFI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( DIFFI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( DOD, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( DOD, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( ODBLK, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( ODBLK, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( PDIFFI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( PDIFFI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( NDIFFI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( NDIFFI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( OD2I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( OD2I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( POLYI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( POLYI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( DPO, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( DPO, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( PPI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( PPI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( NPI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( NPI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( DTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( DTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( FLASH, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( FLASH, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( BJTDUMMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( BJTDUMMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( DIODUMMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( DIODUMMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( RPDUMMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( RPDUMMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( COI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( COI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M1I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M1I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VIA1I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VIA1I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M2I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M2I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VIA2I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VIA2I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M3I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M3I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VIA3I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VIA3I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M4I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M4I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VIA4I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VIA4I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M5I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M5I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VIA5I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VIA5I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M6I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M6I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VIADI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VIADI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MDI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MDI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( CBI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( CBI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( CBDI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( CBDI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( UBMI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( UBMI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( PPII, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( PPII, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( RPOI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( RPOI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( NTNI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( NTNI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( PLMIDEI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( PLMIDEI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( DNWI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( DNWI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VTMPI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VTMPI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VTMNI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VTMNI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( HRII, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( HRII, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M1DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M1DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M2DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M2DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M3DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M3DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M4DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M4DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M5DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M5DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M6DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M6DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MDDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MDDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M1SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M1SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M2SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M2SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M3SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M3SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M4SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M4SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M5SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M5SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( M6SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( M6SLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MDSLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MDSLOTI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( CTM2I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( CTM2I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( CTM3I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( CTM3I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( CTM4I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( CTM4I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( CTM5I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( CTM5I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( HOTWL, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( HOTWL, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( EXCLI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( EXCLI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( DRCDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( DRCDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( RWDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( RWDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( DPDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( DPDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( PLDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( PLDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( SDI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( SDI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( HIADMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( HIADMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( ESD1DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( ESD1DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( ESD2DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( ESD2DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( ESD3DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( ESD3DMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( RLPPDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( RLPPDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( DMN2V, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( DMN2V, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( DMP2V, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( DMP2V, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VARDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VARDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( PMDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( PMDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( FWI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( FWI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( LMARK, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( LMARK, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( LWI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( LWI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( WBDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( WBDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( ESDI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( ESDI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( ESDIMPI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( ESDIMPI, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( INDDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( INDDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( SEALRING, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( SEALRING, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( LOGO, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( LOGO, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( LUPWDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( LUPWDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( LUPWDMY_2, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( LUPWDMY_2, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( SBDDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( SBDDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( RFDUMMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( RFDUMMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( RES200, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( RES200, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MATCHING, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MATCHING, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VDDDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VDDDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( VSSDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( VSSDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( ANALOGDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( ANALOGDMY, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( CMM2I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( CMM2I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( CMM3I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( CMM3I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( CMM4I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( CMM4I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( CMM5I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( CMM5I, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MOMDMY_1, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MOMDMY_1, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MOMDMY_2, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MOMDMY_2, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MOMDMY_3, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MOMDMY_3, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MOMDMY_4, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MOMDMY_4, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MOMDMY_5, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MOMDMY_5, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MOMDMY_6, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MOMDMY_6, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    internal1_edge( MOMDMY_ALL, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
    external1_edge( MOMDMY_ALL, < 0.005, extension = NONE, intersecting = { ACUTE }, orientation = {} ); 
}
gLAYER_8 = DIFFI or NDIFFI; 
ODI = gLAYER_8 or PDIFFI; 
NRODI = ODI not RPOI; 
NPODI = NPI and NRODI; 
#ifdef C0152 
   NWELI = NWELII or ULLNWI; 
#else
   NWELI = copy( NWELII ); 
#endif
NONWRI = not_interacting( NWELI, RWDMY );    /* NWEL - NWR(OD) - NWR(STI) */ 
NTAPI = NPODI and NONWRI;                /* NWEL Pick-Up */ 

// BUILD CONNECTION FOR RULE CHECKS 
//---------------------------------
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPI }, NWELI }} ); 
PPODI = PPI and NRODI; 
PTAPI = PPODI not NWELI;                 /* Substrate(PWEL) Pick-Up */ 

/////////////////////////////////////////////////////////////////////////////////

// EXCLUDE UNCHECKED REGIONS
//--------------------------
gCHIP = chip_extent();
gBULK = size( gCHIP, clip_acute = NONE, distance = 1.0 );
PWELI = gBULK not NWELI; 

// Latch-Up CHECKS
//================
RWI = PWELI inside DNWI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPI }, RWI }} );    /* For DNW connection */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPI }, PWELI }} );    /* For DNW connection */ 
PACTI = PPODI and NONWRI;                /* PMOS Device  */ 
PSDI = PACTI not POLYI;                  /* PMOS source/drain,separated */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPI }, PSDI }} ); 
NACTI = NPODI not NWELI;                 /* NMOS Device */ 
NSDI = NACTI not POLYI;                  /* NMOS source/drain,separated   */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPI }, NSDI }} ); 
gLAYER_1 = M1I or M1DMY; 
M1XD = gLAYER_1 not M1SLOTI; 
ILP1I = POLYI not RPOI;                  /* Interconnection poly */ 
COI_ILP1I = COI and (ILP1I and M1XD);
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COI_ILP1I }, COI, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1XD, ILP1I }, COI_ILP1I, NONE }} );
COI_NTAPI = COI and (NTAPI and M1XD) not COI_ILP1I;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COI_NTAPI }, COI, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1XD, NTAPI }, COI_NTAPI, NONE }} );
COI_PTAPI = COI and (PTAPI and M1XD) not COI_ILP1I not COI_NTAPI;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COI_PTAPI }, COI, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1XD, PTAPI }, COI_PTAPI, NONE }} );
COI_PSDI = COI and (PSDI and M1XD) not COI_ILP1I not COI_NTAPI not COI_PTAPI;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COI_PSDI }, COI, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1XD, PSDI }, COI_PSDI, NONE }} );
COI_NSDI  = COI and (NSDI  and M1XD) not COI_ILP1I not COI_NTAPI not COI_PTAPI not COI_PSDI;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COI_NSDI  }, COI, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1XD, NSDI  }, COI_NSDI , NONE }} );
gLAYER_2 = M2I or M2DMY; 
M2XD = gLAYER_2 not M2SLOTI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1XD, M2XD }, VIA1I, NONE }} ); 
gLAYER_3 = M3I or M3DMY; 
M3XD = gLAYER_3 not M3SLOTI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2XD, M3XD }, VIA2I, NONE }} ); 
gLAYER_4 = M4I or M4DMY; 
M4XD = gLAYER_4 not M4SLOTI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3XD, M4XD }, VIA3I, NONE }} ); 
gLAYER_5 = M5I or M5DMY; 
M5XD = gLAYER_5 not M5SLOTI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4XD, M5XD }, VIA4I, NONE }} ); 
gLAYER_6 = M6I or M6DMY; 
M6XD = gLAYER_6 not M6SLOTI; 
VIA5I_CTM5I = VIA5I and (CTM5I and M6XD);
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5I_CTM5I }, VIA5I, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6XD, CTM5I }, VIA5I_CTM5I, NONE }} );
VIA5I_CMM5I = VIA5I and (CMM5I and M6XD) not VIA5I_CTM5I;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5I_CMM5I }, VIA5I, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6XD, CMM5I }, VIA5I_CMM5I, NONE }} );
VIA5I_M5XD  = VIA5I and (M5XD  and M6XD) not VIA5I_CTM5I not VIA5I_CMM5I;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5I_M5XD  }, VIA5I, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6XD, M5XD  }, VIA5I_M5XD , NONE }} );
gLAYER_7 = MDI or MDDMY; 
MDXD = gLAYER_7 not MDSLOTI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6XD, MDXD }, VIADI, NONE }} ); 
EXCL = EXCLI not LOGO; 
#ifdef CHECK_DUMMY_ODPO 
   gLAYER_10 = POLYI or DPO; 
   POLY = gLAYER_10 not EXCL; 
#else
   POLY = POLYI not EXCL; 
#endif
#ifdef CHECK_DUMMY_ODPO 
   gLAYER_9 = ODI or DOD; 
   OD = gLAYER_9 not EXCL; 
#else
   OD = ODI not EXCL; 
#endif
POLY_ISO = POLY not OD;                  /* Interconnect POLY */ 
FPO1 = copy( POLY_ISO );                  /* Field poly */ 
RPO = RPOI not EXCL; 
RPO_NOT_SDI = RPO not SDI; 
PORES = FPO1 and RPO_NOT_SDI;            /* POLY resistor region */ 

// Poly/OD Resistor CHECK
//==========
gLAYER_47 = not_interacting( PORES, RLPPDMY ); 
PORESC = not_interacting( gLAYER_47, SDI ); 
ALL_GATE = POLY and OD;                  /* Gate regions for NMOS and PMOS */ 
gLAYER_11 = OD outside RWDMY; 
FFOD = gLAYER_11 outside ALL_GATE; 
ODRES = FFOD and RPO_NOT_SDI;            /* OD resistor region */ 
#ifdef RECOMMEND 
   gLAYER_48 = or_edge( not_edge( PORESC, POLY ), coincident_inside_edge( PORESC, POLY ) ); 
   PORESC_L = edge_size( gLAYER_48, corner_extension = INTERSECTION, inside = 0.001, outside = 0.001 ); 
   gLAYER_49 = and_edge( PORESC, POLY, false ); 
   PORESC_W = edge_size( gLAYER_49, inside = 0.001, outside = 0.001 ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PORESC_L }, PORESC_W }} ); 
   gLAYER_50 = not_interacting( ODRES, RLPPDMY ); 
   ODRESC = gLAYER_50 not SEALRING; 
   gLAYER_51 = or_edge( not_edge( ODRESC, OD ), coincident_inside_edge( ODRESC, OD ) ); 
   ODRESC_L = edge_size( gLAYER_51, corner_extension = INTERSECTION, inside = 0.001, outside = 0.001 ); 
   gLAYER_52 = and_edge( ODRESC, OD, false ); 
   ODRESC_W = edge_size( gLAYER_52, inside = 0.001, outside = 0.001 ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ ODRESC_L }, ODRESC_W }} ); 
#endif
gLAYER_12 = DMP2V or DMN2V; 
HRDMY = gLAYER_12 or RLPPDMY;             /* High resistance poly resistor dummy layer for DRC */ 
HREP = PORES and HRDMY;                  /* High precision and resistacne poly resistor */ 
#ifdef MIX_MODE 
   HREPC = interacting( HREP, RLPPDMY ); 
   #ifdef RECOMMEND 
      gLAYER_53 = or_edge( not_edge( HREPC, POLY ), coincident_inside_edge( HREPC, POLY ) ); 
      HREP_L = edge_size( gLAYER_53, corner_extension = INTERSECTION, inside = 0.001, outside = 0.001 ); 
      gLAYER_54 = and_edge( HREPC, POLY, false ); 
      HREP_W = edge_size( gLAYER_54, inside = 0.001, outside = 0.001 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ HREP_L }, HREP_W }} ); 
   #endif
#endif
VIA1 = VIA1I not EXCL; 

// Back-End Layer
//---------------
M1 = M1XD not EXCL; 

//********************************************
//***** Pre-processing for IMD crack check **** 
//********************************************
//
// Processing for SAME Array Merged 
//*********************************
VIA1_M = interacting( VIA1, M1 ); 
VIA1MERGE1 = size_inside_wrapper( VIA1_M, M1, distance = VIA_S_1 / 2, increment = 0.46 ); 
VIA1MERGE2 = size( size( VIA1_M, VIA_S_1 / 2, clip_acute = NONE ), - ( VIA_S_1 / 2 ), clip_acute = NONE );    /* Any space <= VIA1_S_1 um treated as "array" */ 
VIA1MERGE_p_PRE1 = VIA1MERGE1 and VIA1MERGE2;    /* Find merged via array(s) */ 
VIA1MERGE_p_PRE11 = contains( VIA1MERGE_p_PRE1, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA1MERGE_p_PRE12 = interacting( VIA1_M, VIA1MERGE_p_PRE11 );    /* find VIA1 in the effective via arrary */ 
VIA1MERGE_p_PRE13 = size( size( VIA1MERGE_p_PRE12, VIA_S_1 / 2, clip_acute = NONE ), - ( VIA_S_1 / 2 ), clip_acute = NONE );    /* Any space <= VIA1_S_1 um treated as "array" */ 
VIA1MERGE_p_PRE2 = VIA1MERGE1 and VIA1MERGE_p_PRE13;    /* Find merged via array(s) */ 
VIA1_SAME_ARRAY = size( size( VIA1MERGE_p_PRE2, - ( VIA_FILTER / 2 ), clip_acute = NONE ), VIA_FILTER / 2, clip_acute = NONE );    /* For broken small metal connection */ 
#ifdef CHECK_SRAM_EXCL 
   EXCL_S = gCHIP not gBULK;               /* Use an empty layer to disable the usage of EXCL */ 
#else
   EXCL_S = copy( EXCL );                 /* EXCL_S = EXCL */ 
#endif
VIA2 = VIA2I not_inside EXCL_S; 
M2 = M2XD not_inside EXCL_S; 
VIA2_M = interacting( VIA2, M2 ); 
VIA2MERGE1 = size_inside_wrapper( VIA2_M, M2, distance = VIA_S_1 / 2, increment = 0.46 ); 
VIA2MERGE2 = size( size( VIA2_M, VIA_S_1 / 2, clip_acute = NONE ), - ( VIA_S_1 / 2 ), clip_acute = NONE );    /* Any space <= VIA1_S_1 um treated as "array" */ 
VIA2MERGE_p_PRE1 = VIA2MERGE1 and VIA2MERGE2;    /* Find merged via array(s) */ 
VIA2MERGE_p_PRE11 = contains( VIA2MERGE_p_PRE1, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA2MERGE_p_PRE12 = interacting( VIA2_M, VIA2MERGE_p_PRE11 );    /* find VIA2 in the effective via arrary */ 
VIA2MERGE_p_PRE13 = size( size( VIA2MERGE_p_PRE12, VIA_S_1 / 2, clip_acute = NONE ), - ( VIA_S_1 / 2 ), clip_acute = NONE );    /* Any space <= VIA1_S_1 um treated as "array" */ 
VIA2MERGE_p_PRE2 = VIA2MERGE1 and VIA2MERGE_p_PRE13;    /* Find merged via array(s) */ 
VIA2_SAME_ARRAY = size( size( VIA2MERGE_p_PRE2, - ( VIA_FILTER / 2 ), clip_acute = NONE ), VIA_FILTER / 2, clip_acute = NONE );    /* For broken small metal connection */ 
VIA3 = VIA3I not_inside EXCL_S; 
M3 = M3XD not_inside EXCL_S; 
VIA3_M = interacting( VIA3, M3 ); 
VIA3MERGE1 = size_inside_wrapper( VIA3_M, M3, distance = VIA_S_1 / 2, increment = 0.46 ); 
VIA3MERGE2 = size( size( VIA3_M, VIA_S_1 / 2, clip_acute = NONE ), - ( VIA_S_1 / 2 ), clip_acute = NONE );    /* Any space <= VIA1_S_1 um treated as "array" */ 
VIA3MERGE_p_PRE1 = VIA3MERGE1 and VIA3MERGE2;    /* Find merged via array(s) */ 
VIA3MERGE_p_PRE11 = contains( VIA3MERGE_p_PRE1, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA3MERGE_p_PRE12 = interacting( VIA3_M, VIA3MERGE_p_PRE11 );    /* find VIA3 in the effective via arrary */ 
VIA3MERGE_p_PRE13 = size( size( VIA3MERGE_p_PRE12, VIA_S_1 / 2, clip_acute = NONE ), - ( VIA_S_1 / 2 ), clip_acute = NONE );    /* Any space <= VIA1_S_1 um treated as "array" */ 
VIA3MERGE_p_PRE2 = VIA3MERGE1 and VIA3MERGE_p_PRE13;    /* Find merged via array(s) */ 
VIA3_SAME_ARRAY = size( size( VIA3MERGE_p_PRE2, - ( VIA_FILTER / 2 ), clip_acute = NONE ), VIA_FILTER / 2, clip_acute = NONE );    /* For broken small metal connection */ 
VIA4 = VIA4I not_inside EXCL_S; 
M4 = M4XD not_inside EXCL_S; 
VIA4_M = interacting( VIA4, M4 ); 
VIA4MERGE1 = size_inside_wrapper( VIA4_M, M4, distance = VIA_S_1 / 2, increment = 0.46 ); 
VIA4MERGE2 = size( size( VIA4_M, VIA_S_1 / 2, clip_acute = NONE ), - ( VIA_S_1 / 2 ), clip_acute = NONE );    /* Any space <= VIA1_S_1 um treated as "array" */ 
VIA4MERGE_p_PRE1 = VIA4MERGE1 and VIA4MERGE2;    /* Find merged via array(s) */ 
VIA4MERGE_p_PRE11 = contains( VIA4MERGE_p_PRE1, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA4MERGE_p_PRE12 = interacting( VIA4_M, VIA4MERGE_p_PRE11 );    /* find VIA4 in the effective via arrary */ 
VIA4MERGE_p_PRE13 = size( size( VIA4MERGE_p_PRE12, VIA_S_1 / 2, clip_acute = NONE ), - ( VIA_S_1 / 2 ), clip_acute = NONE );    /* Any space <= VIA1_S_1 um treated as "array" */ 
VIA4MERGE_p_PRE2 = VIA4MERGE1 and VIA4MERGE_p_PRE13;    /* Find merged via array(s) */ 
VIA4_SAME_ARRAY = size( size( VIA4MERGE_p_PRE2, - ( VIA_FILTER / 2 ), clip_acute = NONE ), VIA_FILTER / 2, clip_acute = NONE );    /* For broken small metal connection */ 
VIA5 = VIA5I not_inside EXCL_S; 
M5 = M5XD not_inside EXCL_S; 
VIA5_M = interacting( VIA5, M5 ); 
VIA5MERGE1 = size_inside_wrapper( VIA5_M, M5, distance = VIA_S_1 / 2, increment = 0.46 ); 
VIA5MERGE2 = size( size( VIA5_M, VIA_S_1 / 2, clip_acute = NONE ), - ( VIA_S_1 / 2 ), clip_acute = NONE );    /* Any space <= VIA1_S_1 um treated as "array" */ 
VIA5MERGE_p_PRE1 = VIA5MERGE1 and VIA5MERGE2;    /* Find merged via array(s) */ 
VIA5MERGE_p_PRE11 = contains( VIA5MERGE_p_PRE1, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA5MERGE_p_PRE12 = interacting( VIA5_M, VIA5MERGE_p_PRE11 );    /* find VIA5 in the effective via arrary */ 
VIA5MERGE_p_PRE13 = size( size( VIA5MERGE_p_PRE12, VIA_S_1 / 2, clip_acute = NONE ), - ( VIA_S_1 / 2 ), clip_acute = NONE );    /* Any space <= VIA1_S_1 um treated as "array" */ 
VIA5MERGE_p_PRE2 = VIA5MERGE1 and VIA5MERGE_p_PRE13;    /* Find merged via array(s) */ 
VIA5_SAME_ARRAY = size( size( VIA5MERGE_p_PRE2, - ( VIA_FILTER / 2 ), clip_acute = NONE ), VIA_FILTER / 2, clip_acute = NONE );    /* For broken small metal connection */ 

// Processing for 5 ~ 1 Stack Array  
//**********************************
gLAYER_67 = area( VIA1_SAME_ARRAY, >= VIA_A_5 ); 
gLAYER_68 = area( VIA2_SAME_ARRAY, >= VIA_A_5 ); 
gLAYER_66 = gLAYER_67 and gLAYER_68;
gLAYER_69 = area( VIA3_SAME_ARRAY, >= VIA_A_5 ); 
gLAYER_65 = gLAYER_66 and gLAYER_69;
gLAYER_70 = area( VIA4_SAME_ARRAY, >= VIA_A_5 ); 
gLAYER_64 = gLAYER_65 and gLAYER_70;
gLAYER_71 = area( VIA5_SAME_ARRAY, >= VIA_A_5 ); 
VIA1_SAME_ARRAY_5STACK_p_PRE1 = gLAYER_64 and gLAYER_71; 
VIA1_SAME_ARRAY_5STACK_p_PRE2 = area( VIA1_SAME_ARRAY_5STACK_p_PRE1, >= VIA_A_5 ); 

//**********************  
// Small 5 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
VIA1_5STACK_p_PRE3 = contains( VIA1_SAME_ARRAY_5STACK_p_PRE2, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA1_REG_3_S_5 = external1( VIA1_5STACK_p_PRE3, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M6 = M6XD not_inside EXCL_S; 
gLAYER_188 = interacting( M1, VIA1_5STACK_p_PRE3 ); 
gLAYER_189 = interacting( M2, VIA1_5STACK_p_PRE3 ); 
gLAYER_187 = gLAYER_188 or gLAYER_189;
gLAYER_190 = interacting( M3, VIA1_5STACK_p_PRE3 ); 
gLAYER_186 = gLAYER_187 or gLAYER_190;
gLAYER_191 = interacting( M4, VIA1_5STACK_p_PRE3 ); 
gLAYER_185 = gLAYER_186 or gLAYER_191;
gLAYER_192 = interacting( M5, VIA1_5STACK_p_PRE3 ); 
gLAYER_184 = gLAYER_185 or gLAYER_192;
gLAYER_193 = interacting( M6, VIA1_5STACK_p_PRE3 ); 
M1_5STACK_p_PRE3 = gLAYER_184 or gLAYER_193; 
VIA1_REG_3_S_5_PRE = VIA1_REG_3_S_5 not M1_5STACK_p_PRE3; 
VIA1_REG_3_S_5_1 = contains( VIA1_REG_3_S_5_PRE, { 0.005, VIA_S_2L }, FORTY_FIVE );    /* Find parallel run length >= VIA_S_2L */ 
gLAYER_194 = interacting( VIA1_REG_3_S_5, VIA1_REG_3_S_5_1 ); 
VIA1_5STACK_p_PRE4 = interacting( VIA1_5STACK_p_PRE3, gLAYER_194 ); 
VIA1ARRAYS1_S_5 = external1( VIA1_5STACK_p_PRE4, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
gLAYER_199 = VIA1ARRAYS1_S_5 not_inside M1; 
gLAYER_198 = gLAYER_199 not_inside M2; 
gLAYER_197 = gLAYER_198 not_inside M3; 
gLAYER_196 = gLAYER_197 not_inside M4; 
gLAYER_195 = gLAYER_196 not_inside M5; 
VIA1ARRAYS2_S_5 = gLAYER_195 not_inside M6; 
VIA1_5STACK_p_PRE5 = interacting( VIA1_5STACK_p_PRE4, VIA1ARRAYS2_S_5 ); 
M1_5STACK_p_PRE4 = external1( M1_5STACK_p_PRE3, <= VIA_S_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M1_5STACK_p_PRE4_EDGE = M1_5STACK_p_PRE3 coincident_outside_edge M1_5STACK_p_PRE4; 
M1_5STACK_p_PRE5 = edge_size( M1_5STACK_p_PRE4_EDGE, inside = VIA_S_4 ); 
M1_5STACK_p_PRE5_REGION_1 = interacting( M1_5STACK_p_PRE5, VIA1_5STACK_p_PRE5 ); 
M1_5STACK_p_PRE5_REGION = interacting( M1_5STACK_p_PRE4, M1_5STACK_p_PRE5_REGION_1, >= 2 ); 
M1_5STACK_p_PRE6 = M1_5STACK_p_PRE5_REGION or M1_5STACK_p_PRE5_REGION_1; 
M1_5STACK_p_PRE7 = interacting( M1_5STACK_p_PRE6, VIA1_5STACK_p_PRE5, >= 2 ); 
VIA1_5STACK_p_FINAL = interacting( VIA1_5STACK_p_PRE5, M1_5STACK_p_PRE7 ); 
VIA1_S_5_A1 = interacting( VIA1, VIA1_5STACK_p_FINAL ); 
VIA1_REG_4_S_5_A1 = external1( VIA1_S_5_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA1s space smaller than 0.49 (inside small array)   */ 
VIA1_VIOLATE_S_5_A1 = interacting( VIA1_S_5_A1, VIA1_REG_4_S_5_A1 ); 

// Rule Check    
//**************************************
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_5STACK_p_FINAL }, VIA1_VIOLATE_S_5_A1 }} ); 
VIA2_S_5_A1 = interacting( VIA2, VIA1_5STACK_p_FINAL ); 
VIA2_REG_4_S_5_A1 = external1( VIA2_S_5_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_5_A1 = interacting( VIA2_S_5_A1, VIA2_REG_4_S_5_A1 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_5STACK_p_FINAL }, VIA2_VIOLATE_S_5_A1 }} ); 
VIA3_S_5_A1 = interacting( VIA3, VIA1_5STACK_p_FINAL ); 
VIA3_REG_4_S_5_A1 = external1( VIA3_S_5_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_5_A1 = interacting( VIA3_S_5_A1, VIA3_REG_4_S_5_A1 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_5STACK_p_FINAL }, VIA3_VIOLATE_S_5_A1 }} ); 
VIA4_S_5_A1 = interacting( VIA4, VIA1_5STACK_p_FINAL ); 
VIA4_REG_4_S_5_A1 = external1( VIA4_S_5_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_5_A1 = interacting( VIA4_S_5_A1, VIA4_REG_4_S_5_A1 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_5STACK_p_FINAL }, VIA4_VIOLATE_S_5_A1 }} ); 
VIA5_S_5_A1 = interacting( VIA5, VIA1_5STACK_p_FINAL ); 
VIA5_REG_4_S_5_A1 = external1( VIA5_S_5_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA5s space smaller than 0.49 (inside small array)   */ 
VIA5_VIOLATE_S_5_A1 = interacting( VIA5_S_5_A1, VIA5_REG_4_S_5_A1 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_5STACK_p_FINAL }, VIA5_VIOLATE_S_5_A1 }} ); 
gLAYER_90 = area( VIA1_SAME_ARRAY, >= VIA_A_4 ); 
gLAYER_91 = area( VIA2_SAME_ARRAY, >= VIA_A_4 ); 
gLAYER_89 = gLAYER_90 and gLAYER_91;
gLAYER_92 = area( VIA3_SAME_ARRAY, >= VIA_A_4 ); 
gLAYER_88 = gLAYER_89 and gLAYER_92;
gLAYER_93 = area( VIA4_SAME_ARRAY, >= VIA_A_4 ); 
VIA1_SAME_ARRAY_4STACK_p_PRE1 = gLAYER_88 and gLAYER_93; 
VIA1_SAME_ARRAY_4STACK_p_PRE2 = area( VIA1_SAME_ARRAY_4STACK_p_PRE1, >= VIA_A_4 ); 

//**********************  
// Small 4 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
VIA1_4STACK_p_PRE3 = contains( VIA1_SAME_ARRAY_4STACK_p_PRE2, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA1_REG_3_S_4 = external1( VIA1_4STACK_p_PRE3, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
gLAYER_213 = interacting( M1, VIA1_4STACK_p_PRE3 ); 
gLAYER_214 = interacting( M2, VIA1_4STACK_p_PRE3 ); 
gLAYER_212 = gLAYER_213 or gLAYER_214;
gLAYER_215 = interacting( M3, VIA1_4STACK_p_PRE3 ); 
gLAYER_211 = gLAYER_212 or gLAYER_215;
gLAYER_216 = interacting( M4, VIA1_4STACK_p_PRE3 ); 
gLAYER_210 = gLAYER_211 or gLAYER_216;
gLAYER_217 = interacting( M5, VIA1_4STACK_p_PRE3 ); 
M1_4STACK_p_PRE3 = gLAYER_210 or gLAYER_217; 
VIA1_REG_3_S_4_PRE = VIA1_REG_3_S_4 not M1_4STACK_p_PRE3; 
VIA1_REG_3_S_4_1 = contains( VIA1_REG_3_S_4_PRE, { 0.005, VIA_S_2L }, FORTY_FIVE ); 
gLAYER_218 = interacting( VIA1_REG_3_S_4, VIA1_REG_3_S_4_1 ); 
VIA1_4STACK_p_PRE4 = interacting( VIA1_4STACK_p_PRE3, gLAYER_218 ); 
VIA1ARRAYS1_S_4 = external1( VIA1_4STACK_p_PRE4, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } );    /* Space of different "smae array" smaller than VIA_S_2 */ 
gLAYER_222 = VIA1ARRAYS1_S_4 not_inside M1; 
gLAYER_221 = gLAYER_222 not_inside M2; 
gLAYER_220 = gLAYER_221 not_inside M3; 
gLAYER_219 = gLAYER_220 not_inside M4; 
VIA1ARRAYS2_S_4 = gLAYER_219 not_inside M5; 
VIA1_4STACK_p_PRE5 = interacting( VIA1_4STACK_p_PRE4, VIA1ARRAYS2_S_4 ); 
M1_4STACK_p_PRE4 = external1( M1_4STACK_p_PRE3, <= VIA_S_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M1_4STACK_p_PRE4_EDGE = M1_4STACK_p_PRE3 coincident_outside_edge M1_4STACK_p_PRE4; 
M1_4STACK_p_PRE5 = edge_size( M1_4STACK_p_PRE4_EDGE, inside = VIA_S_4 ); 
M1_4STACK_p_PRE5_REGION_1 = interacting( M1_4STACK_p_PRE5, VIA1_4STACK_p_PRE5 ); 
M1_4STACK_p_PRE5_REGION = interacting( M1_4STACK_p_PRE4, M1_4STACK_p_PRE5_REGION_1, >= 2 ); 
M1_4STACK_p_PRE6 = M1_4STACK_p_PRE5_REGION or M1_4STACK_p_PRE5_REGION_1; 
M1_4STACK_p_PRE7 = interacting( M1_4STACK_p_PRE6, VIA1_4STACK_p_PRE5, >= 2 ); 
VIA1_4STACK_p_FINAL = interacting( VIA1_4STACK_p_PRE5, M1_4STACK_p_PRE7 ); 
VIA1_S_4_A1 = interacting( VIA1, VIA1_4STACK_p_FINAL ); 
VIA1_REG_4_S_4_A1 = external1( VIA1_S_4_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA1s space smaller than 0.49 (inside small array)   */ 
VIA1_VIOLATE_S_4_A1 = interacting( VIA1_S_4_A1, VIA1_REG_4_S_4_A1 ); 

// Rule Check    
//**************************************
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_4STACK_p_FINAL }, VIA1_VIOLATE_S_4_A1 }} ); 
VIA2_S_4_A1 = interacting( VIA2, VIA1_4STACK_p_FINAL ); 
VIA2_REG_4_S_4_A1 = external1( VIA2_S_4_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_4_A1 = interacting( VIA2_S_4_A1, VIA2_REG_4_S_4_A1 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_4STACK_p_FINAL }, VIA2_VIOLATE_S_4_A1 }} ); 
VIA3_S_4_A1 = interacting( VIA3, VIA1_4STACK_p_FINAL ); 
VIA3_REG_4_S_4_A1 = external1( VIA3_S_4_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_4_A1 = interacting( VIA3_S_4_A1, VIA3_REG_4_S_4_A1 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_4STACK_p_FINAL }, VIA3_VIOLATE_S_4_A1 }} ); 
VIA4_S_4_A1 = interacting( VIA4, VIA1_4STACK_p_FINAL ); 
VIA4_REG_4_S_4_A1 = external1( VIA4_S_4_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_4_A1 = interacting( VIA4_S_4_A1, VIA4_REG_4_S_4_A1 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_4STACK_p_FINAL }, VIA4_VIOLATE_S_4_A1 }} ); 
gLAYER_108 = area( VIA2_SAME_ARRAY, >= VIA_A_4 ); 
gLAYER_109 = area( VIA3_SAME_ARRAY, >= VIA_A_4 ); 
gLAYER_107 = gLAYER_108 and gLAYER_109;
gLAYER_110 = area( VIA4_SAME_ARRAY, >= VIA_A_4 ); 
gLAYER_106 = gLAYER_107 and gLAYER_110;
gLAYER_111 = area( VIA5_SAME_ARRAY, >= VIA_A_4 ); 
VIA2_SAME_ARRAY_4STACK_p_PRE1 = gLAYER_106 and gLAYER_111; 
VIA2_SAME_ARRAY_4STACK_p_PRE2 = area( VIA2_SAME_ARRAY_4STACK_p_PRE1, >= VIA_A_4 ); 
VIA2_4STACK_p_PRE3 = contains( VIA2_SAME_ARRAY_4STACK_p_PRE2, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA2_REG_3_S_4 = external1( VIA2_4STACK_p_PRE3, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
gLAYER_226 = interacting( M2, VIA2_4STACK_p_PRE3 ); 
gLAYER_227 = interacting( M3, VIA2_4STACK_p_PRE3 ); 
gLAYER_225 = gLAYER_226 or gLAYER_227;
gLAYER_228 = interacting( M4, VIA2_4STACK_p_PRE3 ); 
gLAYER_224 = gLAYER_225 or gLAYER_228;
gLAYER_229 = interacting( M5, VIA2_4STACK_p_PRE3 ); 
gLAYER_223 = gLAYER_224 or gLAYER_229;
gLAYER_230 = interacting( M6, VIA2_4STACK_p_PRE3 ); 
M2_4STACK_p_PRE3 = gLAYER_223 or gLAYER_230; 
VIA2_REG_3_S_4_PRE = VIA2_REG_3_S_4 not M2_4STACK_p_PRE3; 
VIA2_REG_3_S_4_1 = contains( VIA2_REG_3_S_4_PRE, { 0.005, VIA_S_2L }, FORTY_FIVE ); 
gLAYER_231 = interacting( VIA2_REG_3_S_4, VIA2_REG_3_S_4_1 ); 
VIA2_4STACK_p_PRE4 = interacting( VIA2_4STACK_p_PRE3, gLAYER_231 ); 
VIA2ARRAYS1_S_4 = external1( VIA2_4STACK_p_PRE4, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } );    /* Space of different "smae array" smaller than VIA_S_2 */ 
gLAYER_235 = VIA2ARRAYS1_S_4 not_inside M2; 
gLAYER_234 = gLAYER_235 not_inside M3; 
gLAYER_233 = gLAYER_234 not_inside M4; 
gLAYER_232 = gLAYER_233 not_inside M5; 
VIA2ARRAYS2_S_4 = gLAYER_232 not_inside M6; 
VIA2_4STACK_p_PRE5 = interacting( VIA2_4STACK_p_PRE4, VIA2ARRAYS2_S_4 ); 
M2_4STACK_p_PRE4 = external1( M2_4STACK_p_PRE3, <= VIA_S_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M2_4STACK_p_PRE4_EDGE = M2_4STACK_p_PRE3 coincident_outside_edge M2_4STACK_p_PRE4; 
M2_4STACK_p_PRE5 = edge_size( M2_4STACK_p_PRE4_EDGE, inside = VIA_S_4 ); 
M2_4STACK_p_PRE5_REGION_1 = interacting( M2_4STACK_p_PRE5, VIA2_4STACK_p_PRE5 ); 
M2_4STACK_p_PRE5_REGION = interacting( M2_4STACK_p_PRE4, M2_4STACK_p_PRE5_REGION_1, >= 2 ); 
M2_4STACK_p_PRE6 = M2_4STACK_p_PRE5_REGION or M2_4STACK_p_PRE5_REGION_1; 
M2_4STACK_p_PRE7 = interacting( M2_4STACK_p_PRE6, VIA2_4STACK_p_PRE5, >= 2 ); 
VIA2_4STACK_p_FINAL = interacting( VIA2_4STACK_p_PRE5, M2_4STACK_p_PRE7 ); 
VIA2_S_4_A2 = interacting( VIA2, VIA2_4STACK_p_FINAL ); 
VIA2_REG_4_S_4_A2 = external1( VIA2_S_4_A2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_4_A2 = interacting( VIA2_S_4_A2, VIA2_REG_4_S_4_A2 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA2_4STACK_p_FINAL }, VIA2_VIOLATE_S_4_A2 }} ); 
VIA3_S_4_A2 = interacting( VIA3, VIA2_4STACK_p_FINAL ); 
VIA3_REG_4_S_4_A2 = external1( VIA3_S_4_A2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_4_A2 = interacting( VIA3_S_4_A2, VIA3_REG_4_S_4_A2 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA2_4STACK_p_FINAL }, VIA3_VIOLATE_S_4_A2 }} ); 
VIA4_S_4_A2 = interacting( VIA4, VIA2_4STACK_p_FINAL ); 
VIA4_REG_4_S_4_A2 = external1( VIA4_S_4_A2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_4_A2 = interacting( VIA4_S_4_A2, VIA4_REG_4_S_4_A2 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA2_4STACK_p_FINAL }, VIA4_VIOLATE_S_4_A2 }} ); 
VIA5_S_4_A2 = interacting( VIA5, VIA2_4STACK_p_FINAL ); 
VIA5_REG_4_S_4_A2 = external1( VIA5_S_4_A2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA5s space smaller than 0.49 (inside small array)   */ 
VIA5_VIOLATE_S_4_A2 = interacting( VIA5_S_4_A2, VIA5_REG_4_S_4_A2 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA2_4STACK_p_FINAL }, VIA5_VIOLATE_S_4_A2 }} ); 
gLAYER_125 = area( VIA1_SAME_ARRAY, >= VIA_A_3 ); 
gLAYER_126 = area( VIA2_SAME_ARRAY, >= VIA_A_3 ); 
gLAYER_124 = gLAYER_125 and gLAYER_126;
gLAYER_127 = area( VIA3_SAME_ARRAY, >= VIA_A_3 ); 
VIA1_SAME_ARRAY_3STACK_p_PRE1 = gLAYER_124 and gLAYER_127; 
VIA1_SAME_ARRAY_3STACK_p_PRE2 = area( VIA1_SAME_ARRAY_3STACK_p_PRE1, >= VIA_A_3 ); 

//**********************  
// Small 3 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
VIA1_3STACK_p_PRE3 = contains( VIA1_SAME_ARRAY_3STACK_p_PRE2, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >=VIA_W_1 */ 
VIA1_REG_3_S_3 = external1( VIA1_3STACK_p_PRE3, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
gLAYER_254 = interacting( M1, VIA1_3STACK_p_PRE3 ); 
gLAYER_255 = interacting( M2, VIA1_3STACK_p_PRE3 ); 
gLAYER_253 = gLAYER_254 or gLAYER_255;
gLAYER_256 = interacting( M3, VIA1_3STACK_p_PRE3 ); 
gLAYER_252 = gLAYER_253 or gLAYER_256;
gLAYER_257 = interacting( M4, VIA1_3STACK_p_PRE3 ); 
M1_3STACK_p_PRE3 = gLAYER_252 or gLAYER_257; 
VIA1_REG_3_S_3_PRE = VIA1_REG_3_S_3 not M1_3STACK_p_PRE3; 
VIA1_REG_3_S_3_1 = contains( VIA1_REG_3_S_3_PRE, { 0.005, VIA_S_2L }, FORTY_FIVE );    /* Find parallel run length >= VIA_S_2L */ 
gLAYER_258 = interacting( VIA1_REG_3_S_3, VIA1_REG_3_S_3_1 ); 
VIA1_3STACK_p_PRE4 = interacting( VIA1_3STACK_p_PRE3, gLAYER_258 );    /* Find parallel run length >= VIA_S_2L */ 
VIA1ARRAYS1_S_3 = external1( VIA1_3STACK_p_PRE4, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } );    /* Space of different "smae array" smaller than VIA_S_2 */ 
gLAYER_261 = VIA1ARRAYS1_S_3 not_inside M1; 
gLAYER_260 = gLAYER_261 not_inside M2; 
gLAYER_259 = gLAYER_260 not_inside M3; 
VIA1ARRAYS2_S_3 = gLAYER_259 not_inside M4; 
VIA1_3STACK_p_PRE5 = interacting( VIA1_3STACK_p_PRE4, VIA1ARRAYS2_S_3 ); 
M1_3STACK_p_PRE4 = external1( M1_3STACK_p_PRE3, <= VIA_S_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M1_3STACK_p_PRE4_EDGE = M1_3STACK_p_PRE3 coincident_outside_edge M1_3STACK_p_PRE4; 
M1_3STACK_p_PRE5 = edge_size( M1_3STACK_p_PRE4_EDGE, inside = VIA_S_4 ); 
M1_3STACK_p_PRE5_REGION_1 = interacting( M1_3STACK_p_PRE5, VIA1_3STACK_p_PRE5 ); 
M1_3STACK_p_PRE5_REGION = interacting( M1_3STACK_p_PRE4, M1_3STACK_p_PRE5_REGION_1, >= 2 ); 
M1_3STACK_p_PRE6 = M1_3STACK_p_PRE5_REGION or M1_3STACK_p_PRE5_REGION_1; 
M1_3STACK_p_PRE7 = interacting( M1_3STACK_p_PRE6, VIA1_3STACK_p_PRE5, >= 2 ); 
VIA1_3STACK_p_FINAL = interacting( VIA1_3STACK_p_PRE5, M1_3STACK_p_PRE7 ); 
VIA1_S_3_A1 = interacting( VIA1, VIA1_3STACK_p_FINAL ); 
VIA1_REG_4_S_3_A1 = external1( VIA1_S_3_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA1s space smaller than 0.49 (inside small array)   */ 
VIA1_VIOLATE_S_3_A1 = interacting( VIA1_S_3_A1, VIA1_REG_4_S_3_A1 ); 

// Rule Check    
//**************************************
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_3STACK_p_FINAL }, VIA1_VIOLATE_S_3_A1 }} ); 
VIA2_S_3_A1 = interacting( VIA2, VIA1_3STACK_p_FINAL ); 
VIA2_REG_4_S_3_A1 = external1( VIA2_S_3_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_3_A1 = interacting( VIA2_S_3_A1, VIA2_REG_4_S_3_A1 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_3STACK_p_FINAL }, VIA2_VIOLATE_S_3_A1 }} ); 
VIA3_S_3_A1 = interacting( VIA3, VIA1_3STACK_p_FINAL ); 
VIA3_REG_4_S_3_A1 = external1( VIA3_S_3_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_3_A1 = interacting( VIA3_S_3_A1, VIA3_REG_4_S_3_A1 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_3STACK_p_FINAL }, VIA3_VIOLATE_S_3_A1 }} ); 
gLAYER_137 = area( VIA2_SAME_ARRAY, >= VIA_A_3 ); 
gLAYER_138 = area( VIA3_SAME_ARRAY, >= VIA_A_3 ); 
gLAYER_136 = gLAYER_137 and gLAYER_138;
gLAYER_139 = area( VIA4_SAME_ARRAY, >= VIA_A_3 ); 
VIA2_SAME_ARRAY_3STACK_p_PRE1 = gLAYER_136 and gLAYER_139; 
VIA2_SAME_ARRAY_3STACK_p_PRE2 = area( VIA2_SAME_ARRAY_3STACK_p_PRE1, >= VIA_A_3 ); 
VIA2_3STACK_p_PRE3 = contains( VIA2_SAME_ARRAY_3STACK_p_PRE2, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >=VIA_W_1 */ 
VIA2_REG_3_S_3 = external1( VIA2_3STACK_p_PRE3, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
gLAYER_264 = interacting( M2, VIA2_3STACK_p_PRE3 ); 
gLAYER_265 = interacting( M3, VIA2_3STACK_p_PRE3 ); 
gLAYER_263 = gLAYER_264 or gLAYER_265;
gLAYER_266 = interacting( M4, VIA2_3STACK_p_PRE3 ); 
gLAYER_262 = gLAYER_263 or gLAYER_266;
gLAYER_267 = interacting( M5, VIA2_3STACK_p_PRE3 ); 
M2_3STACK_p_PRE3 = gLAYER_262 or gLAYER_267; 
VIA2_REG_3_S_3_PRE = VIA2_REG_3_S_3 not M2_3STACK_p_PRE3; 
VIA2_REG_3_S_3_1 = contains( VIA2_REG_3_S_3_PRE, { 0.005, VIA_S_2L }, FORTY_FIVE );    /* Find parallel run length >= VIA_S_2L */ 
gLAYER_268 = interacting( VIA2_REG_3_S_3, VIA2_REG_3_S_3_1 ); 
VIA2_3STACK_p_PRE4 = interacting( VIA2_3STACK_p_PRE3, gLAYER_268 );    /* Find parallel run length >= VIA_S_2L */ 
VIA2ARRAYS1_S_3 = external1( VIA2_3STACK_p_PRE4, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } );    /* Space of different "smae array" smaller than VIA_S_2 */ 
gLAYER_271 = VIA2ARRAYS1_S_3 not_inside M2; 
gLAYER_270 = gLAYER_271 not_inside M3; 
gLAYER_269 = gLAYER_270 not_inside M4; 
VIA2ARRAYS2_S_3 = gLAYER_269 not_inside M5; 
VIA2_3STACK_p_PRE5 = interacting( VIA2_3STACK_p_PRE4, VIA2ARRAYS2_S_3 ); 
M2_3STACK_p_PRE4 = external1( M2_3STACK_p_PRE3, <= VIA_S_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M2_3STACK_p_PRE4_EDGE = M2_3STACK_p_PRE3 coincident_outside_edge M2_3STACK_p_PRE4; 
M2_3STACK_p_PRE5 = edge_size( M2_3STACK_p_PRE4_EDGE, inside = VIA_S_4 ); 
M2_3STACK_p_PRE5_REGION_1 = interacting( M2_3STACK_p_PRE5, VIA2_3STACK_p_PRE5 ); 
M2_3STACK_p_PRE5_REGION = interacting( M2_3STACK_p_PRE4, M2_3STACK_p_PRE5_REGION_1, >= 2 ); 
M2_3STACK_p_PRE6 = M2_3STACK_p_PRE5_REGION or M2_3STACK_p_PRE5_REGION_1; 
M2_3STACK_p_PRE7 = interacting( M2_3STACK_p_PRE6, VIA2_3STACK_p_PRE5, >= 2 ); 
VIA2_3STACK_p_FINAL = interacting( VIA2_3STACK_p_PRE5, M2_3STACK_p_PRE7 ); 
VIA2_S_3_A2 = interacting( VIA2, VIA2_3STACK_p_FINAL ); 
VIA2_REG_4_S_3_A2 = external1( VIA2_S_3_A2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_3_A2 = interacting( VIA2_S_3_A2, VIA2_REG_4_S_3_A2 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA2_3STACK_p_FINAL }, VIA2_VIOLATE_S_3_A2 }} ); 
VIA3_S_3_A2 = interacting( VIA3, VIA2_3STACK_p_FINAL ); 
VIA3_REG_4_S_3_A2 = external1( VIA3_S_3_A2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_3_A2 = interacting( VIA3_S_3_A2, VIA3_REG_4_S_3_A2 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA2_3STACK_p_FINAL }, VIA3_VIOLATE_S_3_A2 }} ); 
VIA4_S_3_A2 = interacting( VIA4, VIA2_3STACK_p_FINAL ); 
VIA4_REG_4_S_3_A2 = external1( VIA4_S_3_A2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_3_A2 = interacting( VIA4_S_3_A2, VIA4_REG_4_S_3_A2 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA2_3STACK_p_FINAL }, VIA4_VIOLATE_S_3_A2 }} ); 
gLAYER_149 = area( VIA3_SAME_ARRAY, >= VIA_A_3 ); 
gLAYER_150 = area( VIA4_SAME_ARRAY, >= VIA_A_3 ); 
gLAYER_148 = gLAYER_149 and gLAYER_150;
gLAYER_151 = area( VIA5_SAME_ARRAY, >= VIA_A_3 ); 
VIA3_SAME_ARRAY_3STACK_p_PRE1 = gLAYER_148 and gLAYER_151; 
VIA3_SAME_ARRAY_3STACK_p_PRE2 = area( VIA3_SAME_ARRAY_3STACK_p_PRE1, >= VIA_A_3 ); 
VIA3_3STACK_p_PRE3 = contains( VIA3_SAME_ARRAY_3STACK_p_PRE2, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >=VIA_W_1 */ 
VIA3_REG_3_S_3 = external1( VIA3_3STACK_p_PRE3, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
gLAYER_274 = interacting( M3, VIA3_3STACK_p_PRE3 ); 
gLAYER_275 = interacting( M4, VIA3_3STACK_p_PRE3 ); 
gLAYER_273 = gLAYER_274 or gLAYER_275;
gLAYER_276 = interacting( M5, VIA3_3STACK_p_PRE3 ); 
gLAYER_272 = gLAYER_273 or gLAYER_276;
gLAYER_277 = interacting( M6, VIA3_3STACK_p_PRE3 ); 
M3_3STACK_p_PRE3 = gLAYER_272 or gLAYER_277; 
VIA3_REG_3_S_3_PRE = VIA3_REG_3_S_3 not M3_3STACK_p_PRE3; 
VIA3_REG_3_S_3_1 = contains( VIA3_REG_3_S_3_PRE, { 0.005, VIA_S_2L }, FORTY_FIVE );    /* Find parallel run length >= VIA_S_2L */ 
gLAYER_278 = interacting( VIA3_REG_3_S_3, VIA3_REG_3_S_3_1 ); 
VIA3_3STACK_p_PRE4 = interacting( VIA3_3STACK_p_PRE3, gLAYER_278 );    /* Find parallel run length >= VIA_S_2L */ 
VIA3ARRAYS1_S_3 = external1( VIA3_3STACK_p_PRE4, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } );    /* Space of different "smae array" smaller than VIA_S_2 */ 
gLAYER_281 = VIA3ARRAYS1_S_3 not_inside M3; 
gLAYER_280 = gLAYER_281 not_inside M4; 
gLAYER_279 = gLAYER_280 not_inside M5; 
VIA3ARRAYS2_S_3 = gLAYER_279 not_inside M6; 
VIA3_3STACK_p_PRE5 = interacting( VIA3_3STACK_p_PRE4, VIA3ARRAYS2_S_3 ); 
M3_3STACK_p_PRE4 = external1( M3_3STACK_p_PRE3, <= VIA_S_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M3_3STACK_p_PRE4_EDGE = M3_3STACK_p_PRE3 coincident_outside_edge M3_3STACK_p_PRE4; 
M3_3STACK_p_PRE5 = edge_size( M3_3STACK_p_PRE4_EDGE, inside = VIA_S_4 ); 
M3_3STACK_p_PRE5_REGION_1 = interacting( M3_3STACK_p_PRE5, VIA3_3STACK_p_PRE5 ); 
M3_3STACK_p_PRE5_REGION = interacting( M3_3STACK_p_PRE4, M3_3STACK_p_PRE5_REGION_1, >= 2 ); 
M3_3STACK_p_PRE6 = M3_3STACK_p_PRE5_REGION or M3_3STACK_p_PRE5_REGION_1; 
M3_3STACK_p_PRE7 = interacting( M3_3STACK_p_PRE6, VIA3_3STACK_p_PRE5, >= 2 ); 
VIA3_3STACK_p_FINAL = interacting( VIA3_3STACK_p_PRE5, M3_3STACK_p_PRE7 ); 
VIA3_S_3_A3 = interacting( VIA3, VIA3_3STACK_p_FINAL ); 
VIA3_REG_4_S_3_A3 = external1( VIA3_S_3_A3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_3_A3 = interacting( VIA3_S_3_A3, VIA3_REG_4_S_3_A3 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA3_3STACK_p_FINAL }, VIA3_VIOLATE_S_3_A3 }} ); 
VIA4_S_3_A3 = interacting( VIA4, VIA3_3STACK_p_FINAL ); 
VIA4_REG_4_S_3_A3 = external1( VIA4_S_3_A3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_3_A3 = interacting( VIA4_S_3_A3, VIA4_REG_4_S_3_A3 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA3_3STACK_p_FINAL }, VIA4_VIOLATE_S_3_A3 }} ); 
VIA5_S_3_A3 = interacting( VIA5, VIA3_3STACK_p_FINAL ); 
VIA5_REG_4_S_3_A3 = external1( VIA5_S_3_A3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA5s space smaller than 0.49 (inside small array)   */ 
VIA5_VIOLATE_S_3_A3 = interacting( VIA5_S_3_A3, VIA5_REG_4_S_3_A3 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA3_3STACK_p_FINAL }, VIA5_VIOLATE_S_3_A3 }} ); 
gLAYER_160 = area( VIA1_SAME_ARRAY, >= VIA_A_2 ); 
gLAYER_161 = area( VIA2_SAME_ARRAY, >= VIA_A_2 ); 
VIA1_SAME_ARRAY_2STACK_p_PRE1 = gLAYER_160 and gLAYER_161; 
VIA1_SAME_ARRAY_2STACK_p_PRE2 = area( VIA1_SAME_ARRAY_2STACK_p_PRE1, >= VIA_A_2 ); 

//**********************  
// Small 2 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
VIA1_2STACK_p_PRE3 = contains( VIA1_SAME_ARRAY_2STACK_p_PRE2, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA1_REG_3_S_2 = external1( VIA1_2STACK_p_PRE3, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
gLAYER_301 = interacting( M1, VIA1_2STACK_p_PRE3 ); 
gLAYER_302 = interacting( M2, VIA1_2STACK_p_PRE3 ); 
gLAYER_300 = gLAYER_301 or gLAYER_302;
gLAYER_303 = interacting( M3, VIA1_2STACK_p_PRE3 ); 
M1_2STACK_p_PRE3 = gLAYER_300 or gLAYER_303; 
VIA1_REG_3_S_2_PRE = VIA1_REG_3_S_2 not M1_2STACK_p_PRE3; 
VIA1_REG_3_S_2_1 = contains( VIA1_REG_3_S_2_PRE, { 0.005, VIA_S_2L }, FORTY_FIVE );    /* Find parallel run length >= VIA_S_2L  */ 
gLAYER_304 = interacting( VIA1_REG_3_S_2, VIA1_REG_3_S_2_1 ); 
VIA1_2STACK_p_PRE4 = interacting( VIA1_2STACK_p_PRE3, gLAYER_304 );    /* Find parallel run length >= VIA_S_2L */ 
VIA1ARRAYS1_S_2 = external1( VIA1_2STACK_p_PRE4, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } );    /* Space of different "smae array" smaller than >= VIA_S_2 */ 
gLAYER_306 = VIA1ARRAYS1_S_2 not_inside M1; 
gLAYER_305 = gLAYER_306 not_inside M2; 
VIA1ARRAYS2_S_2 = gLAYER_305 not_inside M3; 
VIA1_2STACK_p_PRE5 = interacting( VIA1_2STACK_p_PRE4, VIA1ARRAYS2_S_2 ); 
M1_2STACK_p_PRE4 = external1( M1_2STACK_p_PRE3, <= VIA_S_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M1_2STACK_p_PRE4_EDGE = M1_2STACK_p_PRE3 coincident_outside_edge M1_2STACK_p_PRE4; 
M1_2STACK_p_PRE5 = edge_size( M1_2STACK_p_PRE4_EDGE, inside = VIA_S_4 ); 
M1_2STACK_p_PRE5_REGION_1 = interacting( M1_2STACK_p_PRE5, VIA1_2STACK_p_PRE5 ); 
M1_2STACK_p_PRE5_REGION = interacting( M1_2STACK_p_PRE4, M1_2STACK_p_PRE5_REGION_1, >= 2 ); 
M1_2STACK_p_PRE6 = M1_2STACK_p_PRE5_REGION or M1_2STACK_p_PRE5_REGION_1; 
M1_2STACK_p_PRE7 = interacting( M1_2STACK_p_PRE6, VIA1_2STACK_p_PRE5, >= 2 ); 
VIA1_2STACK_p_FINAL = interacting( VIA1_2STACK_p_PRE5, M1_2STACK_p_PRE7 ); 
VIA1_S_2_A1 = interacting( VIA1, VIA1_2STACK_p_FINAL ); 
VIA1_REG_4_S_2_A1 = external1( VIA1_S_2_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA1s space smaller than 0.49 (inside small array)   */ 
VIA1_VIOLATE_S_2_A1 = interacting( VIA1_S_2_A1, VIA1_REG_4_S_2_A1 ); 

// Rule Check    
//**************************************
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_2STACK_p_FINAL }, VIA1_VIOLATE_S_2_A1 }} ); 
VIA2_S_2_A1 = interacting( VIA2, VIA1_2STACK_p_FINAL ); 
VIA2_REG_4_S_2_A1 = external1( VIA2_S_2_A1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_2_A1 = interacting( VIA2_S_2_A1, VIA2_REG_4_S_2_A1 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA1_2STACK_p_FINAL }, VIA2_VIOLATE_S_2_A1 }} ); 
gLAYER_166 = area( VIA2_SAME_ARRAY, >= VIA_A_2 ); 
gLAYER_167 = area( VIA3_SAME_ARRAY, >= VIA_A_2 ); 
VIA2_SAME_ARRAY_2STACK_p_PRE1 = gLAYER_166 and gLAYER_167; 
VIA2_SAME_ARRAY_2STACK_p_PRE2 = area( VIA2_SAME_ARRAY_2STACK_p_PRE1, >= VIA_A_2 ); 
VIA2_2STACK_p_PRE3 = contains( VIA2_SAME_ARRAY_2STACK_p_PRE2, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA2_REG_3_S_2 = external1( VIA2_2STACK_p_PRE3, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
gLAYER_308 = interacting( M2, VIA2_2STACK_p_PRE3 ); 
gLAYER_309 = interacting( M3, VIA2_2STACK_p_PRE3 ); 
gLAYER_307 = gLAYER_308 or gLAYER_309;
gLAYER_310 = interacting( M4, VIA2_2STACK_p_PRE3 ); 
M2_2STACK_p_PRE3 = gLAYER_307 or gLAYER_310; 
VIA2_REG_3_S_2_PRE = VIA2_REG_3_S_2 not M2_2STACK_p_PRE3; 
VIA2_REG_3_S_2_1 = contains( VIA2_REG_3_S_2_PRE, { 0.005, VIA_S_2L }, FORTY_FIVE );    /* Find parallel run length >= VIA_S_2L  */ 
gLAYER_311 = interacting( VIA2_REG_3_S_2, VIA2_REG_3_S_2_1 ); 
VIA2_2STACK_p_PRE4 = interacting( VIA2_2STACK_p_PRE3, gLAYER_311 );    /* Find parallel run length >= VIA_S_2L */ 
VIA2ARRAYS1_S_2 = external1( VIA2_2STACK_p_PRE4, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } );    /* Space of different "smae array" smaller than >= VIA_S_2 */ 
gLAYER_313 = VIA2ARRAYS1_S_2 not_inside M2; 
gLAYER_312 = gLAYER_313 not_inside M3; 
VIA2ARRAYS2_S_2 = gLAYER_312 not_inside M4; 
VIA2_2STACK_p_PRE5 = interacting( VIA2_2STACK_p_PRE4, VIA2ARRAYS2_S_2 ); 
M2_2STACK_p_PRE4 = external1( M2_2STACK_p_PRE3, <= VIA_S_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M2_2STACK_p_PRE4_EDGE = M2_2STACK_p_PRE3 coincident_outside_edge M2_2STACK_p_PRE4; 
M2_2STACK_p_PRE5 = edge_size( M2_2STACK_p_PRE4_EDGE, inside = VIA_S_4 ); 
M2_2STACK_p_PRE5_REGION_1 = interacting( M2_2STACK_p_PRE5, VIA2_2STACK_p_PRE5 ); 
M2_2STACK_p_PRE5_REGION = interacting( M2_2STACK_p_PRE4, M2_2STACK_p_PRE5_REGION_1, >= 2 ); 
M2_2STACK_p_PRE6 = M2_2STACK_p_PRE5_REGION or M2_2STACK_p_PRE5_REGION_1; 
M2_2STACK_p_PRE7 = interacting( M2_2STACK_p_PRE6, VIA2_2STACK_p_PRE5, >= 2 ); 
VIA2_2STACK_p_FINAL = interacting( VIA2_2STACK_p_PRE5, M2_2STACK_p_PRE7 ); 
VIA2_S_2_A2 = interacting( VIA2, VIA2_2STACK_p_FINAL ); 
VIA2_REG_4_S_2_A2 = external1( VIA2_S_2_A2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_2_A2 = interacting( VIA2_S_2_A2, VIA2_REG_4_S_2_A2 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA2_2STACK_p_FINAL }, VIA2_VIOLATE_S_2_A2 }} ); 
VIA3_S_2_A2 = interacting( VIA3, VIA2_2STACK_p_FINAL ); 
VIA3_REG_4_S_2_A2 = external1( VIA3_S_2_A2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_2_A2 = interacting( VIA3_S_2_A2, VIA3_REG_4_S_2_A2 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA2_2STACK_p_FINAL }, VIA3_VIOLATE_S_2_A2 }} ); 
gLAYER_172 = area( VIA3_SAME_ARRAY, >= VIA_A_2 ); 
gLAYER_173 = area( VIA4_SAME_ARRAY, >= VIA_A_2 ); 
VIA3_SAME_ARRAY_2STACK_p_PRE1 = gLAYER_172 and gLAYER_173; 
VIA3_SAME_ARRAY_2STACK_p_PRE2 = area( VIA3_SAME_ARRAY_2STACK_p_PRE1, >= VIA_A_2 ); 
VIA3_2STACK_p_PRE3 = contains( VIA3_SAME_ARRAY_2STACK_p_PRE2, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA3_REG_3_S_2 = external1( VIA3_2STACK_p_PRE3, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
gLAYER_315 = interacting( M3, VIA3_2STACK_p_PRE3 ); 
gLAYER_316 = interacting( M4, VIA3_2STACK_p_PRE3 ); 
gLAYER_314 = gLAYER_315 or gLAYER_316;
gLAYER_317 = interacting( M5, VIA3_2STACK_p_PRE3 ); 
M3_2STACK_p_PRE3 = gLAYER_314 or gLAYER_317; 
VIA3_REG_3_S_2_PRE = VIA3_REG_3_S_2 not M3_2STACK_p_PRE3; 
VIA3_REG_3_S_2_1 = contains( VIA3_REG_3_S_2_PRE, { 0.005, VIA_S_2L }, FORTY_FIVE );    /* Find parallel run length >= VIA_S_2L  */ 
gLAYER_318 = interacting( VIA3_REG_3_S_2, VIA3_REG_3_S_2_1 ); 
VIA3_2STACK_p_PRE4 = interacting( VIA3_2STACK_p_PRE3, gLAYER_318 );    /* Find parallel run length >= VIA_S_2L */ 
VIA3ARRAYS1_S_2 = external1( VIA3_2STACK_p_PRE4, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } );    /* Space of different "smae array" smaller than >= VIA_S_2 */ 
gLAYER_320 = VIA3ARRAYS1_S_2 not_inside M3; 
gLAYER_319 = gLAYER_320 not_inside M4; 
VIA3ARRAYS2_S_2 = gLAYER_319 not_inside M5; 
VIA3_2STACK_p_PRE5 = interacting( VIA3_2STACK_p_PRE4, VIA3ARRAYS2_S_2 ); 
M3_2STACK_p_PRE4 = external1( M3_2STACK_p_PRE3, <= VIA_S_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M3_2STACK_p_PRE4_EDGE = M3_2STACK_p_PRE3 coincident_outside_edge M3_2STACK_p_PRE4; 
M3_2STACK_p_PRE5 = edge_size( M3_2STACK_p_PRE4_EDGE, inside = VIA_S_4 ); 
M3_2STACK_p_PRE5_REGION_1 = interacting( M3_2STACK_p_PRE5, VIA3_2STACK_p_PRE5 ); 
M3_2STACK_p_PRE5_REGION = interacting( M3_2STACK_p_PRE4, M3_2STACK_p_PRE5_REGION_1, >= 2 ); 
M3_2STACK_p_PRE6 = M3_2STACK_p_PRE5_REGION or M3_2STACK_p_PRE5_REGION_1; 
M3_2STACK_p_PRE7 = interacting( M3_2STACK_p_PRE6, VIA3_2STACK_p_PRE5, >= 2 ); 
VIA3_2STACK_p_FINAL = interacting( VIA3_2STACK_p_PRE5, M3_2STACK_p_PRE7 ); 
VIA3_S_2_A3 = interacting( VIA3, VIA3_2STACK_p_FINAL ); 
VIA3_REG_4_S_2_A3 = external1( VIA3_S_2_A3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_2_A3 = interacting( VIA3_S_2_A3, VIA3_REG_4_S_2_A3 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA3_2STACK_p_FINAL }, VIA3_VIOLATE_S_2_A3 }} ); 
VIA4_S_2_A3 = interacting( VIA4, VIA3_2STACK_p_FINAL ); 
VIA4_REG_4_S_2_A3 = external1( VIA4_S_2_A3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_2_A3 = interacting( VIA4_S_2_A3, VIA4_REG_4_S_2_A3 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA3_2STACK_p_FINAL }, VIA4_VIOLATE_S_2_A3 }} ); 
gLAYER_178 = area( VIA4_SAME_ARRAY, >= VIA_A_2 ); 
gLAYER_179 = area( VIA5_SAME_ARRAY, >= VIA_A_2 ); 
VIA4_SAME_ARRAY_2STACK_p_PRE1 = gLAYER_178 and gLAYER_179; 
VIA4_SAME_ARRAY_2STACK_p_PRE2 = area( VIA4_SAME_ARRAY_2STACK_p_PRE1, >= VIA_A_2 ); 
VIA4_2STACK_p_PRE3 = contains( VIA4_SAME_ARRAY_2STACK_p_PRE2, { VIA_S_2L, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
VIA4_REG_3_S_2 = external1( VIA4_2STACK_p_PRE3, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
gLAYER_322 = interacting( M4, VIA4_2STACK_p_PRE3 ); 
gLAYER_323 = interacting( M5, VIA4_2STACK_p_PRE3 ); 
gLAYER_321 = gLAYER_322 or gLAYER_323;
gLAYER_324 = interacting( M6, VIA4_2STACK_p_PRE3 ); 
M4_2STACK_p_PRE3 = gLAYER_321 or gLAYER_324; 
VIA4_REG_3_S_2_PRE = VIA4_REG_3_S_2 not M4_2STACK_p_PRE3; 
VIA4_REG_3_S_2_1 = contains( VIA4_REG_3_S_2_PRE, { 0.005, VIA_S_2L }, FORTY_FIVE );    /* Find parallel run length >= VIA_S_2L  */ 
gLAYER_325 = interacting( VIA4_REG_3_S_2, VIA4_REG_3_S_2_1 ); 
VIA4_2STACK_p_PRE4 = interacting( VIA4_2STACK_p_PRE3, gLAYER_325 );    /* Find parallel run length >= VIA_S_2L */ 
VIA4ARRAYS1_S_2 = external1( VIA4_2STACK_p_PRE4, <= VIA_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } );    /* Space of different "smae array" smaller than >= VIA_S_2 */ 
gLAYER_327 = VIA4ARRAYS1_S_2 not_inside M4; 
gLAYER_326 = gLAYER_327 not_inside M5; 
VIA4ARRAYS2_S_2 = gLAYER_326 not_inside M6; 
VIA4_2STACK_p_PRE5 = interacting( VIA4_2STACK_p_PRE4, VIA4ARRAYS2_S_2 ); 
M4_2STACK_p_PRE4 = external1( M4_2STACK_p_PRE3, <= VIA_S_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH } ); 
M4_2STACK_p_PRE4_EDGE = M4_2STACK_p_PRE3 coincident_outside_edge M4_2STACK_p_PRE4; 
M4_2STACK_p_PRE5 = edge_size( M4_2STACK_p_PRE4_EDGE, inside = VIA_S_4 ); 
M4_2STACK_p_PRE5_REGION_1 = interacting( M4_2STACK_p_PRE5, VIA4_2STACK_p_PRE5 ); 
M4_2STACK_p_PRE5_REGION = interacting( M4_2STACK_p_PRE4, M4_2STACK_p_PRE5_REGION_1, >= 2 ); 
M4_2STACK_p_PRE6 = M4_2STACK_p_PRE5_REGION or M4_2STACK_p_PRE5_REGION_1; 
M4_2STACK_p_PRE7 = interacting( M4_2STACK_p_PRE6, VIA4_2STACK_p_PRE5, >= 2 ); 
VIA4_2STACK_p_FINAL = interacting( VIA4_2STACK_p_PRE5, M4_2STACK_p_PRE7 ); 
VIA4_S_2_A4 = interacting( VIA4, VIA4_2STACK_p_FINAL ); 
VIA4_REG_4_S_2_A4 = external1( VIA4_S_2_A4, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_2_A4 = interacting( VIA4_S_2_A4, VIA4_REG_4_S_2_A4 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA4_2STACK_p_FINAL }, VIA4_VIOLATE_S_2_A4 }} ); 
VIA5_S_2_A4 = interacting( VIA5, VIA4_2STACK_p_FINAL ); 
VIA5_REG_4_S_2_A4 = external1( VIA5_S_2_A4, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA5s space smaller than 0.49 (inside small array)   */ 
VIA5_VIOLATE_S_2_A4 = interacting( VIA5_S_2_A4, VIA5_REG_4_S_2_A4 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA4_2STACK_p_FINAL }, VIA5_VIOLATE_S_2_A4 }} ); 

//METAL SLOT CHECKS
//================
//Bonding pad ,chip corner dummy pad ,and inductor need not put slot
CB_NON_CUP = not_interacting( CBI, WBDMY ); 
SLT_EXD = CB_NON_CUP or DPDMY; 
M1EXD = M1XD not SLT_EXD; 

//M1 SLOT CHECKS
//==============
M1INNERHOLE = donut_holes( M1EXD, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M1BIGHOLE = size( M1INNERHOLE, clip_acute = NONE, distance = - MHOLE / 2 ); 
M1HOLE = M1INNERHOLE outside M1BIGHOLE; 
M1HOLESPACE = M1HOLE not M1EXD; 
FIM1C = M1EXD or M1HOLESPACE; 
gLAYER_356 = size( size( FIM1C, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
gLAYER_355 = size( size( gLAYER_356, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
LM1XA = gLAYER_355 and FIM1C; 
LM1X = contains( LM1XA, { 35.005, 35.005 }, FORTY_FIVE ); 
M1HOLED = M1HOLESPACE and LM1X; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1HOLED }, LM1X }} ); 
M2EXD = M2XD not SLT_EXD; 

//M2 SLOT CHECKS
//==============
M2INNERHOLE = donut_holes( M2EXD, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M2BIGHOLE = size( M2INNERHOLE, clip_acute = NONE, distance = - MHOLE / 2 ); 
M2HOLE = M2INNERHOLE outside M2BIGHOLE; 
M2HOLESPACE = M2HOLE not M2EXD; 
FIM2C = M2EXD or M2HOLESPACE; 
gLAYER_358 = size( size( FIM2C, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
gLAYER_357 = size( size( gLAYER_358, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
LM2XA = gLAYER_357 and FIM2C; 
LM2X = contains( LM2XA, { 35.005, 35.005 }, FORTY_FIVE ); 
M2HOLED = M2HOLESPACE and LM2X; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2HOLED }, LM2X }} ); 
M3EXD = M3XD not SLT_EXD; 

//M3 SLOT CHECKS
//==============
M3INNERHOLE = donut_holes( M3EXD, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M3BIGHOLE = size( M3INNERHOLE, clip_acute = NONE, distance = - MHOLE / 2 ); 
M3HOLE = M3INNERHOLE outside M3BIGHOLE; 
M3HOLESPACE = M3HOLE not M3EXD; 
FIM3C = M3EXD or M3HOLESPACE; 
gLAYER_360 = size( size( FIM3C, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
gLAYER_359 = size( size( gLAYER_360, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
LM3XA = gLAYER_359 and FIM3C; 
LM3X = contains( LM3XA, { 35.005, 35.005 }, FORTY_FIVE ); 
M3HOLED = M3HOLESPACE and LM3X; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3HOLED }, LM3X }} ); 
M4EXD = M4XD not SLT_EXD; 

//M4 SLOT CHECKS
//==============
M4INNERHOLE = donut_holes( M4EXD, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M4BIGHOLE = size( M4INNERHOLE, clip_acute = NONE, distance = - MHOLE / 2 ); 
M4HOLE = M4INNERHOLE outside M4BIGHOLE; 
M4HOLESPACE = M4HOLE not M4EXD; 
FIM4C = M4EXD or M4HOLESPACE; 
gLAYER_362 = size( size( FIM4C, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
gLAYER_361 = size( size( gLAYER_362, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
LM4XA = gLAYER_361 and FIM4C; 
LM4X = contains( LM4XA, { 35.005, 35.005 }, FORTY_FIVE ); 
M4HOLED = M4HOLESPACE and LM4X; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4HOLED }, LM4X }} ); 
SLT_EXDT = CBI or DPDMY; 
M5EXD = M5XD not SLT_EXDT; 

//M5 SLOT CHECKS
//==============
M5INNERHOLE = donut_holes( M5EXD, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M5BIGHOLE = size( M5INNERHOLE, clip_acute = NONE, distance = - MHOLE / 2 ); 
M5HOLE = M5INNERHOLE outside M5BIGHOLE; 
M5HOLESPACE = M5HOLE not M5EXD; 
FIM5C = M5EXD or M5HOLESPACE; 
gLAYER_364 = size( size( FIM5C, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
gLAYER_363 = size( size( gLAYER_364, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
LM5XA = gLAYER_363 and FIM5C; 
LM5X = contains( LM5XA, { 35.005, 35.005 }, FORTY_FIVE ); 
M5HOLED = M5HOLESPACE and LM5X; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M5HOLED }, LM5X }} ); 
gLAYER_354 = MDXD or PPII; 
PAD_EXD = not_interacting( UBMI, gLAYER_354 ); 
PAD_EXD6 = size_inside_wrapper( PAD_EXD, M6XD, distance = 2, increment = 0.32 ); 
gLAYER_365 = SLT_EXDT or PAD_EXD6; 
M6EXD = M6XD not gLAYER_365; 

//M6 SLOT CHECKS
//==============
M6INNERHOLE = donut_holes( M6EXD, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M6BIGHOLE = size( M6INNERHOLE, clip_acute = NONE, distance = - MHOLE / 2 ); 
M6HOLE = M6INNERHOLE outside M6BIGHOLE; 
M6HOLESPACE = M6HOLE not M6EXD; 
FIM6C = M6EXD or M6HOLESPACE; 
gLAYER_367 = size( size( FIM6C, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
gLAYER_366 = size( size( gLAYER_367, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
LM6XA = gLAYER_366 and FIM6C; 
LM6X = contains( LM6XA, { 35.005, 35.005 }, FORTY_FIVE ); 
M6HOLED = M6HOLESPACE and LM6X; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6HOLED }, LM6X }} ); 

//MD SLOT CHECKS
//==============
// Bonding pad, chip corner dummy pad, and inductor need not put slot
UBM_EXDD = size_inside_wrapper( UBMI, MDXD, distance = 2, increment = 0.32 );    /* For RDL */ 
gLAYER_368 = DPDMY or UBM_EXDD; 
MDEXD = MDXD not gLAYER_368; 
MDINNERHOLE = donut_holes( MDEXD, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
MDBIGHOLE = size( MDINNERHOLE, clip_acute = NONE, distance = - 5 );    /* Holes with width less than 10um will be filled back */ 
MDHOLE = MDINNERHOLE outside MDBIGHOLE; 
MDHOLESPACE = MDHOLE not MDEXD; 
FIMDC = MDEXD or MDHOLESPACE; 
gLAYER_370 = size( size( FIMDC, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
gLAYER_369 = size( size( gLAYER_370, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
LMDXA = gLAYER_369 and FIMDC; 
LMDX = contains( LMDXA, { 35.005, 35.005 }, FORTY_FIVE ); 
MDHOLED = MDHOLESPACE and LMDX; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MDHOLED }, LMDX }} ); 
gNP = NPI not_inside EXCL; 
NPOD = gNP and OD;                        /* N+ OD region */ 
NWEL = NWELI not_inside EXCL; 
NACT = NPOD not NWEL;                    /* NMOS Device */ 
gLAYER_372 = SDI and NACT; 
ENACT = gLAYER_372 not DIODUMMY; 
ENMOS = enclosing( ENACT, ALL_GATE ); 
gLAYER_375 = SDI and ALL_GATE; 
EGTE = gLAYER_375 not DIODUMMY; 
ENSD = ENMOS not EGTE; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ ENSD }, NSDI }} ); 
PP = PPI not_inside EXCL; 
PPOD = PP and OD;                        /* P+ OD region */ 
PACT = PPOD and NWEL;                    /* PMOS Device */ 

//I/O ESD Guidance 
//================
gLAYER_371 = SDI and PACT; 
EPACT = gLAYER_371 not DIODUMMY; 
EPMOS = enclosing( EPACT, ALL_GATE ); 
EPSD = EPMOS not EGTE; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ EPSD }, PSDI }} ); 
PWEL = PWELI not EXCL; 
#ifdef GUIDELINE_ESD 
   NWELC = copy( NWEL ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWELC }, NWELC }} ); 
   PWELC = copy( PWEL ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWELC }, PWELC }} ); 
#endif
DNW = DNWI not EXCL; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWEL }, DNW }} ); 

// Wire-Bond
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6XD }, CBI }} ); 
gLAYER_412 = not_interacting( UBMI, PPII ); 
UBMN = not_interacting( gLAYER_412, MDI );    /* UBM lie on Top Metal */ 

// Flip-chip
// 1_Ground up
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6XD, UBMN }, CBDI, NONE }} ); 
UBMD = UBMI not UBMN;                    /* UBM lie on PPI or MD */ 

// 2_RDL (before passivation)
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MDXD }, UBMD }} ); 

// 3_PPI (After passivation)
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6XD, PPII }, CBDI, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PPII }, UBMD }} ); 
NPODC = NPI and ODI; 
EMPTYI = gCHIP not gBULK; 
gLAYER_416 = NPODC and NWELI; 
NTAPJ = EMPTYI or gLAYER_416; 
gLAYER_415 = NWELI and RWDMY; 
NW_RES_200OHM = gLAYER_415 and RES200; 
NWELJ = NWELI not NW_RES_200OHM; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPJ }, NWELJ }} ); 
PPODC = PPI and ODI; 
PACTC = PPODC and NONWRI; 
PSDC = PACTC not POLYI;                  /* PMOS source/drain */ 

//Build connection for RES200
//============================
gLAYER_413 = ODI and RPDUMMY; 
OD_RES_200OHM = gLAYER_413 and RES200; 
PSDJ = PSDC not OD_RES_200OHM; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPJ }, PSDJ }} ); 
PTAPC = PPODC not NWELI; 
PTAPJ = EMPTYI or PTAPC; 
NACTC = NPODC not NWELI; 
NSDC = NACTC not POLYI;                  /* NMOS source/drain */ 
NSDJ = NSDC not OD_RES_200OHM; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPJ }, NSDJ }} ); 
RWJ = EMPTYI or RWI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPJ }, RWJ }} ); 
PWELJ = EMPTYI or PWELI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPJ }, PWELJ }} ); 
M1X = M1I not M1SLOTI; 
M1J = EMPTYI or M1X; 
gLAYER_414 = POLYI and RPDUMMY; 
PO_RES_200OHM = gLAYER_414 and RES200; 
ILP1J = POLYI not PO_RES_200OHM; 
COJ = EMPTYI or COI; 
COJ_ILP1J = COJ and (ILP1J and M1J);
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COJ_ILP1J }, COJ, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1J, ILP1J }, COJ_ILP1J, NONE }} );
COJ_NTAPJ = COJ and (NTAPJ and M1J) not COJ_ILP1J;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COJ_NTAPJ }, COJ, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1J, NTAPJ }, COJ_NTAPJ, NONE }} );
COJ_PTAPJ = COJ and (PTAPJ and M1J) not COJ_ILP1J not COJ_NTAPJ;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COJ_PTAPJ }, COJ, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1J, PTAPJ }, COJ_PTAPJ, NONE }} );
COJ_PSDJ = COJ and (PSDJ and M1J) not COJ_ILP1J not COJ_NTAPJ not COJ_PTAPJ;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COJ_PSDJ }, COJ, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1J, PSDJ }, COJ_PSDJ, NONE }} );
COJ_NSDJ  = COJ and (NSDJ  and M1J) not COJ_ILP1J not COJ_NTAPJ not COJ_PTAPJ not COJ_PSDJ;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COJ_NSDJ  }, COJ, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1J, NSDJ  }, COJ_NSDJ , NONE }} );
gLAYER_411 = interacting( NWELI, RWDMY ); 
NWRIT = gLAYER_411 not RWDMY;             /* NWR terminal */ 
NWRJT = EMPTYI or NWRIT; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1J, NWRJT }, COJ, NONE }} ); 
M2X = M2I not M2SLOTI; 
M2J = EMPTYI or M2X; 
VIA1J = EMPTYI or VIA1I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1J, M2J }, VIA1J, NONE }} ); 
M3X = M3I not M3SLOTI; 
M3J = EMPTYI or M3X; 
VIA2J = EMPTYI or VIA2I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2J, M3J }, VIA2J, NONE }} ); 
M4X = M4I not M4SLOTI; 
M4J = EMPTYI or M4X; 
VIA3J = EMPTYI or VIA3I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3J, M4J }, VIA3J, NONE }} ); 
M5X = M5I not M5SLOTI; 
M5J = EMPTYI or M5X; 
VIA4J = EMPTYI or VIA4I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4J, M5J }, VIA4J, NONE }} ); 
M6X = M6I not M6SLOTI; 
M6J = EMPTYI or M6X; 
CTM5J = EMPTYI or CTM5I; 
CMM5J = EMPTYI or CMM5I; 
VIA5J = EMPTYI or VIA5I; 
VIA5J_CTM5J = VIA5J and (CTM5J and M6J);
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5J_CTM5J }, VIA5J, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6J, CTM5J }, VIA5J_CTM5J, NONE }} );
VIA5J_CMM5J = VIA5J and (CMM5J and M6J) not VIA5J_CTM5J;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5J_CMM5J }, VIA5J, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6J, CMM5J }, VIA5J_CMM5J, NONE }} );
VIA5J_M5J  = VIA5J and (M5J  and M6J) not VIA5J_CTM5J not VIA5J_CMM5J;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5J_M5J  }, VIA5J, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6J, M5J  }, VIA5J_M5J , NONE }} );
MDX = MDI not MDSLOTI; 
MDJ = EMPTYI or MDX; 
VIADJ = EMPTYI or VIADI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6J, MDJ }, VIADJ, NONE }} ); 
CBJ = EMPTYI or CBI; 

// Wire-Bond
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6J }, CBJ }} ); 
UBMNJ = EMPTYI or UBMN; 
CBDJ = EMPTYI or CBDI; 

// Flip-chip
// 1_Ground up
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6J, UBMNJ }, CBDJ, NONE }} ); 
UBMDJ = EMPTYI or UBMD; 

// 2_RDL (before passivation)
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MDJ }, UBMDJ }} ); 
PPIJ = EMPTYI or PPII; 

// 3_PPI (After passivation)
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6J, PPIJ }, CBDJ, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PPIJ }, UBMDJ }} ); 
NTAPU = NPODC and NWELI; 

//Build connection for CONNECT_ALL_RESISTOR
//============================
NWELU = copy( NWELI ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPU }, NWELU }} ); 
PSDU = copy( PSDC ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPU }, PSDU }} ); 
PTAPU = copy( PTAPC ); 
NSDU = copy( NSDC ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPU }, NSDU }} ); 
RWU = copy( RWI ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPU }, RWU }} ); 
PWELU = copy( PWELI ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPU }, PWELU }} ); 
M1U = copy( M1X ); 
ILP1U = copy( POLYI ); 
COU = copy( COI ); 
COU_ILP1U = COU and (ILP1U and M1U);
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COU_ILP1U }, COU, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1U, ILP1U }, COU_ILP1U, NONE }} );
COU_NTAPU = COU and (NTAPU and M1U) not COU_ILP1U;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COU_NTAPU }, COU, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1U, NTAPU }, COU_NTAPU, NONE }} );
COU_PTAPU = COU and (PTAPU and M1U) not COU_ILP1U not COU_NTAPU;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COU_PTAPU }, COU, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1U, PTAPU }, COU_PTAPU, NONE }} );
COU_PSDU = COU and (PSDU and M1U) not COU_ILP1U not COU_NTAPU not COU_PTAPU;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COU_PSDU }, COU, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1U, PSDU }, COU_PSDU, NONE }} );
COU_NSDU  = COU and (NSDU  and M1U) not COU_ILP1U not COU_NTAPU not COU_PTAPU not COU_PSDU;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COU_NSDU  }, COU, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1U, NSDU  }, COU_NSDU , NONE }} );
NWRUT = copy( NWRIT ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1U, NWRUT }, COU, NONE }} ); 
M2U = copy( M2X ); 
VIA1U = copy( VIA1I ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1U, M2U }, VIA1U, NONE }} ); 
M3U = copy( M3X ); 
VIA2U = copy( VIA2I ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2U, M3U }, VIA2U, NONE }} ); 
M4U = copy( M4X ); 
VIA3U = copy( VIA3I ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3U, M4U }, VIA3U, NONE }} ); 
M5U = copy( M5X ); 
VIA4U = copy( VIA4I ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4U, M5U }, VIA4U, NONE }} ); 
M6U = copy( M6X ); 
CTM5U = copy( CTM5I ); 
CMM5U = copy( CMM5I ); 
VIA5U = copy( VIA5I ); 
VIA5U_CTM5U = VIA5U and (CTM5U and M6U);
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5U_CTM5U }, VIA5U, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6U, CTM5U }, VIA5U_CTM5U, NONE }} );
VIA5U_CMM5U = VIA5U and (CMM5U and M6U) not VIA5U_CTM5U;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5U_CMM5U }, VIA5U, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6U, CMM5U }, VIA5U_CMM5U, NONE }} );
VIA5U_M5U  = VIA5U and (M5U  and M6U) not VIA5U_CTM5U not VIA5U_CMM5U;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5U_M5U  }, VIA5U, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6U, M5U  }, VIA5U_M5U , NONE }} );
MDU = copy( MDX ); 
VIADU = copy( VIADI ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6U, MDU }, VIADU, NONE }} ); 
CBU = copy( CBI ); 

// Wire-Bond
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6U }, CBU }} ); 
UBMNU = copy( UBMN ); 
CBDU = copy( CBDI ); 

// Flip-chip
// 1_Ground up
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6U, UBMNU }, CBDU, NONE }} ); 
UBMDU = copy( UBMD ); 

// 2_RDL (before passivation)
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MDU }, UBMDU }} ); 
PPIU = copy( PPII ); 

// 3_PPI (After passivation)
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6U, PPIU }, CBDU, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PPIU }, UBMDU }} ); 
NTAPC = NPODC and NONWRI; 
NTAPK = NTAPC not EMPTYI; 

//Build connection for DISCONNECT_ALL_RESISTOR
//============================
NWELK = NWELI not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPK }, NWELK }} ); 
RPO_RPDMY = RPOI or RPDUMMY; 
gLAYER_418 = PSDC not RPO_RPDMY; 
PSDK = gLAYER_418 not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPK }, PSDK }} ); 
PTAPK = PTAPC not EMPTYI; 
gLAYER_417 = NSDC not RPO_RPDMY; 
NSDK = gLAYER_417 not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPK }, NSDK }} ); 
RWK = RWI not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPK }, RWK }} ); 
PWELK = PWELI not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPK }, PWELK }} ); 
M1K = M1X not EMPTYI; 
ILP1K = POLYI not RPO_RPDMY; 
COK = COI not EMPTYI; 
COK_ILP1K = COK and (ILP1K and M1K);
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COK_ILP1K }, COK, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1K, ILP1K }, COK_ILP1K, NONE }} );
COK_NTAPK = COK and (NTAPK and M1K) not COK_ILP1K;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COK_NTAPK }, COK, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1K, NTAPK }, COK_NTAPK, NONE }} );
COK_PTAPK = COK and (PTAPK and M1K) not COK_ILP1K not COK_NTAPK;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COK_PTAPK }, COK, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1K, PTAPK }, COK_PTAPK, NONE }} );
COK_PSDK = COK and (PSDK and M1K) not COK_ILP1K not COK_NTAPK not COK_PTAPK;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COK_PSDK }, COK, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1K, PSDK }, COK_PSDK, NONE }} );
COK_NSDK  = COK and (NSDK  and M1K) not COK_ILP1K not COK_NTAPK not COK_PTAPK not COK_PSDK;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COK_NSDK  }, COK, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1K, NSDK  }, COK_NSDK , NONE }} );
NWRKT = NWRIT not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1K, NWRKT }, COK, NONE }} ); 
M2K = M2X not EMPTYI; 
VIA1K = VIA1I not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1K, M2K }, VIA1K, NONE }} ); 
M3K = M3X not EMPTYI; 
VIA2K = VIA2I not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2K, M3K }, VIA2K, NONE }} ); 
M4K = M4X not EMPTYI; 
VIA3K = VIA3I not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3K, M4K }, VIA3K, NONE }} ); 
M5K = M5X not EMPTYI; 
VIA4K = VIA4I not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4K, M5K }, VIA4K, NONE }} ); 
M6K = M6X not EMPTYI; 
CTM5K = CTM5I not EMPTYI; 
CMM5K = CMM5I not EMPTYI; 
VIA5K = VIA5I not EMPTYI; 
VIA5K_CTM5K = VIA5K and (CTM5K and M6K);
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5K_CTM5K }, VIA5K, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6K, CTM5K }, VIA5K_CTM5K, NONE }} );
VIA5K_CMM5K = VIA5K and (CMM5K and M6K) not VIA5K_CTM5K;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5K_CMM5K }, VIA5K, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6K, CMM5K }, VIA5K_CMM5K, NONE }} );
VIA5K_M5K  = VIA5K and (M5K  and M6K) not VIA5K_CTM5K not VIA5K_CMM5K;
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VIA5K_M5K  }, VIA5K, NONE }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6K, M5K  }, VIA5K_M5K , NONE }} );
MDK = MDX not EMPTYI; 
VIADK = VIADI not EMPTYI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6K, MDK }, VIADK, NONE }} ); 
CBK = CBI not EMPTYI; 

// Wire-Bond
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6K }, CBK }} ); 
UBMNK = UBMN not EMPTYI; 
CBDK = CBDI not EMPTYI; 

// Flip-chip
// 1_Ground up
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6K, UBMNK }, CBDK, NONE }} ); 
UBMDK = UBMD not EMPTYI; 

// 2_RDL (before passivation)
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MDK }, UBMDK }} ); 
PPIK = PPII not EMPTYI; 

// 3_PPI (After passivation)
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6K, PPIK }, CBDK, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PPIK }, UBMDK }} ); 
#ifdef DISCONNECT_ALL_RESISTOR 
   NTAPIU = NTAPK not EMPTYI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPIU }, NTAPK }} ); 
   PTAPIU = PTAPK not EMPTYI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPIU }, PTAPK }} ); 
   NSDIU = NSDK not EMPTYI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDIU }, NSDK }} ); 
   PSDIU = PSDK not EMPTYI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDIU }, PSDK }} ); 
   M1IU = M1K not EMPTYI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1IU }, M1K }} ); 
   COIU = COK not EMPTYI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COIU }, COK }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      NTAPIU = NTAPU not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPIU }, NTAPU }} ); 
      PTAPIU = PTAPU not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPIU }, PTAPU }} ); 
      NSDIU = NSDU not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDIU }, NSDU }} ); 
      PSDIU = PSDU not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDIU }, PSDU }} ); 
      M1IU = M1U not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1IU }, M1U }} ); 
      COIU = COU not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COIU }, COU }} ); 
   #else
      NTAPIU = NTAPJ not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPIU }, NTAPJ }} ); 
      PTAPIU = PTAPJ not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPIU }, PTAPJ }} ); 
      NSDIU = NSDJ not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDIU }, NSDJ }} ); 
      PSDIU = PSDJ not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDIU }, PSDJ }} ); 
      M1IU = M1J not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1IU }, M1J }} ); 
      COIU = COJ not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COIU }, COJ }} ); 
   #endif
#endif
CTM5 = CTM5I not EXCL_S; 
CMM5 = CMM5I not EXCL_S; 
#ifdef MIX_MODE 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWEL }, DNW }} ); 
   
   //Build connection for CTM.R.6
   //============================
   BULK2 = size( gCHIP, clip_acute = NONE, distance = 2.0 ); 
   EMPTY2I = gCHIP not BULK2; 
   M1M = EMPTY2I or M1I; 
   M2M = EMPTY2I or M2I; 
   VIA1M = EMPTY2I or VIA1I; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1M, M2M }, VIA1M, NONE }} ); 
   M3M = EMPTY2I or M3I; 
   VIA2M = EMPTY2I or VIA2I; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2M, M3M }, VIA2M, NONE }} ); 
   M4M = EMPTY2I or M4I; 
   VIA3M = EMPTY2I or VIA3I; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3M, M4M }, VIA3M, NONE }} ); 
   M5M = EMPTY2I or M5I; 
   VIA4M = EMPTY2I or VIA4I; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4M, M5M }, VIA4M, NONE }} ); 
   M6M = EMPTY2I or M6I; 
   VIA5M = EMPTY2I or VIA5I; 
   CTM5M = EMPTY2I or CTM5I; 
   CMM5M = EMPTY2I or CMM5I; 
   gLAYER_505 = not_interacting( VIA5M, CTM5M ); 
   VIATM = not_interacting( gLAYER_505, CMM5M ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M5M, M6M }, VIATM, NONE }} ); 
   VIACM = VIA5M and CTM5M; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6M }, VIACM }} ); 
   MDM = EMPTY2I or MDI; 
   VIADM = EMPTY2I or VIADI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6M, MDM }, VIADM, NONE }} ); 
   CBM = EMPTY2I or CBI; 
   
   // Wire-Bond
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6M }, CBM }} ); 
   UBMNM = EMPTY2I or UBMN; 
   CBDM = EMPTY2I or CBDI; 
   
   // Flip-chip
   // 1_Ground up
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6M, UBMNM }, CBDM, NONE }} ); 
   UBMDM = EMPTY2I or UBMD; 
   
   // 2_RDL (before passivation)
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MDM }, UBMDM }} ); 
   PPIM = EMPTY2I or PPII; 
   
   // 3_PPI (After passivation)
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6M, PPIM }, CBDM, NONE }} ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PPIM }, UBMDM }} ); 
   
   // MIMVIA CHECK
   //===============
   CTMV5 = VIA5 and CTM5;                /* VIA5 locate on CTM */ 
   
   // CTM CHECK
   //============
   TCTM = interacting( CTM5, VIA5 );     /* True CTM */ 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CTMV5 }, TCTM }} ); 
   gLAYER_504 = not_interacting( TCTM, CMM5 ); 
   BPM5 = size_inside_wrapper( gLAYER_504, M5, distance = 2, increment = 0.28 * 0.7 );     
   gLAYER_507 = VIA5 and BPM5; 
   gLAYER_506 = gLAYER_507 not CTM5; 
   CBMV5 = gLAYER_506 not CMM5;           /* VIA5 locate on CBMV */ 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBMV5 }, BPM5 }} ); 
   #ifndef C016 
      #ifndef C0152 
         BPM5_3D = size_inside_wrapper( CMM5, M5, distance = 2, increment = 0.28 * 0.7 );    /* CBM_3D = TCMM size 2 */ 
         gLAYER_525 = VIA5 and BPM5_3D; 
         gLAYER_524 = gLAYER_525 not CTM5; 
         CBMV5_3D = gLAYER_524 not CMM5; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBMV5_3D }, BPM5_3D }} ); 
      #endif
   #endif
#endif
CHIPX = level( gCHIP ); 

// MOM CHECKS
//===========
CHIP_MOM = copy( CHIPX ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CHIP_MOM }, CHIP_MOM }} ); 

// Front-End Layer
//----------------
ULLNW = ULLNWI not_inside EXCL; 
LVNW = NWELII not_inside EXCL; 
ODLL = ODLLI not_inside EXCL; 
VTMP = VTMPI not EXCL; 
VTMN = VTMNI not EXCL; 
OD2 = OD2I not EXCL; 
CO = COI not EXCL; 
M1_A = M1XD not_inside EXCL; 
VIAD = VIADI not_inside EXCL_S; 
MD = MDXD not_inside EXCL_S; 
CB = CBI not EXCL_S; 
CBD = CBDI not EXCL_S; 
NTN = NTNI not EXCL; 
PLMIDE = PLMIDEI not EXCL_S; 


FW = FWI not EXCL_S; 
LW = LWI not EXCL_S; 
HRI = HRII not EXCL; 
ESD = ESDI not EXCL_S; 
ESDIMP = ESDIMPI not EXCL_S; 
CTM2 = CTM2I not EXCL_S; 
CTM3 = CTM3I not EXCL_S; 
CTM4 = CTM4I not EXCL_S; 

// GLOBAL DERIVED LAYERS FOR RULE CHECKS 
//--------------------------------------
ALL_OD = ODI or DOD;                     /* For OD density check */ 
ALL_PO = POLYI or DPO;                   /* For POLY density check */ 
LVGT = ALL_GATE not OD2;                 /* 1.8V gate */ 
HVGT = ALL_GATE and OD2;                 /* 3.3V gate */ 
RNWEL = cutting( NWEL, RWDMY );          /* NWEL resistor (UNDER OD & STI) */ 
NONWR = NWEL not RNWEL;                  /* NWEL - NWR(OD) - NWR(STI) */ 
NTAP = NPOD and NONWR;                   /* NWEL Pick-Up */ 
PTAP = PPOD not NWEL;                    /* Substrate(PWEL) Pick-Up */ 
GATE_W = and_edge( POLY, OD, false );    /* Gate width */ 
GATE_L = and_edge( OD, POLY, false );    /* Channel length */ 
GATE_NP = ALL_GATE and gNP;               /* N+ Gate */ 
GATE_PP = ALL_GATE and PP;               /* P+ Gate */ 
ILP1 = POLY_ISO not RPO;                 /* Interconnection poly */ 
ODRES_ALL = interacting( FFOD, RPDUMMY ); 
DACT = NACT or PACT;                     /* NMOS and PMOS Device */ 
DSTP = NTAP or PTAP;                     /* NWEL and PWEL Pick-Up */ 
IMP = PP or gNP;                          /* N+ and P+ implant  */ 
HVN_GOX = NPOD and OD2;                  /* Device n-type diffusion for thick gate NMOS */ 
HVP_GOX = PPOD and OD2;                  /* Device p-type diffusion for thick gate PMOS */ 
HV_NGATE_W = and_edge( GATE_W, HVN_GOX, false );    /* 3.3V NMOS gate edges */ 
HV_PGATE_W = and_edge( GATE_W, HVP_GOX, false );    /* 3.3V PMOS gate edges */ 
BUTT_NTAP = outside_touching( NTAP, PACT );    /* NWEL Tap butting p-type active diffusion */ 
NONB_NTAP = not_outside_touching( NTAP, PACT );    /* Non-butting ntap */ 
BUTT_PTAP = outside_touching( PTAP, NACT );    /* PWEL Tap butting n-type active diffusion */ 
NONB_PTAP = not_outside_touching( PTAP, NACT );    /* Non-butting ptap  */ 
PP_BEDGE = BUTT_PTAP coincident_edge NACT;    /* PP edge to form butted tap */ 
NP_BEDGE = BUTT_NTAP coincident_edge PACT;    /* NP edge to form butted tap */ 
OD2_BEDGE = and_edge( OD2, OD, false ); 
ACT_OD = interacting( OD, POLY ); 
PNSD = ACT_OD not ALL_GATE; 
SDPO2 = interacting( PNSD, POLY, == 2 );    /* S/D between two Poly gate */ 
CO_DIFF = CO outside POLY_ISO;           /* Diffusion contacts + floating contacts */ 
CO_POLY = CO not_outside POLY_ISO;       /* POLY contacts */ 
ASD1 = enclosing( PNSD, CO_DIFF ); 

// For checks such as PP.C.4/C.5, NP.C.4/C.5.
gLAYER_14 = size( GATE_NP, clip_acute = NONE, distance = 0.03 ); 
gLAYER_13 = gLAYER_14 and POLY; 
EXGATE_NP = size( gLAYER_13, clip_acute = NONE, distance = NP_C_5 ); 
gLAYER_16 = size( GATE_PP, clip_acute = NONE, distance = 0.03 ); 
gLAYER_15 = gLAYER_16 and POLY; 
EXGATE_PP = size( gLAYER_15, clip_acute = NONE, distance = PP_C_5 ); 
gLAYER_17 = CB or FW; 
FUSE_LMARK = gLAYER_17 or LW; 
RNGX = PMDMY not FUSE_LMARK; 
#ifdef FULL_CHIP 
   CHIP_CORE = size( CHIPX, clip_acute = NONE, distance = - ( 10 + SR_S_1 ) );    /* sealring + assembly isolation */ 
#else /* the reverse of #ifdef FULL_CHIP  */ 
   CHIP_CORE = copy( CHIPX ); 
#endif /* end of #ifdef FULL_CHIP  */ 
gLAYER_18 = CB or CBD; 
PADH = donut_holes( gLAYER_18, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
SCORE = CHIP_CORE inside PADH; 
SR_CHIP = interacting( gCHIP, SCORE ); 
gLAYER_19 = size( SR_CHIP, clip_acute = NONE, distance = - 10 ); 
SR = SR_CHIP not gLAYER_19; 
SEALRING_ALL = SR or SEALRING; 
SR_CB = CB and SR; 
SR_CO = CO and SR; 
SR_VIA1 = VIA1 and SR; 
SR_VIA2 = VIA2 and SR; 
SR_VIA3 = VIA3 and SR; 
SR_VIA4 = VIA4 and SR; 
SR_VIA5 = VIA5 and SR; 
SR_M1 = M1 and SR; 
SR_M2 = M2 and SR; 
SR_M3 = M3 and SR; 
SR_M4 = M4 and SR; 
SR_M5 = M5 and SR; 
SR_M6 = M6 and SR; 

// For SEAL-RING and CHIP CORNER checks.
CHIP_WISR = interacting( CHIPX, SCORE ); 
SR_EDGE = CHIP_WISR not SCORE; 
CHIP_NOSR = not_interacting( CHIPX, SR_EDGE ); 
CHIP_NOSR1 = copy( CHIP_NOSR ); 
CHIP_NOSR2 = copy( CHIP_NOSR ); 
CHIP_NOSR3 = copy( CHIP_NOSR ); 
SR_EDGE1 = copy( SR_EDGE ); 
SR_EDGE2 = copy( SR_EDGE ); 
SR_EDGE3 = copy( SR_EDGE ); 
#ifdef FULL_CHIP 
   #ifdef BIGSEALRINGCORNER 
      
      // without seal-ring
      EMPTY_AREA = vertex( CHIP_NOSR1, angles = { 90 }, shape = TRIANGLE, shape_size = 350 ); 
      
      // with seal-ring
      SR_EXC = vertex( SR_EDGE1, angles = { 270 }, shape = TRIANGLE, shape_size = 350 ); 
   #else /* the reverse of #ifdef BIGSEALRINGCORNER  */ 
      #ifdef SMALLSEALRINGCORNER 
         
         // without seal-ring
         EMPTY_AREA = vertex( CHIP_NOSR2, angles = { 90 }, shape = TRIANGLE, shape_size = 125 ); 
         
         // with seal-ring
         SR_EXC = vertex( SR_EDGE2, angles = { 270 }, shape = TRIANGLE, shape_size = 125 ); 
      #else /* the reverse of #ifdef SMALLSEALRINGCORNER  */    /* not specify seal-ring structure, use BigSealringCorner */ 
         
         // without seal-ring
         EMPTY_AREA = vertex( CHIP_NOSR3, angles = { 90 }, shape = TRIANGLE, shape_size = 350 ); 
         
         // with seal-ring
         SR_EXC = vertex( SR_EDGE3, angles = { 270 }, shape = TRIANGLE, shape_size = 350 ); 
      #endif /* end of #ifdef SMALLSEALRINGCORNER  */ 
   #endif /* end of #ifdef BIGSEALRINGCORNER  */ 
   SRCSR = SR_EDGE or SR_EXC;            /* Sealring + Corner + Assembly isolation */ 
   gLAYER_20 = CHIPX not EMPTY_AREA; 
   CHIP_CHAMFERED = gLAYER_20 not SRCSR; 
   CHIP_EDGE = CHIPX not SR_EDGE; 
   gLAYER_21 = size( CHIP_EDGE, clip_acute = NONE, distance = SR_S_1 ); 
   ASS_REGION = gLAYER_21 not CHIP_EDGE; 
#endif /* end of #ifdef FULL_CHIP  */    /* FULL_CHIP */ 
SR_VIAD = VIAD and SR; 
gLAYER_22 = OD and SBDDMY; 
SBDOD = gLAYER_22 and NWEL; 
NW_SBD = interacting( NWEL, SBDOD ); 
DNW_SBD = interacting( DNW, SBDOD ); 
PP_SBD = interacting( PP, SBDOD ); 
PP_SBD_HOLE = donut_holes( PP_SBD, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
PP_SBD_ALL = PP_SBD or PP_SBD_HOLE; 
PP_NSBD = PP not PP_SBD; 
PPOD_SBD = interacting( SBDOD, PP ); 
NPOD_SBD = SBDOD and gNP; 
PPOD_SBD_GAP = edge_size( PPOD_SBD, outside = 0.48 ); 
PPOD_SBD_G = outside_touching( PPOD_SBD_GAP, NPOD_SBD ); 
NPOD_SBD_GAP = edge_size( NPOD_SBD, outside = 0.48 ); 
NPOD_SBD_G = outside_touching( NPOD_SBD_GAP, PPOD_SBD ); 
gLAYER_23 = PPOD_SBD or NPOD_SBD; 
SBDOD_ALL = gLAYER_23 or PPOD_SBD_G; 
PPOD_SBD_W = PPOD_SBD outside_touching_edge NPOD_SBD_G; 
PPOD_SBD_L = PPOD_SBD not_outside_touching_edge NPOD_SBD_G; 
NPOD_SBD_W = NPOD_SBD outside_touching_edge PPOD_SBD_G; 
rHRI_WARN @= { @ "HRI.WARN : RLPPDMY overlap OD is not allowed";
    RLPPDMY and OD; 
} /* end of rule : HRI.WARN */

//************************************************************************************* 
//
//  warning messages to check whether some switchs are used corretly or not. 
//
//*************************************************************************************
//======================================================================================
// Process selection warning.
//======================================================================================
#ifndef MIX_MODE 
   rWARN_PROCESS_1 @= { @ "WARN.PROCESS_1 : MIX_MODE switch should be turned on for Mixed Singal/RF process";
       sLAYER_4 = CTM5I or INDDMY; 
       sLAYER_3 = sLAYER_4 or HRII; 
       sLAYER_2 = sLAYER_3 or DNWI; 
       sLAYER_1 = sLAYER_2 or VTMPI; 
       MM_LAYERS = sLAYER_1 or VTMNI; 
       interacting( CHIPX, MM_LAYERS ); 
   } /* end of rule : WARN.PROCESS_1 */
#endif /* end of #ifndef MIX_MODE  */ 
#ifdef MIX_MODE 
   #ifndef _1_8V 
      rWARN_PROCESS_2 @= { @ "WARN.PROCESS_2 : Pls turn on (#define _1_8V) switch if you use Mixed Singal/RF process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_2 */
   #endif /* end of #ifndef _1_8V  */ 
   #ifndef _3_3V 
      rWARN_PROCESS_3 @= { @ "WARN.PROCESS_3 : Pls turn on (#define _3_3V) switch if you use Mixed Singal/RF process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_3 */
   #endif /* end of #ifndef _3_3V  */ 
   #ifdef LP 
      rWARN_PROCESS_4 @= { @ "WARN.PROCESS_4 : Pls turn off (#define LP) switch if you use Mixed Singal/RF process. "
                                              "Low power is not supported in Mixed Signal process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_4 */
   #endif /* end of #ifdef LP  */ 
   #ifdef _1_5V 
      rWARN_PROCESS_5 @= { @ "WARN.PROCESS_5 : Pls turn off (#define _1_5V) switch if you use Mixed Singal/RF process "
                                              "Low voltage is not supported in Mixed Signal process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_5 */
   #endif /* end of #ifdef _1_5V  */ 
   #ifdef _5V 
      rWARN_PROCESS_6 @= { @ "WARN.PROCESS_6 : Pls turn off (#define _5V) switch if you use Mixed Singal/RF process "
                                              "1.8V/5V is not supported in Mixed Signal process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_6 */
   #endif /* end of #ifdef _5V  */ 
#endif /* end of #ifdef MIX_MODE  */ 
#ifdef C016 
   #ifdef _5V 
      rWARN_PROCESS_7 @= { @ "WARN.PROCESS_7 : Pls turn off (#define _5V) switch if you use 0.16um process "
                                              "1.8V/5V is not supported in 0.16um process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_7 */
   #endif /* end of #ifdef _5V  */ 
   #ifdef _1_5V 
      rWARN_PROCESS_8 @= { @ "WARN.PROCESS_8 : Pls turn off (#define _1_5V) switch if you use 0.16um process "
                                              "Low voltage is not supported in 0.16um process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_8 */
   #endif /* end of #ifdef _1_5V  */ 
   #ifdef LP 
      rWARN_PROCESS_9 @= { @ "WARN.PROCESS_9 : Pls turn off (#define LP) switch if you use 0.16um process "
                                              "Low power is not supported in 0.16um process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_9 */
   #endif /* end of #ifdef LP  */ 
#endif /* end of #ifdef C016  */ 
#ifdef C016 
   #ifdef C0152 
      rWARN_PROCESS_10 @= { @ "WARN.PROCESS_10 : (#define C016 & #define C0152) switch can't be turned on together";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_10 */
   #endif /* end of #ifdef C0152  */ 
#endif /* end of #ifdef C016  */ 
#ifdef C0152 
   #ifdef _5V 
      rWARN_PROCESS_11 @= { @ "WARN.PROCESS_11 : Pls turn off (#define _5V) switch if you use 0.152um process "
                                                "1.8V/5V is not supported in 0.152um process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_11 */
   #endif /* end of #ifdef _5V  */ 
   #ifdef _1_5V 
      rWARN_PROCESS_12 @= { @ "WARN.PROCESS_12 : Pls turn off (#define _1_5V) switch if you use 0.152um process "
                                                "Low voltage is not supported in 0.152um process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_12 */
   #endif /* end of #ifdef _1_5V  */ 
   #ifdef LP 
      rWARN_PROCESS_13 @= { @ "WARN.PROCESS_13 : Pls turn off (#define LP) switch if you use 0.152um process "
                                                "Low power is not supported in 0.152um process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_13 */
   #endif /* end of #ifdef LP  */ 
#endif /* end of #ifdef C0152  */ 
#ifdef LP 
   #ifdef _1_5V 
      rWARN_PROCESS_14 @= { @ "WARN.PROCESS_14 : Pls turn off (#define _1_5V) switch if you use 0.18um Low power process";
          copy( CHIPX ); 
      } /* end of rule : WARN.PROCESS_14 */
   #endif /* end of #ifdef _1_5V  */ 
#endif /* end of #ifdef LP  */ 

//======================================================================================
// Voltage selection warning.
//======================================================================================
#ifndef _3_3V 
   #ifndef _2_5V 
      #ifndef _5V 
         rWARN_VOLTAGE_1 @= { @ "WARN.VOLTAGE_1 : There must be specified an option of HIGH_VOLTAGE";
             copy( CHIPX ); 
         } /* end of rule : WARN.VOLTAGE_1 */
      #endif /* end of #ifndef _5V  */ 
   #endif /* end of #ifndef _2_5V  */ 
#endif /* end of #ifndef _3_3V  */ 
#ifndef _1_8V 
   #ifndef _1_5V 
      rWARN_VOLTAGE_2 @= { @ "WARN.VOLTAGE_2 : There must be specified an option of CORE_VOLTAGE";
          copy( CHIPX ); 
      } /* end of rule : WARN.VOLTAGE_2 */
   #endif /* end of #ifndef _1_5V  */ 
#endif /* end of #ifndef _1_8V  */ 
#ifdef _3_3V 
   #ifdef _2_5V 
      rWARN_VOLTAGE_3 @= { @ "WARN.VOLTAGE_3 : Only one HIGH_VOLTAGE can be specified every time.";
          copy( CHIPX ); 
      } /* end of rule : WARN.VOLTAGE_3 */
   #endif /* end of #ifdef _2_5V  */ 
   #ifdef _5V 
      rWARN_VOLTAGE_4 @= { @ "WARN.VOLTAGE_4 : Only one HIGH_VOLTAGE can be specified every time.";
          copy( CHIPX ); 
      } /* end of rule : WARN.VOLTAGE_4 */
   #endif /* end of #ifdef _5V  */ 
#endif /* end of #ifdef _3_3V  */ 
#ifdef _1_8V 
   #ifdef _1_5V 
      rWARN_VOLTAGE_5 @= { @ "WARN.VOLTAGE_5 : Only one CORE_VOLTAGE can be specified every time.";
          copy( CHIPX ); 
      } /* end of rule : WARN.VOLTAGE_5 */
   #endif /* end of #ifdef _1_5V  */ 
#endif /* end of #ifdef _1_8V  */ 
#ifdef _1_8V 
   #ifdef _2_5V 
      rWARN_VOLTAGE_6 @= { @ "WARN.VOLTAGE_6 : 1.8V and 2.5V can not be specified at the same time.";
          copy( CHIPX ); 
      } /* end of rule : WARN.VOLTAGE_6 */
   #endif /* end of #ifdef _2_5V  */ 
#endif /* end of #ifdef _1_8V  */ 
#ifdef _1_5V 
   #ifdef _5V 
      rWARN_VOLTAGE_7 @= { @ "WARN.VOLTAGE_7 : 1.5V and 5V can not be specified at the same time.";
          copy( CHIPX ); 
      } /* end of rule : WARN.VOLTAGE_7 */
   #endif /* end of #ifdef _5V  */ 
#endif /* end of #ifdef _1_5V  */ 

//======================================================================================
// Thick top metal selection warning
//======================================================================================
#ifndef MIX_MODE 
   #ifdef THICK_40K 
      rWARN_THICK_TOP_METAL_1 @= { @ "WARN.THICK_TOP_METAL_1 : 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, "
                                                              "Other processes are not provided in this design rule.";
          copy( CHIPX ); 
      } /* end of rule : WARN.THICK_TOP_METAL_1 */
   #endif /* end of #ifdef THICK_40K  */ 
   #ifdef THICK_20K 
      rWARN_THICK_TOP_METAL_2 @= { @ "WARN.THICK_TOP_METAL_2 : 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, "
                                                              "Other processes are not provided in this design rule.";
          copy( CHIPX ); 
      } /* end of rule : WARN.THICK_TOP_METAL_2 */
   #endif /* end of #ifdef THICK_20K  */ 
#endif /* end of #ifndef MIX_MODE  */ 
#ifdef C016 
   #ifdef THICK_40K 
      rWARN_THICK_TOP_METAL_3 @= { @ "WARN.THICK_TOP_METAL_3 : 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, "
                                                              "Other processes are not provided in this design rule.";
          copy( CHIPX ); 
      } /* end of rule : WARN.THICK_TOP_METAL_3 */
   #endif /* end of #ifdef THICK_40K  */ 
#endif /* end of #ifdef C016  */ 
#ifdef C0152 
   #ifdef THICK_40K 
      rWARN_THICK_TOP_METAL_4 @= { @ "WARN.THICK_TOP_METAL_4 : 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, "
                                                              "Other processes are not provided in this design rule.";
          copy( CHIPX ); 
      } /* end of rule : WARN.THICK_TOP_METAL_4 */
   #endif /* end of #ifdef THICK_40K  */ 
   #ifdef THICK_20K 
      rWARN_THICK_TOP_METAL_5 @= { @ "WARN.THICK_TOP_METAL_5 : 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, "
                                                              "Other processes are not provided in this design rule.";
          copy( CHIPX ); 
      } /* end of rule : WARN.THICK_TOP_METAL_5 */
   #endif /* end of #ifdef THICK_20K  */ 
#endif /* end of #ifdef C0152  */ 
#ifdef THICK_40K 
   #ifdef THICK_20K 
      rWARN_THICK_TOP_METAL_6 @= { @ "WARN.THICK_TOP_METAL_6 : 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, "
                                                              "and 20KA and 40KA should not be placed in the same chip.";
          copy( CHIPX ); 
      } /* end of rule : WARN.THICK_TOP_METAL_6 */
   #endif /* end of #ifdef THICK_20K  */ 
#endif /* end of #ifdef THICK_40K  */ 
#ifdef C016 
   #ifdef CHECK_ALRDL 
      rWARN_THICK_TOP_METAL_7 @= { @ "WARN.THICK_TOP_METAL_7 : AL RDL is not support in 0.16um process";
          copy( CHIPX ); 
      } /* end of rule : WARN.THICK_TOP_METAL_7 */
   #endif /* end of #ifdef CHECK_ALRDL  */ 
#endif /* end of #ifdef C016  */ 

//======================================================================================
// DNW warning
//======================================================================================
#ifndef MIX_MODE 
   rWARN_DNW @= { @ "WARN.DNW : DNW only provide for MM/RF process";
       copy( DNWI ); 
   } /* end of rule : WARN.DNW */
#endif /* end of #ifndef MIX_MODE  */ 

//======================================================================================
// NTN warning
//======================================================================================
#ifdef _5V 
   rWARN_NTN_1 @= { @ "WARN.NTN_1 : NTN devices don't provide for 0.18um 1.8V/5V General purpose,Low Power and "
                                   "1.8V/3.3V Low Power process";
       copy( NTNI ); 
   } /* end of rule : WARN.NTN_1 */
#endif /* end of #ifdef _5V  */ 
#ifdef LP 
   #ifdef _3_3V 
      rWARN_NTN_2 @= { @ "WARN.NTN_2 : NTN devices don't provide for 0.18um 1.8V/5V General purpose,Low Power and "
                                      "1.8V/3.3V Low Power process";
          copy( NTNI ); 
      } /* end of rule : WARN.NTN_2 */
   #endif /* end of #ifdef _3_3V  */ 
#endif /* end of #ifdef LP  */ 

// NWEL CHECKS
//=============
gLAYER_24 = NWEL and HOTWL; 
HOT_NWEL = gLAYER_24 or RNWEL; 
NW_5V = NWEL not_outside OD2; 
NW_1_8V = NWEL outside OD2; 
rNW_W_1 @= { @ "NW.W.1 : Min. NWEL width < 0.86";
    internal1( NWEL, < 0.86, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : NW.W.1 */
rNW_W_2 @= { @ "NW.W.2 : Min. HOT_NWEL width < 2.10";
    internal1( HOT_NWEL, < 2.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : NW.W.2 */
rNW_S_1 @= { @ "NW.S.1 : Min. different potential NWEL space < 1.40";
    NWEL_NODAL = stamp( NWEL, NWELI, CONNECT_DB, CONNECT_DB_NW_S_1, include_touch = NONE ); 
    external1( NWEL_NODAL, < 1.4, connect_sequence = CONNECT_DB_NW_S_1, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
    external2( RNWEL, NWEL, < 1.4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    external1( RNWEL, < 1.4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : NW.S.1 */
rNW_S_2 @= { @ "NW.S.2 : Min. same potential NWEL space < 0.6";
    external1( NWEL, < 0.6, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : NW.S.2 */
#ifdef _5V 
   rNW_S_3 @= { @ "NW.S.3 : Min. space between 1.8V & 5V NW < " + NW_S_3; 
       NW_1_8V_NODAL = stamp( NW_1_8V, NWELI, CONNECT_DB, CONNECT_DB_NW_S_3, include_touch = NONE ); 
       NW_5V_NODAL = stamp( NW_5V, NWELI, CONNECT_DB_NW_S_3, CONNECT_DB_NW_S_3, include_touch = NONE ); 
       external2( NW_5V_NODAL, NW_1_8V_NODAL, < NW_S_3, connect_sequence = CONNECT_DB_NW_S_3, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : NW.S.3 */
   rNW_S_4 @= { @ "NW.S.4 : Min. space between 5V NW with different potential, except two NW region fully covered with OD2 < " + NW_S_4; 
       NW2V = NW_5V not OD2; 
       NW3V = NW_5V and OD2; 
       NW2V_NODAL = stamp( NW2V, NWELI, CONNECT_DB, CONNECT_DB_NW_S_4, include_touch = NONE ); 
       NW3V_NODAL = stamp( NW3V, NWELI, CONNECT_DB_NW_S_4, CONNECT_DB_NW_S_4, include_touch = NONE ); 
       external1( NW2V_NODAL, < NW_S_4, connect_sequence = CONNECT_DB_NW_S_4, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
       external2( NW2V_NODAL, NW3V_NODAL, < NW_S_4, connect_sequence = CONNECT_DB_NW_S_4, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : NW.S.4 */
#endif /* end of #ifdef _5V  */ 

//NW.S.5 is checked by other rule.
#ifdef RECOMMEND 
   rNW_R_1 @= { @ "NW.R.1 : Recommended not to use floating well";
       sLAYER_7 = interacting( NPODI, COI ); 
       sLAYER_6 = NWELI outside sLAYER_7; 
       sLAYER_5 = sLAYER_6 not LOGO; 
       X1 = sLAYER_5 not_inside EXCL; 
       sLAYER_10 = ODI not RPOI; 
       sLAYER_9 = interacting( sLAYER_10, NPODI ); 
       sLAYER_8 = sLAYER_9 and NWELI; 
       X2 = interacting( sLAYER_8, COI ); 
       X1 outside X2; 
       sLAYER_12 = interacting( PPODI, COI ); 
       sLAYER_11 = PWELI outside sLAYER_12; 
       Y1 = sLAYER_11 not_inside EXCL; 
       sLAYER_15 = ODI not RPOI; 
       sLAYER_14 = interacting( sLAYER_15, PPODI ); 
       sLAYER_13 = sLAYER_14 not NWELI; 
       Y2 = interacting( sLAYER_13, COI ); 
       Y1 outside Y2; 
   } /* end of rule : NW.R.1 */
#endif /* end of #ifdef RECOMMEND  */ 

// NWEL (within OD) RESISTOR CHECKS
//====================================
NWRES = interacting( RNWEL, RPO );       /* NWEL resistor (UNDER OD) */ 
ODWR = interacting( OD, NWRES );         /* OD area of NW resistor */ 
NPWR = interacting( gNP, NWRES );         /* N+ implant on NW resistor terminals */ 
COWR = interacting( CO_DIFF, NWRES );    /* Contact on NW resistor terminals */ 
RHWR = ODWR not RPO;                     /* Non-Salicided area of NW resistor */ 
RPONWR_H = donut_holes( RPO, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
rNWR_E_1 @= { @ "NWR.E.1 : Min. OD enclose NWEL resistor < 1.0";
    enclose( NWRES, ODWR, < 1.0, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    cutting( NWRES, ODWR ); 
} /* end of rule : NWR.E.1 */
rNWR_E_2 @= { @ "NWR.E.2 : Min. NWEL resistor enclose CO < 0.3";
    enclose( COWR, NWRES, < 0.3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    cutting( COWR, NWRES ); 
} /* end of rule : NWR.E.2 */
rNWR_C_1 @= { @ "NWR.C.1 : Min. RPO hole enclose NWEL < 0.3";
    enclose( NWRES, RHWR, < 0.3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : NWR.C.1 */
rNWR_C_2 @= { @ "NWR.C.2 : Min. RPO enclose OD (with NWEL resistor) < 0.22";
    enclose( ODWR, RPO, < 0.22, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : NWR.C.2 */
rNWR_C_3 @= { @ "NWR.C.3 : Min. RPO hole enclose NWEL resistor CO < 0.3";
    enclose( COWR, RHWR, < 0.3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    cutting( COWR, RHWR ); 
} /* end of rule : NWR.C.3 */
rNWR_O_1 @= { @ "NWR.O.1 : Min. RPO overlap NP < 0.4";
    internal2( NPWR, RPO, < 0.4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    X = interacting( RPO, NWRES ); 
    H = donut_holes( X, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
    H not NPWR; 
} /* end of rule : NWR.O.1 */
rNWR_R_1 @= { @ "NWR.R.1 : NW resistor doped by implants not allowed.";
    RWDMY and NPOD; 
    RWDMY and PPOD; 
} /* end of rule : NWR.R.1 */
NWT = interacting( NTAPU, NWRES ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWT }, NTAPU }} ); 
VDD_VSS_DUMMY = VDDDMY or VSSDMY; 
NWT_CB_DUMMY = interacting( CBU, VDD_VSS_DUMMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWT_CB_DUMMY }, CBU }} ); 
NWT_UBMN_DUMMY = interacting( UBMNU, VDD_VSS_DUMMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWT_UBMN_DUMMY }, UBMNU }} ); 
NWT_UBMD_DUMMY = interacting( UBMDU, VDD_VSS_DUMMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWT_UBMD_DUMMY }, UBMDU }} ); 
gLAYER_526 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M1U_BY_TEXT = M1U interacting gLAYER_526; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M1U_BY_TEXT }, M1U }} ); 
gLAYER_527 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M1U_BY_TEXT = M1U interacting gLAYER_527; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M1U_BY_TEXT }, M1U }} ); 
gLAYER_528 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M1U_BY_TEXT = M1U interacting gLAYER_528; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M1U_BY_TEXT }, M1U }} ); 
gLAYER_529 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M1K_BY_TEXT = M1K interacting gLAYER_529; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M1K_BY_TEXT }, M1K }} ); 
gLAYER_530 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M1K_BY_TEXT = M1K interacting gLAYER_530; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M1K_BY_TEXT }, M1K }} ); 
gLAYER_531 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M1K_BY_TEXT = M1K interacting gLAYER_531; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M1K_BY_TEXT }, M1K }} ); 
gLAYER_25 = PAD_M1K_BY_TEXT not PWR_M1K_BY_TEXT; 
IO_PAD_M1K_BY_TEXT = gLAYER_25 not GND_M1K_BY_TEXT; 
gLAYER_532 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M2U_BY_TEXT = M2U interacting gLAYER_532; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M2U_BY_TEXT }, M2U }} ); 
gLAYER_533 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M2U_BY_TEXT = M2U interacting gLAYER_533; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M2U_BY_TEXT }, M2U }} ); 
gLAYER_534 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M2U_BY_TEXT = M2U interacting gLAYER_534; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M2U_BY_TEXT }, M2U }} ); 
gLAYER_535 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M2K_BY_TEXT = M2K interacting gLAYER_535; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M2K_BY_TEXT }, M2K }} ); 
gLAYER_536 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M2K_BY_TEXT = M2K interacting gLAYER_536; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M2K_BY_TEXT }, M2K }} ); 
gLAYER_537 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M2K_BY_TEXT = M2K interacting gLAYER_537; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M2K_BY_TEXT }, M2K }} ); 
gLAYER_26 = PAD_M2K_BY_TEXT not PWR_M2K_BY_TEXT; 
IO_PAD_M2K_BY_TEXT = gLAYER_26 not GND_M2K_BY_TEXT; 
gLAYER_538 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M3U_BY_TEXT = M3U interacting gLAYER_538; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M3U_BY_TEXT }, M3U }} ); 
gLAYER_539 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M3U_BY_TEXT = M3U interacting gLAYER_539; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M3U_BY_TEXT }, M3U }} ); 
gLAYER_540 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M3U_BY_TEXT = M3U interacting gLAYER_540; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M3U_BY_TEXT }, M3U }} ); 
gLAYER_541 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M3K_BY_TEXT = M3K interacting gLAYER_541; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M3K_BY_TEXT }, M3K }} ); 
gLAYER_542 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M3K_BY_TEXT = M3K interacting gLAYER_542; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M3K_BY_TEXT }, M3K }} ); 
gLAYER_543 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M3K_BY_TEXT = M3K interacting gLAYER_543; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M3K_BY_TEXT }, M3K }} ); 
gLAYER_27 = PAD_M3K_BY_TEXT not PWR_M3K_BY_TEXT; 
IO_PAD_M3K_BY_TEXT = gLAYER_27 not GND_M3K_BY_TEXT; 
gLAYER_544 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M4U_BY_TEXT = M4U interacting gLAYER_544; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M4U_BY_TEXT }, M4U }} ); 
gLAYER_545 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M4U_BY_TEXT = M4U interacting gLAYER_545; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M4U_BY_TEXT }, M4U }} ); 
gLAYER_546 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M4U_BY_TEXT = M4U interacting gLAYER_546; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M4U_BY_TEXT }, M4U }} ); 
gLAYER_547 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M4K_BY_TEXT = M4K interacting gLAYER_547; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M4K_BY_TEXT }, M4K }} ); 
gLAYER_548 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M4K_BY_TEXT = M4K interacting gLAYER_548; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M4K_BY_TEXT }, M4K }} ); 
gLAYER_549 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M4K_BY_TEXT = M4K interacting gLAYER_549; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M4K_BY_TEXT }, M4K }} ); 
gLAYER_28 = PAD_M4K_BY_TEXT not PWR_M4K_BY_TEXT; 
IO_PAD_M4K_BY_TEXT = gLAYER_28 not GND_M4K_BY_TEXT; 
gLAYER_550 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M5U_BY_TEXT = M5U interacting gLAYER_550; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M5U_BY_TEXT }, M5U }} ); 
gLAYER_551 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M5U_BY_TEXT = M5U interacting gLAYER_551; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M5U_BY_TEXT }, M5U }} ); 
gLAYER_552 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M5U_BY_TEXT = M5U interacting gLAYER_552; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M5U_BY_TEXT }, M5U }} ); 
gLAYER_553 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M5K_BY_TEXT = M5K interacting gLAYER_553; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M5K_BY_TEXT }, M5K }} ); 
gLAYER_554 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M5K_BY_TEXT = M5K interacting gLAYER_554; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M5K_BY_TEXT }, M5K }} ); 
gLAYER_555 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M5K_BY_TEXT = M5K interacting gLAYER_555; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M5K_BY_TEXT }, M5K }} ); 
gLAYER_29 = PAD_M5K_BY_TEXT not PWR_M5K_BY_TEXT; 
IO_PAD_M5K_BY_TEXT = gLAYER_29 not GND_M5K_BY_TEXT; 
gLAYER_556 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M6U_BY_TEXT = M6U interacting gLAYER_556; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M6U_BY_TEXT }, M6U }} ); 
gLAYER_557 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M6U_BY_TEXT = M6U interacting gLAYER_557; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M6U_BY_TEXT }, M6U }} ); 
gLAYER_558 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M6U_BY_TEXT = M6U interacting gLAYER_558; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M6U_BY_TEXT }, M6U }} ); 
gLAYER_559 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_M6K_BY_TEXT = M6K interacting gLAYER_559; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M6K_BY_TEXT }, M6K }} ); 
gLAYER_560 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_M6K_BY_TEXT = M6K interacting gLAYER_560; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M6K_BY_TEXT }, M6K }} ); 
gLAYER_561 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_M6K_BY_TEXT = M6K interacting gLAYER_561; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M6K_BY_TEXT }, M6K }} ); 
gLAYER_30 = PAD_M6K_BY_TEXT not PWR_M6K_BY_TEXT; 
IO_PAD_M6K_BY_TEXT = gLAYER_30 not GND_M6K_BY_TEXT; 
gLAYER_562 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_MDU_BY_TEXT = MDU interacting gLAYER_562; 
gLAYER_563 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_MDU_BY_TEXT = MDU interacting gLAYER_563; 
gLAYER_564 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_MDU_BY_TEXT = MDU interacting gLAYER_564; 
gLAYER_565 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
PWR_MDK_BY_TEXT = MDK interacting gLAYER_565; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_MDK_BY_TEXT }, MDK }} ); 
gLAYER_566 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
GND_MDK_BY_TEXT = MDK interacting gLAYER_566; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_MDK_BY_TEXT }, MDK }} ); 
gLAYER_567 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
PAD_MDK_BY_TEXT = MDK interacting gLAYER_567; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_MDK_BY_TEXT }, MDK }} ); 
NWT_IOPAD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => NWT, "layer2" => CBU, "layer3" => UBMNU, "layer4" => UBMDU }, 4, 4, {  }, NAR_SAVE_NET_1, false ); 
NWT_VDD_VSS_PAD_DUMMY = net_select( CONNECT_DB, connected_to_any = { NWT_CB_DUMMY, NWT_UBMN_DUMMY, NWT_UBMD_DUMMY }, output_from_layers = { NWT } ); 
NWT_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PAD_M1U_BY_TEXT, PAD_M2U_BY_TEXT, PAD_M3U_BY_TEXT, PAD_M4U_BY_TEXT, PAD_M5U_BY_TEXT, PAD_M6U_BY_TEXT }, output_from_layers = { NWT } ); 
NWT_VDD_VSS_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PWR_M1U_BY_TEXT, PWR_M2U_BY_TEXT, PWR_M3U_BY_TEXT, PWR_M4U_BY_TEXT, PWR_M5U_BY_TEXT, PWR_M6U_BY_TEXT, GND_M1U_BY_TEXT, GND_M2U_BY_TEXT, GND_M3U_BY_TEXT, GND_M4U_BY_TEXT, GND_M5U_BY_TEXT, GND_M6U_BY_TEXT }, output_from_layers = { NWT } ); 
#ifdef CHECK_LATCHUP_BY_TEXT 
   gLAYER_31 = NWT_VDD_VSS_PAD_TEXT or NWT_VDD_VSS_PAD_DUMMY; 
   NWT_IO = NWT_IOPAD not gLAYER_31; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWT_IO }, NWT }} ); 
   gLAYER_32 = NWT_VDD_VSS_PAD_TEXT or NWT_VDD_VSS_PAD_DUMMY; 
   NWT_IO_TEXT = NWT_PAD_TEXT not gLAYER_32; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWT_IO_TEXT }, NWT }} ); 
#else /* the reverse of #ifdef CHECK_LATCHUP_BY_TEXT  */ 
   NWT_IO = NWT_IOPAD not NWT_VDD_VSS_PAD_DUMMY;
CONNECT_DB=incremental_connect(CONNECT_DB,{{{NWT_IO},NWT}});
 
#endif /* end of #ifdef CHECK_LATCHUP_BY_TEXT  */ 
#ifdef RECOMMEND 
   rNWR_R_7 @= { @ "NWR.R.7 : Its recommended not to connect any terminal of NWROD(N-well under OD resistor) to IO voltage for the leakage current concern.";
       NTAP_OD2 = NTAPU and OD2; 
       CONNECT_DB_NWR_R_7 = incremental_connect( CONNECT_DB, {{{ NTAP_OD2 }, NTAPU }} ); 
       PTAP_OD2 = PTAPU and OD2; 
       CONNECT_DB_NWR_R_7 = incremental_connect( CONNECT_DB_NWR_R_7, {{{ PTAP_OD2 }, PTAPU }} ); 
       NSD_OD2 = NSDU and OD2; 
       CONNECT_DB_NWR_R_7 = incremental_connect( CONNECT_DB_NWR_R_7, {{{ NSD_OD2 }, NSDU }} ); 
       PSD_OD2 = PSDU and OD2; 
       CONNECT_DB_NWR_R_7 = incremental_connect( CONNECT_DB_NWR_R_7, {{{ PSD_OD2 }, PSDU }} ); 
       ILP1_OD2 = ILP1U and OD2; 
       CONNECT_DB_NWR_R_7 = incremental_connect( CONNECT_DB_NWR_R_7, {{{ ILP1_OD2 }, ILP1U }} ); 
   #ifdef CHECK_LATCHUP_BY_TEXT 
          net_area_ratio( CONNECT_DB_NWR_R_7, > 0, { "layer1" => NWT, "layer2" => NTAP_OD2, "layer3" => PTAP_OD2, "layer4" => NSD_OD2, "layer5" => PSD_OD2, "layer6" => ILP1_OD2, "layer7" => NWT_IO, "layer8" => NWT_IO_TEXT }, 8, 8, {  }, NAR_SAVE_NET_2, false ); 
   #else /* the reverse of #ifdef CHECK_LATCHUP_BY_TEXT  */ 
          net_area_ratio( CONNECT_DB_NWR_R_7, > 0, { "layer1" => NWT, "layer2" => NTAP_OD2, "layer3" => PTAP_OD2, "layer4" => NSD_OD2, "layer5" => PSD_OD2, "layer6" => ILP1_OD2, "layer7" => NWT_IO }, 7, 7, {  }, NAR_SAVE_NET_3, false ); 
   #endif /* end of #ifdef CHECK_LATCHUP_BY_TEXT  */ 
   } /* end of rule : NWR.R.7 */
#endif /* end of #ifdef RECOMMEND  */ 
rNWR_R_3 @= { @ "NWR.R.3 : Only one NW inside NWROD is allowed in one OD.";
    sLAYER_16 = NWRES and ODWR; 
    A = interacting( ODWR, sLAYER_16, > 1 ); 
    interacting( NWRES, A ); 
} /* end of rule : NWR.R.3 */
rNWR_R_4 @= { @ "NWR.R.4 : Only two NPS in NWROD is allowed in one od.";
    sLAYER_17 = interacting( gNP, NWRES ); 
    C = interacting( ODWR, sLAYER_17, != 2 ); 
    interacting( gNP, C ); 
    sLAYER_18 = interacting( gNP, NWRES ); 
    not_interacting( ODWR, sLAYER_18 ); 
} /* end of rule : NWR.R.4 */
rNWR_R_5 @= { @ "NWR.R.5 : ONLY TWO RPO HOLES IN NWROD ARE ALLOWED.";
    A = interacting( ODWR, RPONWR_H, != 2 ); 
    D = not_interacting( ODWR, RPONWR_H ); 
    sLAYER_19 = A or D; 
    interacting( RPONWR_H, sLAYER_19 ); 
} /* end of rule : NWR.R.5 */
rNWR_R_6 @= { @ "NWR.R.6 : For U-shape or S-shape NWROD, both OD and NW must be U-shape or S-shape and the OD edge must be "
                          "parallel to the NW edge. DRC can only flag the pattern without OD space while 2 edges of NW "
                          "[NW space or notch <= 5 um] parallel length > 0 um";
    sLAYER_20 = external1( NWRES, < 5, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    A = sLAYER_20 not NWRES; 
    A inside ODWR; 
} /* end of rule : NWR.R.6 */

//NWEL under STI
NWRES_STI = not_interacting( RNWEL, RPO );    /* NWEL resistor (UNDER STI) */ 
ODWR_STI = interacting( OD, NWRES_STI ); 
NPWR_STI = interacting( gNP, NWRES_STI ); 
rNWR_E_3 @= { @ "NWR.E.3 : Min. extension of NP to OD (NWEL resistor under STI) 0.18 um";
    enclose( ODWR_STI, NPWR_STI, < 0.18, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    ODWR_STI not NPWR_STI; 
} /* end of rule : NWR.E.3 */
#ifdef C0152 
   
   // ULLNW CHECKS
   //============
   // ULLNW.W.1 is checked by NW.W.1
   // ULLNW.W.2 is checked by NW.W.2
   // ULLNW.S.1 is checked by NW.S.1
   // ULLNW.S.2 is checked by NW.S.2
   // ULLNW.S.3 is checked by NW.S.1
   // ULLNW.S.4 is checked by NW.S.2
#endif /* end of #ifdef C0152  */ 
#ifndef _5V 
   
   // NT_N
   //======
   NTN_OD = OD not_outside NTN; 
   NTN_PO = POLY and NTN; 
   NTN_GATE = NTN_PO and NTN_OD; 
   NTN_GATE_W = and_edge( NTN_PO, NTN_OD, false ); 
   NTN_GATE_L = and_edge( NTN_OD, NTN_PO, false ); 
   gLAYER_34 = CO or OD; 
   gLAYER_33 = interacting( NTN_PO, gLAYER_34 ); 
   NTN_PO_W = gLAYER_33 coincident_inside_edge POLY; 
   rNT_N_I_1 @= { @ "NT_N.I.1 : NT_N interact DNW is not allowed. (Butted is allowed)";
       NTN and DNW; 
   } /* end of rule : NT_N.I.1 */
   rNT_N_I_2 @= { @ "NT_N.I.2 : only one OD region allowed to be put in an NT_N region";
       enclosing( NTN, OD, > 1 ); 
   } /* end of rule : NT_N.I.2 */
   rNT_N_I_3 @= { @ "NT_N.I.3 : A P+GATE is not allowed to be put in an NT_N region";
       NTN and GATE_PP; 
   } /* end of rule : NT_N.I.3 */
   rNT_N_I_4 @= { @ "NT_N.I.4 : A bent poly region is not allowed to put in an NT_N region";
       external1_error( NTN_PO_W, < 0.18, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ); 
       internal1_error( NTN_PO_W, < 0.18, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } ); 
       vertex_edge( NTN_PO_W, angles = { 225 }, shape_size = 0.18 ); 
       vertex_edge( NTN_PO_W, angles = { 135 }, shape_size = 0.18 ); 
   } /* end of rule : NT_N.I.4 */
   rNT_N_W_1 @= { @ "NT_N.W.1 : For CL018LV 1.5V/2.5V, CL018G 1.8V/3.3V minimum dimension of a NT_N region < " + NT_N_W_1; 
       internal1( NTN, < NT_N_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
   } /* end of rule : NT_N.W.1 */
   #ifdef _1_5V 
      #ifdef _3_3V 
         rNT_N_W_1_1_5_3_3V @= { @ "NT_N.W.1_1.5_3.3V : For CL018LV 1.5V/3.3V, minimum dimension of a NT_N region.<0.86";
             internal1( NTN, < 0.86, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : NT_N.W.1_1.5_3.3V */
      #endif /* end of #ifdef _3_3V  */ 
   #endif /* end of #ifdef _1_5V  */ 
   #ifdef _1_8V 
      #ifdef C016 
         rNTN_W_2 @= { @ "NTN.W.2 : Minimum poly gate dimension(channel length) of a 1.8V blocked NT_N device < 0.55";
             internal1( NTN_GATE_W, < 0.55, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
         } /* end of rule : NTN.W.2 */
      #endif /* end of #ifdef C016  */ 
      #ifndef C016 
         rNT_N_W_2_LV @= { @ "NT_N.W.2_LV : Minimum Poly gate dimension of a 1.8V blocked NT_N device < 0.5";
             internal1( NTN_GATE_W, < 0.5, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
         } /* end of rule : NT_N.W.2_LV */
      #endif /* end of #ifndef C016  */ 
   #endif /* end of #ifdef _1_8V  */ 
   #ifdef _1_5V 
      rNT_N_W_2_LV @= { @ "NT_N.W.2.LV : For CL018LV 1.5/2.5V & 1.5/3.3V, minimum Poly gate dimension of a 1.5V blocked NT_N device < 0.37";
          internal1( NTN_GATE_W, < 0.37, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : NT_N.W.2.LV */
      rNT_N_W_2_HV @= { @ "NT_N.W.2_HV : CL018LV 1.5V/3.3V, CL018LV 1.5V/2.5V, CL018G 1.8V/3.3, minimum Poly gate dimension of a {2.5V or 3.3V} blocked NT_N device < 1.2";
          Z = and_edge( NTN_GATE_W, OD2, false ); 
          internal1( Z, < 1.2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : NT_N.W.2_HV */
   #endif /* end of #ifdef _1_5V  */ 
   #ifndef C016 
      #ifdef _3_3V 
         rNT_N_W_2_3_3V @= { @ "NT_N.W.2_3.3V : For CL018LV 1.5V/3.3V, CL018LV 1.5V/2.5V, CL018G 1.8V/3.3V, minimum Poly gate dimension of a {2.5V or 3.3V} blocked NT_N device < 1.2";
             Z = and_edge( NTN_GATE_W, OD2, false ); 
             internal1( Z, < 1.2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
         } /* end of rule : NT_N.W.2_3.3V */
      #endif /* end of #ifdef _3_3V  */ 
   #endif /* end of #ifndef C016  */ 
   #ifdef C016 
      rNTN_W_2B @= { @ "NTN.W.2B : Minimum poly gate dimension (channel length) of a 3.3V blocked NT_N device < 1.32";
          Z = and_edge( NTN_GATE_W, OD2, false ); 
          internal1( Z, < 1.32, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : NTN.W.2B */
      rNTN_W_3 @= { @ "NTN.W.3 : Minimum OD width of 1.8V/3.3V blocked NT_N device < 0.245";
          A = interacting( NTN_OD, NTN_PO ); 
          internal1( A, < 0.245, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : NTN.W.3 */
   #endif /* end of #ifdef C016  */ 
   rNT_N_S_1 @= { @ "NT_N.S.1 : Minimum space between two NT_N regions < " + NT_N_S_1; 
       external1( NTN, < NT_N_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : NT_N.S.1 */
   #ifdef C0152 
      rNT_N_S_2 @= { @ "NT_N.S.2 : Space of NT_N to ULLNW (Overlap is not allowed) >= " + NT_N_S_2; 
          external2( NTN, ULLNW, < NT_N_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          NTN and ULLNW; 
      } /* end of rule : NT_N.S.2 */
   #endif /* end of #ifdef C0152  */ 
   rNT_N_E_1 @= { @ "NT_N.E.1 : Maximum and Minimum extension from NT_N region beyond an NP OD region " + NT_N_E_1; 
       A = interacting( NTN, NPOD ); 
       B = interacting( NPOD, NTN ); 
       C = size( B, clip_acute = NONE, distance = NT_N_E_1 ); 
       D = size( A, clip_acute = NONE, distance = - NT_N_E_1 ); 
       A xor C; 
       B xor D; 
   } /* end of rule : NT_N.E.1 */
   #ifdef _1_5V 
      rNT_N_E_2_LV @= { @ "NT_N.E.2.LV : For CL018LV 1.5V/2.5V & 1.5V/3.3V, minimum extension from OD2 edge to {2.5V or 3.3V} "
                                        "NT_N region inside OD2 < 0.86um";
          enclose( NTN, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          cutting( NTN, OD2 ); 
      } /* end of rule : NT_N.E.2.LV */
   #endif /* end of #ifdef _1_5V  */ 
   rNT_N_C_1 @= { @ "NT_N.C.1 : MInimum clearance from NT_N to OD < " + NT_N_C_1; 
       external2( OD, NTN, < NT_N_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       cutting( OD, NTN ); 
   } /* end of rule : NT_N.C.1 */
   rNT_N_C_2 @= { @ "NT_N.C.2 : Minimum clearance frome a NT_N region to NWEL edge < 1.66";
       external2( NTN, NWEL, < 1.66, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       NTN and NWEL; 
   } /* end of rule : NT_N.C.2 */
   #ifdef _1_5V 
      rNT_N_C_3_LV @= { @ "NT_N.C.3.LV : For CL018LV 1.5/2.5V & 1.5/3.3V, minimum clearance from 1.5V "
                                        "NT_N region to OD2 edge < 0.86um";
          external2( NTN, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : NT_N.C.3.LV */
   #endif /* end of #ifdef _1_5V  */ 
   rNT_N_PO_1 @= { @ "NT_N.PO.1 : Minimum overlap of a PO region extended into field oxide(endcap) < 0.35";
       enclose( NTN_OD, POLY, < 0.35, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
   } /* end of rule : NT_N.PO.1 */
#endif /* end of #ifndef _5V  */    /* #IFNDEF or IFDEF 5V */ 

// OD CHECKS
//==============
rOD_W_1_OD_W_2 @= { @ "OD.W.1_OD.W.2 : Min. OD width for MOS and interconnect < 0.22";
    internal1( OD, < 0.22, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : OD.W.1_OD.W.2 */
rOD_S_1 @= { @ "OD.S.1 : Min. OD space < 0.28";
    external1( OD, < 0.28, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : OD.S.1 */
rOD_C_1 @= { @ "OD.C.1 : Min. NWEL olap NPOD tie down < 0.12";
    enclose( NPOD, NONWR, < 0.12, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    cutting( NPOD, NONWR ); 
} /* end of rule : OD.C.1 */
rOD_C_2_OD_C_3 @= { @ "OD.C.2_OD.C.3 : Min. NWEL to NPOD space < 0.43";
    A = NPOD not_inside NWEL; 
    X = A not ODWR; 
    external2( X, NWEL, < 0.43, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    cutting( X, NWEL ); 
} /* end of rule : OD.C.2_OD.C.3 */
rOD_C_4 @= { @ "OD.C.4 : NWEL overlap PPOD < 0.43";
    enclose( PPOD, NWEL, < 0.43, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    cutting( PPOD, NWEL ); 
} /* end of rule : OD.C.4 */
rOD_C_5 @= { @ "OD.C.5 : NWEL space PPOD outside NW < 0.12";
    external2( PTAP, NWEL, < 0.12, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : OD.C.5 */

// OD.C.6 is checked by PP.C.5 and NP.C.5
#ifdef RECOMMEND 
   rOD_C_7 @= { @ "OD.C.7 : Min. clearance between parallel NW strap and PW strap < " + OD_C_7 + " um"; 
       external2( NTAP, PTAP, < OD_C_7, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
   } /* end of rule : OD.C.7 */
#endif /* end of #ifdef RECOMMEND  */ 

// OD.S.2 is not necessary to check
rOD_W_3 @= { @ "OD.W.3 : Length of active with width < " + OD_W_3_J + " um, connected to butted strap > " + OD_W_3_T + " um"; 
    sLAYER_21 = interacting( DACT, ALL_GATE ); 
    SD = sLAYER_21 not ALL_GATE; 
    NP_PP_BTE = NPOD coincident_outside_edge PPOD; 
    BUTTED_EDGE = length_edge( NP_PP_BTE, < OD_W_3_J ); 
    CHECK_SD = SD touching BUTTED_EDGE; 
    sLAYER_22 = CHECK_SD coincident_inside_edge OD; 
    NARROW_SD = internal1( sLAYER_22, < OD_W_3_J, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    sLAYER_23 = NARROW_SD touching BUTTED_EDGE; 
    sLAYER_24 = NARROW_SD touching GATE_W; 
    CHECK_OD = sLAYER_23 or sLAYER_24; 
    sLAYER_25 = OD coincident_inside_edge CHECK_OD; 
    length_edge( sLAYER_25, > OD_W_3_T, CONNECT ); 
} /* end of rule : OD.W.3 */
rOD_A_1 @= { @ "OD.A.1 : Min. area of stand-alone OD region < 0.202";
    area( OD, < 0.202 ); 
} /* end of rule : OD.A.1 */
#ifdef C0152 
   rOD_S_3 @= { @ "OD.S.3 : Space of (NW INTERACT (P+OD AND ULLNW)) to (P-channel PO gate INSIDE ULLNW) >= " + OD_S_3; 
       sLAYER_26 = PPOD and ULLNW; 
       A = interacting( LVNW, sLAYER_26 ); 
       B = GATE_PP inside ULLNW; 
       external2( A, B, < OD_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : OD.S.3 */
   rOD_S_4 @= { @ "OD.S.4 : Space of (ULLNW INTERACT (P+OD AND NW)) to (P-channel PO gate INSIDE NW) >= " + OD_S_4; 
       sLAYER_27 = PPOD and LVNW; 
       A = interacting( ULLNW, sLAYER_27 ); 
       B = GATE_PP inside LVNW; 
       external2( A, B, < OD_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : OD.S.4 */
   rOD2_R_1 @= { @ "OD2.R.1 : OD2 region overlap ULLNW is not allowed";
       OD2 and ULLNW; 
   } /* end of rule : OD2.R.1 */
#endif /* end of #ifdef C0152  */ 
#ifdef RECOMMEND 
   rOD_EX_1 @= { @ "OD.EX.1 : Min. extension of NW beyond NPOD which is parallel NW strap and PW strap >= " + OD_EX_1; 
       A = external2( NTAP, PTAP, < 0.72, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
       B = NTAP coincident_edge A; 
       enclose( B, NWEL, < OD_EX_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
   } /* end of rule : OD.EX.1 */
#endif /* end of #ifdef RECOMMEND  */ 
rOD_R_5 @= { @ "OD.R.5 : (NW OR ULLNW) cut {(OD INTERACT(OD NOT (NP OR PP))) NOT INTERACT CO} is not allowed (except NW fully inside OD or OD fully inside NW)";
    sLAYER_30 = gNP or PP; 
    sLAYER_29 = OD not sLAYER_30; 
    sLAYER_28 = interacting( OD, sLAYER_29 ); 
    PRE = not_interacting( sLAYER_28, CO ); 
    A = NWEL inside PRE; 
    B = PRE inside NWEL; 
    sLAYER_31 = NWEL not A; 
    sLAYER_32 = PRE not B; 
    cutting( sLAYER_31, sLAYER_32 );
} /* end of rule : OD.R.5 */
#ifdef C0152 
   
   // ODLL CHECKS
   //===========
   ODLL_GATE_NP = interacting( GATE_NP, ODLL ); 
   ODLL_GATE = interacting( ALL_GATE, ODLL ); 
   LV_ALL_GATE = ALL_GATE not ODLL_GATE; 
   gLAYER_36 = size( ODLL_GATE_NP, clip_acute = NONE, distance = 0.03 ); 
   gLAYER_35 = gLAYER_36 and POLY; 
   ODLL_EXGATE_NP = size( gLAYER_35, clip_acute = NONE, distance = 0.32 ); 
   gLAYER_38 = size( LV_ALL_GATE, clip_acute = NONE, distance = 0.03 ); 
   gLAYER_37 = gLAYER_38 and POLY; 
   LV_ALL_EXGATE = size( gLAYER_37, clip_acute = NONE, distance = 0.32 ); 
   rODLL_W_1 @= { @ "ODLL.W.1 : Min. width of ODLL < 0.44um";
       internal1( ODLL, < 0.44, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
   } /* end of rule : ODLL.W.1 */
   rODLL_S_1 @= { @ "ODLL.S.1 : Min. space two ODLL region < 0.44um";
       external1( ODLL, < 0.44, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : ODLL.S.1 */
   rODLL_S_2 @= { @ "ODLL.S.2 : Space of ODLL to an non-butted Pwell strap(P+ OD inside PW) < 0.1um, and butted is allowed";
       external2( ODLL, PTAP, < 0.1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
       A = external2_edge( ODLL, PTAP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = COINCIDENT, output_layer = LAYER2 ); 
       B = edge_size( A, outside = 0.001 ); 
       not_interacting( B, NACT ); 
   } /* end of rule : ODLL.S.2 */
   rODLL_S_3 @= { @ "ODLL.S.3 : Space of ODLL to butted diffusion P+OD region(inside PW) < 0";
       ODLL and PTAP; 
   } /* end of rule : ODLL.S.3 */
   rODLL_S_4_ODLL_E_2 @= { @ "ODLL.S.4_ODLL.E.2 : Min. clearance from ODLL to N-channel PO gate inside ODLL < 0.32um";
       ODLL_EXGATE_NP not ODLL; 
   } /* end of rule : ODLL.S.4_ODLL.E.2 */
   rODLL_S_5_ODLL_S_7 @= { @ "ODLL.S.5_ODLL.S.7 : Space of ODLL to PO gate outside ODLL < 0.32um";
       LV_ALL_EXGATE and ODLL; 
   } /* end of rule : ODLL.S.5_ODLL.S.7 */
   rODLL_O_1 @= { @ "ODLL.O.1 : Min. overlap from ODLL to OD < 0.23um";
       internal2( ODLL, OD, < 0.23, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = RELATED_COINCIDENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : ODLL.O.1 */
   rODLL_E_1 @= { @ "ODLL.E.1 : Min. extension of ODLL beyond NPOD ( if the distance to the releated poly > 0.32um ) < 0.18um";
       enclose( NACT, ODLL, < 0.18, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
       A = enclose_edge( NACT, ODLL, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
       B = edge_size( A, outside = 0.001 ); 
       not_interacting( B, PTAP ); 
   } /* end of rule : ODLL.E.1 */
   
   // ODLL.E.2 is checked by ODLL.S.4_ODLL.E.2
   rODLL_E_3 @= { @ "ODLL.E.3 : Minimum extension of a ODLL region beyond a P+OD region inside ULLNW >= 0.00um";
       A = PACT and ULLNW; 
       B = A and ODLL; 
       C = interacting( A, B ); 
       C not ODLL; 
   } /* end of rule : ODLL.E.3 */
   rODLL_S_6 @= { @ "ODLL.S.6 : Space of ODLL to N+OD outside ODLL and in PW (if the distance to the releated poly > 0.32um ) < 0.21um";
       A = NACT not ODLL; 
       external2( A, ODLL, < 0.21, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : ODLL.S.6 */
   
   //ODLL.S.7 is checked by ODLL.S.5_ODLL.S.7
   rODLL_A_1 @= { @ "ODLL.A.1 : Min. area of ODLL region < 0.3844";
       area( ODLL, < 0.3844 ); 
   } /* end of rule : ODLL.A.1 */
   rODLL_R_1 @= { @ "ODLL.R.1 : Overlap of ODLL to LVNW is forbidden unless ODLL inside ULLNW.";
       sLAYER_33 = ODLL and NWELI; 
       sLAYER_33 not ULLNWI; 
   } /* end of rule : ODLL.R.1 */
#endif /* end of #ifdef C0152  */ 
#ifdef _5V 
   
   // 5V OD CHECKS
   //==============
   rOD_C_2_1_OD_C_3_1 @= { @ "OD.C.2.1_OD.C.3.1 : Minimum clearance from NWEL edge to N+OD which interacts OD2 < " + OD_C_2_1; 
       sLAYER_34 = NPOD not_inside NWEL; 
       X = sLAYER_34 not ODWR; 
       Y = interacting( X, OD2 ); 
       external2( Y, NWEL, < OD_C_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : OD.C.2.1_OD.C.3.1 */
   rOD_C_4_1 @= { @ "OD.C.4.1 : Minimum clearance from NWEL edge to P+OD which interacts OD2 < " + OD_C_4_1; 
       X = interacting( PPOD, OD2 ); 
       enclose( X, NWEL, < OD_C_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
   } /* end of rule : OD.C.4.1 */
#endif /* end of #ifdef _5V  */ 

// OD2 CHECKS
//===============
DACTG = DACT or ALL_GATE; 
rOD2_W_1 @= { @ "OD2.W.1 : Minimum width of an OD2 region >= " + OD2_W_1 + " um"; 
    internal1( OD2, < OD2_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : OD2.W.1 */
rOD2_E_1 @= { @ "OD2.E.1 : Minimum extension of an OD2 region beyond an {active OD OR Gate} region>=0.32um";
    CHECK_EDGE = enclose_edge( DACTG, OD2, < 0.32, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
    CHECK_EDGE not_coincident_outside_edge DSTP; 
    OD2 inside DACTG;                     /* OD2 totally inside OD */ 
} /* end of rule : OD2.E.1 */
#ifndef _5V 
   #ifdef _1_8V 
      rOD2_S_1 @= { @ "OD2.S.1 : For two well process (1.8V/3.3V C018G), minimum space between two OD2 "
                                "regions. Merge if the space is less than 0.45um.>=0.45um";
          external1( OD2, < 0.45, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : OD2.S.1 */
   #endif /* end of #ifdef _1_8V  */ 
#endif /* end of #ifndef _5V  */ 
#ifdef _1_5V 
   rOD2_S_1_LV @= { @ "OD2.S.1.LV : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions. "
                                   "Merge if the space is less than 0.86um.";
       external1( OD2, < 0.86, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.S.1.LV */
#endif /* end of #ifdef _1_5V  */ 
#ifdef _5V 
   rOD2_S_1_5V @= { @ "OD2.S.1.5V : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions. "
                                   "Merge if the space is less than 0.86um.";
       external1( OD2, < 0.86, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.S.1.5V */
#endif /* end of #ifdef _5V  */ 
#ifdef LP 
   rOD2_S_1_LP @= { @ "OD2.S.1.LP : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions. "
                                   "Merge if the space is less than 0.86um.";
       external1( OD2, < 0.86, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.S.1.LP */
#endif /* end of #ifdef LP  */ 
rOD2_C_1 @= { @ "OD2.C.1 : Minimum clearance between OD region and an OD2 region>=0.32um";
    external2( OD2, NACT, < 0.32, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    external2( OD2, PACT, < 0.32, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : OD2.C.1 */
rOD2_C_2 @= { @ "OD2.C.2 : Minimum clearance between OD2 region and {1.5V or 1.8V} transistor gate "
                          "poly>= 0.4um";
    A = and_edge( OD2, DACT, false ); 
    external2( A, GATE_W, < 0.4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
} /* end of rule : OD2.C.2 */
rOD2_E_2 @= { @ "OD2.E.2 : Minimum extension of OD2 region beyond {2.5V or 3.3V or 5V} transistor "
                          "gate poly in the source/drain OD direction OD2 cut poly GATE is not "
                          "allowed. >=0.4um";
    enclose( GATE_W, OD2_BEDGE, < 0.4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
    cutting( ALL_GATE, OD2 ); 
} /* end of rule : OD2.E.2 */
#ifdef _1_5V 
   rOD2_E_4_LV @= { @ "OD2.E.4.LV : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region "
                                   "beyond an NW region>=0.86um. Align if space is less than 0.86um";
       enclose( NWEL, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.E.4.LV */
   rOD2_C_4_LV @= { @ "OD2.C.4.LV : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region "
                                   "and an NW region. Align if space is less than 0.86um";
       external2( NWEL, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
       enclose( OD2, NWEL, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.C.4.LV */
   rOD2_O_1_LV @= { @ "OD2.O.1.LV : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um";
       internal2( NWEL, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.O.1.LV */
#endif /* end of #ifdef _1_5V  */ 
#ifdef _5V 
   rOD2_E_4_5V @= { @ "OD2.E.4.5V : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region "
                                   "beyond an NW region>=0.86um. Align if space is less than 0.86um";
       enclose( NWEL, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.E.4.5V */
   rOD2_C_4_5V @= { @ "OD2.C.4.5V : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region "
                                   "and an NW region. Align if space is less than 0.86um";
       external2( NWEL, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
       enclose( OD2, NWEL, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.C.4.5V */
   rOD2_O_1_5V @= { @ "OD2.O.1.5V : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um";
       internal2( NWEL, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.O.1.5V */
#endif /* end of #ifdef _5V  */ 
#ifdef LP 
   rOD2_E_4_LP @= { @ "OD2.E.4.LP : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region "
                                   "beyond an NW region>=0.86um. Align if space is less than 0.86um";
       enclose( NWEL, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.E.4.LP */
   rOD2_C_4_LP @= { @ "OD2.C.4.LP : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region "
                                   "and an NW region. Align if space is less than 0.86um";
       external2( NWEL, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
       enclose( OD2, NWEL, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.C.4.LP */
   rOD2_O_1_LP @= { @ "OD2.O.1.LP : For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V "
                                   "C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um";
       internal2( NWEL, OD2, < 0.86, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : OD2.O.1.LP */
#endif /* end of #ifdef LP  */ 

// POLY checks
//=============
//PO.W.1A is checked by PO.W.3
//PO.W.2A is checked by PO.W.3
rPO_W_3 @= { @ "PO.W.3 : Min. POLY width for interconnect, 1.8V NMOS, 1.8V PMOS < 0.18";
    internal1( POLY, < 0.18, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : PO.W.3 */
#ifdef _3_3V 
   rPO_W_1_3_3V @= { @ "PO.W.1_3.3V : Min. POLY gate length 3.3V pmos < 0.30";
       internal1( HV_PGATE_W, < 0.3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
   } /* end of rule : PO.W.1_3.3V */
   rPO_W_2_3_3V @= { @ "PO.W.2_3.3V : Min. POLY gate length 3.3v nmos < 0.35";
       internal1( HV_NGATE_W, < 0.35, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
   } /* end of rule : PO.W.2_3.3V */
#endif /* end of #ifdef _3_3V  */ 
#ifdef _2_5V 
   rPO_W_1_2_5V @= { @ "PO.W.1_2.5V : Min. POLY gate length 2.5V pmos < 0.26";
       internal1( HV_PGATE_W, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
   } /* end of rule : PO.W.1_2.5V */
   rPO_W_2_2_5V @= { @ "PO.W.2_2.5V : Min. POLY gate length 2.5v nmos < 0.26";
       internal1( HV_NGATE_W, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
   } /* end of rule : PO.W.2_2.5V */
#endif /* end of #ifdef _2_5V  */ 
#ifdef _5V 
   rPO_W_1_5V @= { @ "PO.W.1_5V : Min. POLY gate length 5.0V pmos < 0.5";
       internal1( HV_PGATE_W, < 0.5, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
   } /* end of rule : PO.W.1_5V */
   rPO_W_2_5V @= { @ "PO.W.2_5V : Min. POLY gate length 5.0v nmos < 0.6";
       internal1( HV_NGATE_W, < 0.6, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
   } /* end of rule : PO.W.2_5V */
#endif /* end of #ifdef _5V  */ 
rPO_S_1 @= { @ "PO.S.1 : Min. POLY space on OD with contact < 0.375";
    Y = ALL_GATE coincident_outside_edge ASD1; 
    external1( Y, < 0.375, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
} /* end of rule : PO.S.1 */
rPO_S_2_PO_S_3 @= { @ "PO.S.2_PO.S.3 : Min. POLY space: on OD w/o contact and interconnect < 0.25";
    external1( POLY, < 0.25, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : PO.S.2_PO.S.3 */
rPO_C_1 @= { @ "PO.C.1 : Min. POLY on field space to active < 0.1";
    external2( POLY, OD, < 0.1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 89.5, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : PO.C.1 */
rPO_C_2 @= { @ "PO.C.2 : Min. OD overhang gate < " + PO_C_2; 
    enclose( POLY, OD, < PO_C_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 89.5, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : PO.C.2 */
GATE_5V = ALL_GATE and OD2; 
PO_5V = interacting( POLY, GATE_5V ); 
gLAYER_39 = NW_5V and OD; 
gLAYER_41 = interacting( OD, GATE_5V ); 
gLAYER_40 = gLAYER_41 not NWEL; 
OD_5V = gLAYER_39 or gLAYER_40; 
#ifdef _5V 
   rPO_C_3 @= { @ "PO.C.3 : Min. clearance for an (OD not OD2) region to an 5V PO on field oxide >= " + PO_C_3; 
       A = OD not OD2; 
       B = PO_5V not OD; 
       external2( A, B, < PO_C_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : PO.C.3 */
   rPO_C_4 @= { @ "PO.C.4 : Min. clearance from an (5V OD not OD2) region to an PO on field oxide >= " + PO_C_4; 
       A = OD_5V not OD2; 
       external2( A, POLY_ISO, < PO_C_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
       B = external2_edge( A, POLY_ISO, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = COINCIDENT, output_layer = LAYER1 ); 
       C = edge_size( B, inside = 0.001 ); 
       not_interacting( C, ALL_GATE ); 
   } /* end of rule : PO.C.4 */
#endif /* end of #ifdef _5V  */ 
rPO_O_1 @= { @ "PO.O.1 : Min. POLY overhang active < 0.22";
    enclose( OD, POLY, < 0.22, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 89.5, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : PO.O.1 */
#ifndef MIX_MODE 
   rPO_R_1A @= { @ "PO.R.1A : 90 degree gate not allowed/L and U shape gate are not allowed";
   
         // 0.18 value is arbitrary, note the angle
       external1_error( GATE_W, < 0.18, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ); 
       internal1_error( GATE_W, < 0.18, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } ); 
   } /* end of rule : PO.R.1A */
#endif /* end of #ifndef MIX_MODE  */ 
rPO_R_1B @= { @ "PO.R.1B : 45 degree 1.8V gate min. length < 0.21";
    internal1( LVGT, < 0.21, extension = NONE, intersecting = {  }, orthogonal = NEITHER, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
} /* end of rule : PO.R.1B */
rPO_R_2 @= { @ "PO.R.2 : Max. POLY length between contacts when PO width less than 0.24um > " + PO_R_2; 
    LONG_PO = area( ILP1, > ( 0.18 * PO_R_2 ) ); 
    CHECK_PO = interacting( LONG_PO, CO ); 
    CHECK_CO = interacting( CO, CHECK_PO ); 
    CO_A = size_inside_wrapper( CHECK_CO, CHECK_PO, distance = PO_R_2 / 2, increment = 0.25 ); 
    PO_A = interacting( CHECK_PO, CO_A, == 1 ); 
    PO_B = interacting( CHECK_PO, CO_A, > 1 ); 
    CO_B = interacting( CO_A, PO_A ); 
    CO_C = size_inside_wrapper( CO_B, PO_A, distance = PO_R_2 / 2, increment = 0.25 ); 
    sLAYER_35 = PO_A not CO_C; 
    sLAYER_36 = PO_B not CO_A; 
    BAD = sLAYER_35 or sLAYER_36; 
    BAD_EDGE = BAD coincident_inside_edge POLY; 
    sERROR = internal1( BAD_EDGE, <= 0.24, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
    interacting( CHECK_PO, sERROR ); 
} /* end of rule : PO.R.2 */
GATEU = stamp( ALL_GATE, ILP1U, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
PSDU_G = interacting( PSDU, POLYI ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDU_G }, PSDU }} ); 
NSDU_G = interacting( NSDU, POLYI ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDU_G }, NSDU }} ); 

//get all floating gates
FLOAT_GATE = net_area_ratio( CONNECT_DB, > 0, { "layer1" => GATEU, "layer2" => PTAPU, "layer3" => NTAPU, "layer4" => PSDU_G, "layer5" => NSDU_G, "layer6" => CBU, "layer7" => UBMNU, "layer8" => UBMDU, "layer9" => COU }, 9, 9, {  }, NAR_SAVE_NET_4, false ); 

//get all floating source/drain
FLOAT_NSD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => NSDU_G, "layer2" => PSDU_G, "layer3" => GATEU, "layer4" => PTAPU, "layer5" => NTAPU, "layer6" => CBU, "layer7" => UBMNU, "layer8" => UBMDU }, 8, 8, {  }, NAR_SAVE_NET_5, false ); 
FLOAT_PSD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => PSDU_G, "layer2" => NSDU_G, "layer3" => GATEU, "layer4" => PTAPU, "layer5" => NTAPU, "layer6" => CBU, "layer7" => UBMNU, "layer8" => UBMDU }, 8, 8, {  }, NAR_SAVE_NET_5, false ); 

//not floating source/drain
EFFECTIVE_NSD = NSDU_G not FLOAT_NSD; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ EFFECTIVE_NSD }, NSDU_G }} ); 
EFFECTIVE_PSD = PSDU_G not FLOAT_PSD; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ EFFECTIVE_PSD }, PSDU_G }} ); 
gLAYER_43 = FLOAT_NSD or ALL_GATE; 
gLAYER_42 = interacting( gLAYER_43, EFFECTIVE_NSD, >= 2, connect_sequence = CONNECT_DB, count_by = NET ); 
FLOAT_NSD_A = FLOAT_NSD not gLAYER_42; 
gLAYER_45 = FLOAT_PSD or ALL_GATE; 
gLAYER_44 = interacting( gLAYER_45, EFFECTIVE_PSD, >= 2, connect_sequence = CONNECT_DB, count_by = NET ); 
FLOAT_PSD_A = FLOAT_PSD not gLAYER_44; 
gLAYER_46 = FLOAT_NSD_A or FLOAT_PSD_A; 
FLOAT_GATE_CHECK = not_interacting( FLOAT_GATE, gLAYER_46 ); 
#ifdef FULL_CHIP 
   rPO_R_4 @= { @ "PO.R.4 : It is prohibited for Floating Gate if the effective source/drain is not connected together";
       interacting( FLOAT_GATE_CHECK, NSDU, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
       interacting( FLOAT_GATE_CHECK, PSDU, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
   } /* end of rule : PO.R.4 */
#endif /* end of #ifdef FULL_CHIP  */ 
#ifdef RECOMMEND 
   rRES_2 @= { @ "RES.2 : For poly resistor, it is strongly recommended that the poly resistor width >= " + RES_2_W + " um, " 
                         "length >= 5.0um, and the resistor square number Nsq >= " + RES_2_NSQ + ", " 
                         "DRC will check the width and Nsq 1um and 5 for poly resistor & 2um and 5 for OD resistor";
       internal1( PORESC, < RES_2_W, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
       net_area_ratio( CONNECT_DB, < RES_2_NSQ, { "layer1" => PORESC_L, "layer2" => PORESC_W }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
   } /* end of rule : RES.2 */
   DMPN2V = DMP2V or DMN2V; 
   rRES_3_PO @= { @ "RES.3_PO : The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is "
                               "resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, "
                               "dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation, "
                               "please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. "
                               "Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.";
       sLAYER_38 = interacting( PORES, PP ); 
       sLAYER_37 = not_interacting( sLAYER_38, HRII ); 
       sLAYER_37 not DMP2V; 
       sLAYER_39 = interacting( PORES, gNP ); 
       sLAYER_39 not DMN2V; 
       sLAYER_40 = DMP2V and DMN2V; 
       sLAYER_40 and PORES; 
       PORES_PO = interacting( POLY, PORES ); 
       enclose( PORES_PO, DMP2V, < 0.22, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       enclose( PORES_PO, DMN2V, < 0.22, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       sLAYER_41 = interacting( DMPN2V, PORES ); 
       sLAYER_456 = length_edge( sLAYER_41, > 0 );
       sLAYER_457 = extend_edge( sLAYER_456, start = - 0.005, end = - 0.005 );
       X = edge_size( sLAYER_457, inside = 0.005 ); 
       sLAYER_43 = not_interacting( X, PORES_PO ); 
       sLAYER_42 = DMPN2V touching_edge sLAYER_43; 
       Y = edge_size( sLAYER_42, inside = 0.22 ); 
       not_outside_touching( Y, PORES ); 
   } /* end of rule : RES.3_PO */
   rRES_3_OD @= { @ "RES.3_OD : The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is "
                               "resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, "
                               "dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation, "
                               "please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. "
                               "Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.";
       sLAYER_45 = interacting( ODRES, PP ); 
       sLAYER_44 = sLAYER_45 not DMP2V; 
       sLAYER_44 not SEALRING_ALL; 
       sLAYER_46 = interacting( ODRES, gNP ); 
       sLAYER_46 not DMN2V; 
       sLAYER_47 = DMP2V and DMN2V; 
       sLAYER_47 and ODRES; 
       ODRES_OD = interacting( OD, ODRES ); 
       enclose( ODRES_OD, DMP2V, < 0.22, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       enclose( ODRES_OD, DMN2V, < 0.22, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       sLAYER_48 = interacting( DMPN2V, ODRES ); 
       sLAYER_458 = length_edge( sLAYER_48, > 0 );
       sLAYER_459 = extend_edge( sLAYER_458, start = - 0.005, end = - 0.005 );
       X = edge_size( sLAYER_459, inside = 0.005 ); 
       sLAYER_50 = not_interacting( X, ODRES_OD ); 
       sLAYER_49 = DMPN2V touching_edge sLAYER_50; 
       Y = edge_size( sLAYER_49, inside = 0.22 ); 
       not_outside_touching( Y, ODRES ); 
   } /* end of rule : RES.3_OD */
   rRES_4_PO @= { @ "RES.4_PO : Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor = 0.22um";
       PO_RES = interacting( POLY, PORES ); 
       CO_RES = interacting( CO, PO_RES ); 
       RPO_E = and_edge( RPO, PO_RES, false ); 
       RPO_EX = edge_size( RPO_E, outside = 0.22 ); 
       RPO_EX and CO_RES; 
       not_interacting( RPO_EX, CO_RES ); 
       not_interacting( CO_RES, RPO_EX ); 
   } /* end of rule : RES.4_PO */
   rRES_4_OD @= { @ "RES.4_OD : Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor ==0.22um";
       OD_RES = interacting( OD, ODRES ); 
       CO_RES = interacting( CO, OD_RES ); 
       RPO_E = and_edge( RPO, OD_RES, false ); 
       RPO_EX = edge_size( RPO_E, outside = 0.22 ); 
       sLAYER_51 = RPO_EX and CO_RES; 
       sLAYER_51 not SEALRING_ALL; 
       sLAYER_52 = not_interacting( RPO_EX, CO_RES ); 
       sLAYER_52 not SEALRING_ALL; 
       sLAYER_53 = not_interacting( CO_RES, RPO_EX ); 
       sLAYER_53 not SEALRING_ALL; 
   } /* end of rule : RES.4_OD */
   rRES_5_PO @= { @ "RES.5_PO : Min. clearance from poly resistor and OD resistor to un-related NP, PP regions >= 0.26um";
       external2( PORES, IMP, < 0.26, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = ALL, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : RES.5_PO */
   rRES_5_OD @= { @ "RES.5_OD : Min. clearance from poly resistor and OD resistor to un-related NP, PP regions >= 0.26um";
       external2( ODRES, IMP, < 0.26, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = ALL, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : RES.5_OD */
   rRES_6_PO @= { @ "RES.6_PO : Minimum clearance from an un-related RPO to the POLY and OD  resistor>= 0.3um";
       external2( PORES, RPO, < 0.3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = ALL, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : RES.6_PO */
   rRES_6_OD @= { @ "RES.6_OD : Minimum clearance from an un-related RPO to the POLY and OD resistor>= 0.3um";
       external2( ODRES, RPO, < 0.3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = ALL, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : RES.6_OD */
   
   // RES.7 is checked by RES.4
   rRES_8 @= { @ "RES.8 : To use rectangle shape resistor for SPICE simulation accuracy.";
       not_rectangles( PORESC ); 
       sLAYER_54 = not_rectangles( ODRES ); 
       sLAYER_54 not SEALRING; 
   } /* end of rule : RES.8 */
#endif /* end of #ifdef RECOMMEND  */ 
rRES_9 @= { @ "RES.9 : DMN2V overlap DMP2V not allowed";
    DMP2V and DMN2V; 
} /* end of rule : RES.9 */
rRES_10 @= { @ "RES.10 : Minimum clearence from DMN2V to GATE(overlap is not allowed) >=0.35um";
    external2( DMN2V, ALL_GATE, < 0.35, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DMN2V and ALL_GATE; 
} /* end of rule : RES.10 */
rRES_11 @= { @ "RES.11 : Minimum clearence from DMP2V to GATE(overlap is not allowed) >=0.35um";
    external2( DMP2V, ALL_GATE, < 0.35, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DMP2V and ALL_GATE; 
} /* end of rule : RES.11 */
#ifdef RECOMMEND 
   rRES_12 @= { @ "RES.12 : For OD resistor, it is strongly recommended that the resistor width>= " + RES_12_W + " um and the resistor square number Nsq >= " + RES_12_NSQ + ". " 
                           "DRC will check the width and Nsq 1um and 5 for poly resistor & 2um and 5 for OD resistor";
       internal1( ODRESC, < RES_12_W, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
       net_area_ratio( CONNECT_DB, < RES_12_NSQ, { "layer1" => ODRESC_L, "layer2" => ODRESC_W }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
   } /* end of rule : RES.12 */
   #ifdef _5V 
      rRES_14 @= { @ "RES.14 : Minimum clearance from poly resistor to od edge >= " + RES_14; 
          external2( PORESC, OD, < RES_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : RES.14 */
   #endif /* end of #ifdef _5V  */ 
#endif /* end of #ifdef RECOMMEND  */ 
rRES_13 @= { @ "RES.13 : Minimum clearance from poly resistor to OD edge >= " + RES_13; 
    external2( PORESC, OD, < RES_13, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : RES.13 */
rRES_15 @= { @ "RES.15 : Poly resistor cuts NW is not allowed.";
    cutting( PORESC, NWEL ); 
} /* end of rule : RES.15 */
#ifdef MIX_MODE 
   #ifdef RECOMMEND 
      rRES_HRI_1 @= { @ "RES.HRI.1 : It is strongly recommended that the HRI poly resistor width e 1.0 um and resistor number of square Nsq e 2.";
          internal1( HREPC, < 1.0, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          net_area_ratio( CONNECT_DB, < 2.0, { "layer1" => HREP_L, "layer2" => HREP_W }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
      } /* end of rule : RES.HRI.1 */
      
      //RES.HRI.2 is checked by RES.4_PO
      //RES.HRI.3 is checked by RES.5_PO
      //RES.HRI.4 is checked by RES.6_PO 
      //RES.HRI.5 is checked by RES.4_PO
      //RES.HRI.6 un-checkable by DRC
      rRES_HRI_7 @= { @ "RES.HRI.7 : Min. clearance from RLPPDMY to the HRI poly resistor >= 0.26um";
          PO_HREP = interacting( POLY, HREP ); 
          enclose( PO_HREP, RLPPDMY, < 0.26, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RES.HRI.7 */
      rRES_HRI_8 @= { @ "RES.HRI.8 : To use rectangle shape HRI resistor for the SPICE simulation accuracy.";
          not_rectangles( HREPC ); 
      } /* end of rule : RES.HRI.8 */
      rRES_HRI_9 @= { @ "RES.HRI.9 : Min. clearance from HRI resistor to OD edge >= " + RES_HRI_9; 
          external2( HREPC, OD, < RES_HRI_9, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : RES.HRI.9 */
   #endif /* end of #ifdef RECOMMEND  */ 
   rRES_HRI_10 @= { @ "RES.HRI.10 : HRI resistor cuts NW is not allowed.";
       cutting( HREPC, NWEL ); 
   } /* end of rule : RES.HRI.10 */
   rRES_HRI_11 @= { @ "RES.HRI.11 : RLPPDMY and PP must be butted (overlap is not allow)";
       sLAYER_55 = RLPPDMY and PP; 
       sLAYER_55 and POLY; 
       sLAYER_56 = interacting( POLY, HREPC ); 
       A = and_edge( PP, sLAYER_56, false ); 
       sLAYER_57 = interacting( POLY, HREPC ); 
       B = PP and sLAYER_57; 
       not_outside_touching( HREPC, B, == 2 ); 
       A not_coincident_outside_edge RLPPDMY; 
   } /* end of rule : RES.HRI.11 */
   #ifdef RECOMMEND 
      gLAYER_55 = interacting( POLY, HREPC ); 
      CO_HRI = interacting( CO, gLAYER_55 ); 
      rRES_HRI_12 @= { @ "RES.HRI.12 : Min and max space between two CO region on HRI poly res == " + RES_HRI_12; 
          external1( CO_HRI, < RES_HRI_12, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_58 = interacting( POLY, HREPC ); 
          A = sLAYER_58 not RPO; 
          B = size( size( CO_HRI, RES_HRI_12 / 2, clip_acute = NONE ), - ( RES_HRI_12 / 2 ), clip_acute = NONE ); 
          interacting( A, B, != 1 ); 
      } /* end of rule : RES.HRI.12 */
   #endif /* end of #ifdef RECOMMEND  */ 
#endif /* end of #ifdef MIX_MODE  */ 

// PP CHECKS
//============
PPE4_NWELC = size( NWELI, clip_acute = NONE, distance = 0.43 ); 
PPE4_NWELS = size( PPE4_NWELC, clip_acute = NONE, distance = 0.18 ); 
PPE4_OD = PTAP and PPE4_NWELS; 
PPE4_C1 = enclose( PPE4_OD, PP, < 0.18, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
PPE4_C2 = enclose( PPE4_OD, PP, < 0.18, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED ); 
PPE4_C3 = enclose( PPE4_OD, PP, < 0.18, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, orientation = { PARALLEL }, projection = { ON } ); 
gLAYER_56 = size( PPE4_C2, clip_acute = NONE, distance = 0.005 ); 
PPE4_C4 = gLAYER_56 not PPE4_OD; 
gLAYER_57 = PPE4_C1 or PPE4_C3; 
PPE4_ALL = gLAYER_57 or PPE4_C4; 
PPE4_CHECKOD = PPE4_ALL coincident_outside_edge PPE4_OD; 
NPC3_C1 = external2( PPE4_OD, gNP, < 0.18, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
NPC3_C2 = external2( PPE4_OD, gNP, < 0.18, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT ); 
NPC3_C3 = external2( PPE4_OD, gNP, < 0.18, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, orientation = { PARALLEL }, projection = { ON } ); 
gLAYER_58 = size( NPC3_C2, clip_acute = NONE, distance = 0.005 ); 
NPC3_C4 = gLAYER_58 not PPE4_OD; 
gLAYER_59 = NPC3_C1 or NPC3_C3; 
NPC3_ALL = gLAYER_59 or NPC3_C4; 
NPC3_CHECKOD = NPC3_ALL coincident_outside_edge PPE4_OD; 
NPE4_NWELC = size( NWELI, clip_acute = NONE, distance = - 0.43 ); 
NPE4_NWELS = size( NPE4_NWELC, clip_acute = NONE, distance = - 0.18 ); 
NPE4_OD = NTAP not NPE4_NWELS; 
NPE4_C1 = enclose( NPE4_OD, gNP, < 0.18, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
NPE4_C2 = enclose( NPE4_OD, gNP, < 0.18, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED ); 
NPE4_C3 = enclose( NPE4_OD, gNP, < 0.18, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, orientation = { PARALLEL }, projection = { ON } ); 
gLAYER_60 = size( NPE4_C2, clip_acute = NONE, distance = 0.005 ); 
NPE4_C4 = gLAYER_60 not NPE4_OD; 
gLAYER_61 = NPE4_C1 or NPE4_C3; 
NPE4_ALL = gLAYER_61 or NPE4_C4; 
NPE4_CHECKOD = NPE4_ALL coincident_outside_edge NPE4_OD; 
PPC3_C1 = external2( NPE4_OD, PP, < 0.18, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
PPC3_C2 = external2( NPE4_OD, PP, < 0.18, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT ); 
PPC3_C3 = external2( NPE4_OD, PP, < 0.18, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, orientation = { PARALLEL }, projection = { ON } ); 
gLAYER_62 = size( PPC3_C2, clip_acute = NONE, distance = 0.005 ); 
PPC3_C4 = gLAYER_62 not NPE4_OD; 
gLAYER_63 = PPC3_C1 or PPC3_C3; 
PPC3_ALL = gLAYER_63 or PPC3_C4; 
PPC3_CHECKOD = PPC3_ALL coincident_outside_edge NPE4_OD; 
rPP_W_1 @= { @ "PP.W.1 : PP width < " + PP_W_1; 
    internal1( PP, < PP_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : PP.W.1 */
rPP_S_1 @= { @ "PP.S.1 : PP space < " + PP_S_1; 
    external1( PP, < PP_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : PP.S.1 */
rPP_C_1 @= { @ "PP.C.1 : PP space to n active in pwell < " + PP_C_1; 

  // N active in pwell can be butting or non-butting. 
  // The non-butting N active is not allowed to touch PP.
    external2( PP, NACT, < PP_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
    X = external2_edge( PP, NACT, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = COINCIDENT, output_layer = LAYER2 ); 
    Y = edge_size( X, outside = 0.001 ); 
    not_interacting( Y, PPOD ); 
} /* end of rule : PP.C.1 */
rPP_C_2 @= { @ "PP.C.2 : PP space to non-butting NTAP < 0.1 with PWEL space >= 0.43";
    external2( PP, NTAP, < 0.1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
} /* end of rule : PP.C.2 */
rPP_C_3 @= { @ "PP.C.3 : PP space to non-butting NTAP < 0.18 with PWEL space < 0.43";
    not_edge( PPC3_CHECKOD, NPE4_NWELC, coincident = false ); 
} /* end of rule : PP.C.3 */

// PP.C.4 is checked by NP.C.5 and PP.R.1_NP.R.1
rPP_C_5 @= { @ "PP.C.5 : PP extension over (P gate) + (field poly within 0.35um) < " + PP_C_5 + " um"; 

  // This rule must extend out of gate in the direction of PO by 0.35um
    EXGATE_PP not PP; 
} /* end of rule : PP.C.5 */
rPP_O_1 @= { @ "PP.O.1 : Minimum overlap from a PP edge to an OD region must >= 0.230um except SBD region";
    internal2( OD, PP_NSBD, < 0.23, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = RELATED_COINCIDENT, relational = { POINT_TOUCH } ); 
} /* end of rule : PP.O.1 */
rPP_E_1 @= { @ "PP.E.1 : Minimum extension of a PP region beyond a P+ active OD region must >= " + PP_E_1 + " um " 
                        "except SBD and SEALRING region";
    sLAYER_59 = enclose( PACT, PP_NSBD, < PP_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
    not_interacting( sLAYER_59, SEALRING_ALL ); 
    Y = enclose_edge( PACT, PP_NSBD, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
    Z = edge_size( Y, outside = 0.001 ); 
    sLAYER_60 = not_interacting( Z, NPOD ); 
    not_interacting( sLAYER_60, SEALRING_ALL ); 
} /* end of rule : PP.E.1 */
rPP_E_1_NP_E_1 @= { @ "PP.E.1_NP.E.1 : Implant can not coincident OD edge except butted diffusion";
    sLAYER_61 = not_interacting( IMP, SEALRING_ALL ); 
    sLAYER_61 coincident_inside_edge OD; 
} /* end of rule : PP.E.1_NP.E.1 */
rPP_E_3 @= { @ "PP.E.3 : Minimum enclosure of PTAP by PP < 0.02 with NWEL space >= 0.43 except SEALRING region";
    sLAYER_62 = enclose( PTAP, PP, < 0.02, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
    not_interacting( sLAYER_62, SEALRING_ALL ); 
    X = enclose_edge( PTAP, PP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
    Y = edge_size( X, outside = 0.001 ); 
    sLAYER_63 = not_interacting( Y, NPOD ); 
    not_interacting( sLAYER_63, SEALRING_ALL ); 
} /* end of rule : PP.E.3 */
rPP_E_4 @= { @ "PP.E.4 : Min. enc. of PTAP by PP < 0.18 with NWEL space < 0.43";
    and_edge( PPE4_CHECKOD, PPE4_NWELC, false ); 
} /* end of rule : PP.E.4 */

// PP.C.6 is not necessary to check
// PP.E.5 is not necessary to check
rPP_A_1 @= { @ "PP.A.1 : Minimum area of PP < 0.3844";
    area( PP, < 0.3844 ); 
} /* end of rule : PP.A.1 */
#ifndef MIX_MODE 
   rPP_E_6 @= { @ "PP.E.6 : Min enc of POLY resistor by PP < " + PP_E_6; 
       enclose( PORES, PP, < PP_E_6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       sLAYER_65 = RPO and POLY; 
       sLAYER_64 = sLAYER_65 not IMP; 
       sLAYER_64 not HRI; 
   } /* end of rule : PP.E.6 */
#endif /* end of #ifndef MIX_MODE  */ 
rPP_R_1_NP_R_1 @= { @ "PP.R.1_NP.R.1 : PP and NP not allowed to overlap";
    PP and gNP; 
} /* end of rule : PP.R.1_NP.R.1 */

//PP.R.1 is checked by PP.R.1_NP.R.1
//NP.R.1 is checked by PP.R.1_NP.R.1

// PP.R.2 is not necessary to check
rPP_R_3_NP_R_3 @= { @ "PP.R.3_NP.R.3 : OD must be fully covered by PP and NP, except OD without interacting CO OR PO";
    sLAYER_68 = interacting( OD, POLYI ); 
    sLAYER_67 = sLAYER_68 not ODWR; 
    sLAYER_66 = sLAYER_67 not SBDDMY; 
    sLAYER_66 not IMP; 
    sLAYER_71 = interacting( OD, COI ); 
    sLAYER_70 = sLAYER_71 not ODWR; 
    sLAYER_69 = sLAYER_70 not SBDDMY; 
    sLAYER_69 not IMP; 
} /* end of rule : PP.R.3_NP.R.3 */

// NP CHECKS
//============
rNP_W_1 @= { @ "NP.W.1 : NP width < " + NP_W_1; 
    internal1( gNP, < NP_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : NP.W.1 */
rNP_S_1 @= { @ "NP.S.1 : NP space < " + NP_S_1; 
    external1( gNP, < NP_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : NP.S.1 */
rNP_C_1 @= { @ "NP.C.1 : NP space to p active in NWEL < " + NP_C_1; 

  // P active in NWEL can be butting or non-butting.
  // The non-butting P active is not allowed to touch NP.
    external2( gNP, PACT, < NP_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
    X = external2_edge( gNP, PACT, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = COINCIDENT, output_layer = LAYER2 ); 
    Y = edge_size( X, outside = 0.001 ); 
    not_interacting( Y, NPOD ); 
} /* end of rule : NP.C.1 */
rNP_C_2 @= { @ "NP.C.2 : NP space to non-butting ptap < 0.1 with NWEL space >= 0.43";
    external2( gNP, PTAP, < 0.1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
} /* end of rule : NP.C.2 */
rNP_C_3 @= { @ "NP.C.3 : NP space to non-butting ptap < 0.18 with NWEL space < 0.43";
    and_edge( NPC3_CHECKOD, PPE4_NWELC, false ); 
} /* end of rule : NP.C.3 */

// NP.C.4 is checked by PP.C.5 and PP.R.1_NP.R.1
rNP_C_5 @= { @ "NP.C.5 : NP extension over (N gate) + (field poly within 0.35um) < " + NP_C_5 + " um"; 

  // This rule must extend out of gate in the direction of PO by 0.35um
    EXGATE_NP not gNP; 
} /* end of rule : NP.C.5 */
rNP_O_1 @= { @ "NP.O.1 : NP extends into n active < 0.230";
    internal2( OD, gNP, < 0.23, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = RELATED_COINCIDENT, relational = { POINT_TOUCH } ); 
} /* end of rule : NP.O.1 */
rNP_E_1 @= { @ "NP.E.1 : NP olap OD < " + NP_E_1 + " except SEALRING region"; 
    X = NACT not ODWR; 
    sLAYER_72 = enclose( X, gNP, < NP_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
    not_interacting( sLAYER_72, SEALRING_ALL ); 
    Y = enclose_edge( X, gNP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
    Z = edge_size( Y, outside = 0.001 ); 
    sLAYER_73 = not_interacting( Z, PPOD ); 
    not_interacting( sLAYER_73, SEALRING_ALL ); 
} /* end of rule : NP.E.1 */
rNP_E_3 @= { @ "NP.E.3 : Minimum enclosure of NTAP by NP < 0.02 with PWEL space >= 0.43";
    enclose( NTAP, gNP, < 0.02, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
    X = enclose_edge( NTAP, gNP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
    Y = edge_size( X, outside = 0.001 ); 
    not_interacting( Y, PPOD ); 
} /* end of rule : NP.E.3 */
rNP_E_4 @= { @ "NP.E.4 : Min. enc. of NTAP by NP < 0.18 with PWEL space < 0.43";
    not_edge( NPE4_CHECKOD, NPE4_NWELC, coincident = false ); 
} /* end of rule : NP.E.4 */

// NP.C.6 is not checked by drc
// NP.E.5 is not checked by drc
rNP_A_1 @= { @ "NP.A.1 : Minimum area of NP < 0.3844";
    area( gNP, < 0.3844 );
} /* end of rule : NP.A.1 */
rNP_E_6 @= { @ "NP.E.6 : Min enc of POLY resistor by NP < 0.18";
    enclose( PORES, gNP, < 0.18, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : NP.E.6 */

// NP.R.2 is not necessary to check

// RPO checks
//===========
CB_HOLE = donut_holes( CB, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
CB_SR = outside_touching( CB, CB_HOLE, == 1 ); 
RPO_NOT_SR = not_interacting( RPO, CB_SR ); 
rRPO_W_1 @= { @ "RPO.W.1 : Minimum RPO width < 0.43";
    internal1( RPO, < 0.43, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : RPO.W.1 */
rRPO_S_1 @= { @ "RPO.S.1 : Minimum RPO space < " + RPO_S_1; 
    external1( RPO, < RPO_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : RPO.S.1 */
rRPO_C_1 @= { @ "RPO.C.1 : Minimum RPO space to OD < 0.22 except SEALRING region";
    sLAYER_74 = external2( RPO, OD, < 0.22, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    not_interacting( sLAYER_74, SEALRING_ALL ); 
} /* end of rule : RPO.C.1 */
rRPO_C_2 @= { @ "RPO.C.2 : Minimum RPO space to CO < " + RPO_C_2; 
    external2( RPO, CO, < RPO_C_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    CO and RPO; 
} /* end of rule : RPO.C.2 */
rRPO_C_3 @= { @ "RPO.C.3 : Minimum RPO space to gate < 0.45 "
                          "exclude ESD part";
    sLAYER_78 = ALL_GATE not DRCDMY; 
    sLAYER_77 = sLAYER_78 not ESD1DMY; 
    sLAYER_76 = sLAYER_77 not ESD2DMY; 
    sLAYER_75 = sLAYER_76 not ESD3DMY; 
    A = sLAYER_75 not SDI; 
    external2( RPO, A, < 0.45, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    RPO and A; 
} /* end of rule : RPO.C.3 */
rRPO_C_4 @= { @ "RPO.C.4 : Minimum RPO overhang OD < 0.22";
    sLAYER_79 = enclose( OD, RPO, < 0.22, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    not_interacting( sLAYER_79, SEALRING_ALL ); 
    RPO_NOT_SR inside OD; 
} /* end of rule : RPO.C.4 */
rRPO_E_1 @= { @ "RPO.E.1 : Minimum OD overhang RPO < 0.22";
    sLAYER_80 = enclose( RPO, OD, < 0.22, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    not_interacting( sLAYER_80, SEALRING_ALL ); 
} /* end of rule : RPO.E.1 */
rRPO_C_5 @= { @ "RPO.C.5 : Minimum RPO overhang POLY < 0.22";
    enclose( POLY, RPO, < 0.22, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    RPO_NOT_SR inside POLY; 
} /* end of rule : RPO.C.5 */
rRPO_C_6 @= { @ "RPO.C.6 : Minimum clearance RPO to unrelated poly < 0.3um";
    external2( RPO, POLY_ISO, < 0.3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : RPO.C.6 */
rRPO_A_1 @= { @ "RPO.A.1 : RPO min. area < 2 um*um";
    area( RPO, < 2 ); 
} /* end of rule : RPO.A.1 */
rRPO_A_2 @= { @ "RPO.A.2 : Enclosed Area >= " + RPO_A_2 + " um2"; 
    A = donut_holes( RPO, area = < RPO_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
    B = A not RPO; 
    area( B, < RPO_A_2 ); 
} /* end of rule : RPO.A.2 */

// CO checks
//===============
rCO_W_1 @= { @ "CO.W.1 : contact width != 0.22";
    X = CO not SR_CO; 
    not_rectangles( X, orientation = ORTHOGONAL, sides = { == 0.22, == 0.22 } ); 
} /* end of rule : CO.W.1 */
rCO_S_1 @= { @ "CO.S.1 : contact spacing < 0.25";
    external1( CO, < 0.25, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : CO.S.1 */
rCO_S_2 @= { @ "CO.S.2 : Min space between two contacts in larger than 4x4 array.";
    A = size( size( CO, 0.30 / 2, clip_acute = NONE ), - ( 0.30 / 2 ), clip_acute = NONE );    /* space < 0.3um treat as array */ 
    B = size( size( A, - 0.7, clip_acute = NONE ), 0.7, clip_acute = NONE );    /* (0.22*3+0.3*2) = 1.26  (3 COs Mix.) */ 
    C = interacting( B, CO, >= 16 );     /* 1.63-0.22 = 1.41       (Max. CO shift space)  */ 
    D = interacting( CO, C );            /* so 1.26 < CONTY width < 1.41 */ 
    external1_error( D, < 0.28, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT );    /* & we use CONTY width = 1.4 */ 
} /* end of rule : CO.S.2 */
rCO_C_1_CO_R_1 @= { @ "CO.C.1_CO.R.1 : diff contact to gate space < 0.16, or contact on gate";
    external2( CO_DIFF, ALL_GATE, < 0.16, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    CO_DIFF and ALL_GATE; 
} /* end of rule : CO.C.1_CO.R.1 */
rCO_C_2 @= { @ "CO.C.2 : poly contact space to OD < 0.20";
    external2( CO_POLY, OD, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : CO.C.2 */
rCO_E_1 @= { @ "CO.E.1 : active olap contact < 0.10, also floating contacts";
    enclose( CO_DIFF, OD, < 0.1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    not_edge( CO_DIFF, OD, coincident = false ); 
} /* end of rule : CO.E.1 */
rCO_E_2 @= { @ "CO.E.2 : poly olap contact < 0.10";
    enclose( CO_POLY, POLY_ISO, < 0.1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    cutting( CO_POLY, POLY_ISO ); 
} /* end of rule : CO.E.2 */
rCO_E_3 @= { @ "CO.E.3 : Minimum extension of a PP region beyond a OD CO region must >= " + CO_E_3 + " um except SBD region"; 
    enclose( CO_DIFF, PP_NSBD, < CO_E_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    and_edge( PP_NSBD, CO_DIFF, false ); 
} /* end of rule : CO.E.3 */
rCO_E_4 @= { @ "CO.E.4 : implant olap contact < " + CO_E_4; 
    enclose( CO_DIFF, gNP, < CO_E_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    and_edge( gNP, CO_DIFF, false ); 
} /* end of rule : CO.E.4 */

// CO.R.2 is checked by CO.E.3/CO.E.4
// CO.R.3 is checked by RPO.C.2
rCO_R_4 @= { @ "CO.R.4 : CO and {PO INTERACT(RPDMY(54;0) OR RPDMY(drawing1)(54;1) OR RLPPDMY)} must be fully covered by {NP OR PP}";
    sLAYER_82 = RPDUMMY or RLPPDMY; 
    sLAYER_81 = interacting( POLY, sLAYER_82 ); 
    A = CO and sLAYER_81; 
    sLAYER_83 = gNP or PP; 
    A not sLAYER_83; 
} /* end of rule : CO.R.4 */

// M1 checks
//=============
rM1_W_1 @= { @ "M1.W.1 : Min. M1 width < 0.23";
    internal1( M1, < 0.23, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : M1.W.1 */
rM1_S_1 @= { @ "M1.S.1 : Min. M1 space < 0.23";
    external1( M1, < 0.23, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : M1.S.1 */
rM1_S_2 @= { @ "M1.S.2 : Min. space to wide M1 (>10um) < " + M1_S_2; 
    sLAYER_86 = shrink( M1, east = 5 ); 
    sLAYER_85 = shrink( sLAYER_86, west = 5 );
    sLAYER_84 = shrink( sLAYER_85, north = 5 );
    M1_S5 = shrink( sLAYER_84, south = 5 ); 
    sLAYER_89 = grow( M1_S5, east = 5 ); 
    sLAYER_88 = grow( sLAYER_89, west = 5 );
    sLAYER_87 = grow( sLAYER_88, north = 5 );
    M1_G5 = grow( sLAYER_87, south = 5 ); 
    M1_WIDE = M1_G5 and M1; 
    M1_EXP = size_inside_wrapper( M1_WIDE, M1, distance = 1, increment = 0.161 ); 
    M1_BRANCH = M1_EXP not M1_WIDE; 
    M1_BRANCH_EDGE = M1_BRANCH coincident_inside_edge M1; 
    sLAYER_90 = size( M1_EXP, clip_acute = NONE, distance = M1_S_2 ); 
    M1_CHECK = M1 and sLAYER_90; 
    sLAYER_91 = edge_size( M1_BRANCH_EDGE, corner_extension = INTERSECTION, outside = M1_S_2 ); 
    M1_BRANCH_CHECK = M1 and sLAYER_91; 
    M1_WIDEC = stamp( M1_WIDE, M1XD, CONNECT_DB, CONNECT_DB_M1_S_2, include_touch = NONE ); 
    M1_CHECKC = stamp( M1_CHECK, M1XD, CONNECT_DB_M1_S_2, CONNECT_DB_M1_S_2, include_touch = NONE ); 
    M1_BRANCHC = stamp( M1_BRANCH, M1XD, CONNECT_DB_M1_S_2, CONNECT_DB_M1_S_2, include_touch = NONE ); 
    M1_BRANCH_CHECKC = stamp( M1_BRANCH_CHECK, M1XD, CONNECT_DB_M1_S_2, CONNECT_DB_M1_S_2, include_touch = NONE ); 
    external2( M1_WIDEC, M1_CHECKC, < M1_S_2, connect_sequence = CONNECT_DB_M1_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
    external2( M1_BRANCHC, M1_BRANCH_CHECKC, < M1_S_2, connect_sequence = CONNECT_DB_M1_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
} /* end of rule : M1.S.2 */
rM1_S_2_1_A @= { @ "M1.S.2.1.a : Min. space betweem wide metal and small piece of metal with parallel run length >= " + M1_S_2_L + " and same connection >=" + M1_S_2_1 + " um"; 
    sLAYER_94 = shrink( M1, east = 5 ); 
    sLAYER_93 = shrink( sLAYER_94, west = 5 );
    sLAYER_92 = shrink( sLAYER_93, north = 5 );
    M1_S5 = shrink( sLAYER_92, south = 5 ); 
    sLAYER_97 = grow( M1_S5, east = 5 ); 
    sLAYER_96 = grow( sLAYER_97, west = 5 );
    sLAYER_95 = grow( sLAYER_96, north = 5 );
    M1_G5 = grow( sLAYER_95, south = 5 ); 
    M1_WIDE = M1_G5 and M1; 
    M1_SMALL = M1 not M1_WIDE; 
    M1_WIDEC = stamp( M1_WIDE, M1XD, CONNECT_DB, CONNECT_DB_M1_S_2_1_A, include_touch = NONE ); 
    M1_SMALLC = stamp( M1_SMALL, M1XD, CONNECT_DB_M1_S_2_1_A, CONNECT_DB_M1_S_2_1_A, include_touch = NONE ); 
    M1_S_REG = external2( M1_WIDEC, M1_SMALLC, < M1_S_2_1, connect_sequence = CONNECT_DB_M1_S_2_1_A, connectivity = SAME_NET, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    M1_S_REG_CHECK = contains( M1_S_REG, { GRID, M1_S_2_L }, FORTY_FIVE ); 
    WIDEEDGE1 = M1_S_REG_CHECK coincident_outside_edge M1_WIDE; 
    M1_SMALL_EDGE = M1_SMALL coincident_inside_edge M1; 
    WIDEEDGE2 = M1_S_REG_CHECK coincident_outside_edge M1_SMALL_EDGE; 
    length_edge( WIDEEDGE1, >= M1_S_2_L, CONNECT ); 
    length_edge( WIDEEDGE2, >= M1_S_2_L, CONNECT ); 
} /* end of rule : M1.S.2.1.a */
rM1_S_2_1_B @= { @ "M1.S.2.1.b : Min. space between two wide metals with parallel run length >= " + M1_S_2_L + " and same connection >=" + M1_S_2_2 + " um"; 
    sLAYER_100 = shrink( M1, east = 5 ); 
    sLAYER_99 = shrink( sLAYER_100, west = 5 );
    sLAYER_98 = shrink( sLAYER_99, north = 5 );
    M1_S5 = shrink( sLAYER_98, south = 5 ); 
    sLAYER_103 = grow( M1_S5, east = 5 ); 
    sLAYER_102 = grow( sLAYER_103, west = 5 );
    sLAYER_101 = grow( sLAYER_102, north = 5 );
    M1_G5 = grow( sLAYER_101, south = 5 ); 
    M1_WIDE = M1_G5 and M1; 
    M1_WIDEC = stamp( M1_WIDE, M1XD, CONNECT_DB, CONNECT_DB_M1_S_2_1_B, include_touch = NONE ); 
    M1_S_REG = external1( M1_WIDEC, < M1_S_2_2, connect_sequence = CONNECT_DB_M1_S_2_1_B, connectivity = SAME_NET, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    M1_S_REG_CHECK = contains( M1_S_REG, { GRID, M1_S_2_L }, FORTY_FIVE ); 
    WIDEEDGE = M1_S_REG_CHECK coincident_outside_edge M1_WIDE; 
    length_edge( WIDEEDGE, >= M1_S_2_L, CONNECT ); 
} /* end of rule : M1.S.2.1.b */
rM1_E_1 @= { @ "M1.E.1 : Min. extension of a M1 region beyond a CO region < 0.005";
    enclose( CO, M1, < 0.005, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    CO not M1; 
} /* end of rule : M1.E.1 */
rM1_E_2 @= { @ "M1.E.2 : Min. extension of M1 end-of-line region beyond CO region < 0.06";
    X = enclose_edge( CO, M1, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
    internal1_error( X, < 0.22, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
} /* end of rule : M1.E.2 */
rM1_A_1 @= { @ "M1.A.1 : Min. M1 area < " + M1_A_1; 
    area( M1_A, < M1_A_1 ); 
} /* end of rule : M1.A.1 */

// Density check M1.R.1 included at the end of this file

// VIA1 checks
//=============
VIA1_CORE = VIA1 not SR_VIA1; 
rVIA1_W_1 @= { @ "VIA1.W.1 : VIA1 must be 0.26 x 0.26";
    A = not_rectangles( VIA1_CORE, orientation = ORTHOGONAL, sides = { == 0.26, == 0.26 } ); 
    A outside RNGX;                       /* exclude from metal fuse protection ring area */ 
} /* end of rule : VIA1.W.1 */
rVIA1_S_1 @= { @ "VIA1.S.1 : Min. VIA1 space < 0.26";
    external1( VIA1, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : VIA1.S.1 */
rVIA1_E_1 @= { @ "VIA1.E.1 : Min. extension of a M1 region beyond a VIA1 region < 0.01";
    enclose( VIA1, M1, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    VIA1 not M1; 
} /* end of rule : VIA1.E.1 */
rVIA1_E_2 @= { @ "VIA1.E.2 : Min. extension of M1 end-of-line region beyond VIA1 region < 0.06";
    X = enclose_edge( VIA1, M1, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
    internal1_error( X, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
} /* end of rule : VIA1.E.2 */

// M2 checks
//=============
rM2_W_1 @= { @ "M2.W.1 : Min. M2 width < 0.28";
    internal1( M2, < 0.28, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : M2.W.1 */
rM2_S_1 @= { @ "M2.S.1 : Min. M2 space < 0.28";
    external1( M2, < 0.28, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : M2.S.1 */
rM2_S_2 @= { @ "M2.S.2 : Min. space to wide M2 (>10um) < 0.6";
    sLAYER_106 = shrink( M2, east = 5 ); 
    sLAYER_105 = shrink( sLAYER_106, west = 5 );
    sLAYER_104 = shrink( sLAYER_105, north = 5 );
    M2_S5 = shrink( sLAYER_104, south = 5 ); 
    sLAYER_109 = grow( M2_S5, east = 5 ); 
    sLAYER_108 = grow( sLAYER_109, west = 5 );
    sLAYER_107 = grow( sLAYER_108, north = 5 );
    M2_G5 = grow( sLAYER_107, south = 5 ); 
    M2_WIDE = M2_G5 and M2; 
    M2_EXP = size_inside_wrapper( M2_WIDE, M2, distance = 1, increment = 0.196 ); 
    M2_BRANCH = M2_EXP not M2_WIDE; 
    M2_BRANCH_EDGE = M2_BRANCH coincident_inside_edge M2; 
    sLAYER_110 = size( M2_EXP, clip_acute = NONE, distance = 0.6 ); 
    M2_CHECK = M2 and sLAYER_110; 
    sLAYER_111 = edge_size( M2_BRANCH_EDGE, corner_extension = INTERSECTION, outside = 0.6 ); 
    M2_BRANCH_CHECK = M2 and sLAYER_111; 
    M2_WIDEC = stamp( M2_WIDE, M2XD, CONNECT_DB, CONNECT_DB_M2_S_2, include_touch = NONE ); 
    M2_CHECKC = stamp( M2_CHECK, M2XD, CONNECT_DB_M2_S_2, CONNECT_DB_M2_S_2, include_touch = NONE ); 
    M2_BRANCHC = stamp( M2_BRANCH, M2XD, CONNECT_DB_M2_S_2, CONNECT_DB_M2_S_2, include_touch = NONE ); 
    M2_BRANCH_CHECKC = stamp( M2_BRANCH_CHECK, M2XD, CONNECT_DB_M2_S_2, CONNECT_DB_M2_S_2, include_touch = NONE ); 
    external2( M2_WIDEC, M2_CHECKC, < 0.6, connect_sequence = CONNECT_DB_M2_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
    external2( M2_BRANCHC, M2_BRANCH_CHECKC, < 0.6, connect_sequence = CONNECT_DB_M2_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
} /* end of rule : M2.S.2 */
rM2_S_2_1_A @= { @ "M2.S.2.1.a : Min. space betweem wide metal and small piece of metal with parallel run length >= " + M2_S_2_L + " and same connection >=" + M2_S_2_1 + " um"; 
    sLAYER_114 = shrink( M2, east = 5 ); 
    sLAYER_113 = shrink( sLAYER_114, west = 5 );
    sLAYER_112 = shrink( sLAYER_113, north = 5 );
    M2_S5 = shrink( sLAYER_112, south = 5 ); 
    sLAYER_117 = grow( M2_S5, east = 5 ); 
    sLAYER_116 = grow( sLAYER_117, west = 5 );
    sLAYER_115 = grow( sLAYER_116, north = 5 );
    M2_G5 = grow( sLAYER_115, south = 5 ); 
    M2_WIDE = M2_G5 and M2; 
    M2_SMALL = M2 not M2_WIDE; 
    M2_WIDEC = stamp( M2_WIDE, M2XD, CONNECT_DB, CONNECT_DB_M2_S_2_1_A, include_touch = NONE ); 
    M2_SMALLC = stamp( M2_SMALL, M2XD, CONNECT_DB_M2_S_2_1_A, CONNECT_DB_M2_S_2_1_A, include_touch = NONE ); 
    M2_S_REG = external2( M2_WIDEC, M2_SMALLC, < M2_S_2_1, connect_sequence = CONNECT_DB_M2_S_2_1_A, connectivity = SAME_NET, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    M2_S_REG_CHECK = contains( M2_S_REG, { GRID, M2_S_2_L }, FORTY_FIVE ); 
    WIDEEDGE1 = M2_S_REG_CHECK coincident_outside_edge M2_WIDE; 
    M2_SMALL_EDGE = M2_SMALL coincident_inside_edge M2; 
    WIDEEDGE2 = M2_S_REG_CHECK coincident_outside_edge M2_SMALL_EDGE; 
    length_edge( WIDEEDGE1, >= M2_S_2_L, CONNECT ); 
    length_edge( WIDEEDGE2, >= M2_S_2_L, CONNECT ); 
} /* end of rule : M2.S.2.1.a */
rM2_S_2_1_B @= { @ "M2.S.2.1.b : Min. space between two wide metals with parallel run length >= " + M2_S_2_L + " and same connection >=" + M2_S_2_2 + " um"; 
    sLAYER_120 = shrink( M2, east = 5 ); 
    sLAYER_119 = shrink( sLAYER_120, west = 5 );
    sLAYER_118 = shrink( sLAYER_119, north = 5 );
    M2_S5 = shrink( sLAYER_118, south = 5 ); 
    sLAYER_123 = grow( M2_S5, east = 5 ); 
    sLAYER_122 = grow( sLAYER_123, west = 5 );
    sLAYER_121 = grow( sLAYER_122, north = 5 );
    M2_G5 = grow( sLAYER_121, south = 5 ); 
    M2_WIDE = M2_G5 and M2; 
    M2_WIDEC = stamp( M2_WIDE, M2XD, CONNECT_DB, CONNECT_DB_M2_S_2_1_B, include_touch = NONE ); 
    M2_S_REG = external1( M2_WIDEC, < M2_S_2_2, connect_sequence = CONNECT_DB_M2_S_2_1_B, connectivity = SAME_NET, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    M2_S_REG_CHECK = contains( M2_S_REG, { GRID, M2_S_2_L }, FORTY_FIVE ); 
    WIDEEDGE = M2_S_REG_CHECK coincident_outside_edge M2_WIDE; 
    length_edge( WIDEEDGE, >= M2_S_2_L, CONNECT ); 
} /* end of rule : M2.S.2.1.b */
rM2_E_1 @= { @ "M2.E.1 : Min. extension of a M2 region beyond a VIA1 region < 0.01";
    enclose( VIA1, M2, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    VIA1 not M2; 
} /* end of rule : M2.E.1 */
rM2_E_2 @= { @ "M2.E.2 : Min. extension of M2 end-of-line region beyond VIA1 region < 0.06";
    X = enclose_edge( VIA1, M2, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
    internal1_error( X, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
} /* end of rule : M2.E.2 */
rM2_A_1 @= { @ "M2.A.1 : Min M2 area region < " + MX_A_1; 
    area( M2, < MX_A_1 ); 
} /* end of rule : M2.A.1 */

// Density check M2.R.1 included at the end of this file

// VIA2 checks
//=============
VIA2_CORE = VIA2 not SR_VIA2; 
rVIA2_W_1 @= { @ "VIA2.W.1 : VIA2 must be 0.26 x 0.26";
    A = not_rectangles( VIA2_CORE, orientation = ORTHOGONAL, sides = { == 0.26, == 0.26 } ); 
    A outside RNGX;                       /* exclude from metal fuse protection ring area */ 
} /* end of rule : VIA2.W.1 */
rVIA2_S_1 @= { @ "VIA2.S.1 : Min. VIA2 space < 0.26";
    external1( VIA2, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : VIA2.S.1 */
rVIA2_E_1 @= { @ "VIA2.E.1 : Min. extension of a M2 region beyond a VIA2 region < 0.01";
    enclose( VIA2, M2, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    VIA2 not M2; 
} /* end of rule : VIA2.E.1 */
rVIA2_E_2 @= { @ "VIA2.E.2 : Min. extension of M2 end-of-line region beyond VIA2 region < 0.06";
    X = enclose_edge( VIA2, M2, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
    internal1_error( X, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
} /* end of rule : VIA2.E.2 */
#ifdef RECOMMEND 
   rVIA2_E_3 @= { @ "VIA2.E.3 : Minimum extension of M2 beyond the overlap area that VIA2 and VIA1 are fully or partially touching < " + VIA2_E_3; 
       X = VIA2 and VIA1; 
       enclose( X, M2, < VIA2_E_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
   } /* end of rule : VIA2.E.3 */
#endif /* end of #ifdef RECOMMEND  */ 

// M3 checks
//=============
rM3_W_1 @= { @ "M3.W.1 : Min. M3 width < 0.28";
    internal1( M3, < 0.28, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : M3.W.1 */
rM3_S_1 @= { @ "M3.S.1 : Min. M3 space < 0.28";
    external1( M3, < 0.28, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : M3.S.1 */
rM3_S_2 @= { @ "M3.S.2 : Min. space to wide M3 (>10um) < 0.6";
    sLAYER_126 = shrink( M3, east = 5 ); 
    sLAYER_125 = shrink( sLAYER_126, west = 5 );
    sLAYER_124 = shrink( sLAYER_125, north = 5 );
    M3_S5 = shrink( sLAYER_124, south = 5 ); 
    sLAYER_129 = grow( M3_S5, east = 5 ); 
    sLAYER_128 = grow( sLAYER_129, west = 5 );
    sLAYER_127 = grow( sLAYER_128, north = 5 );
    M3_G5 = grow( sLAYER_127, south = 5 ); 
    M3_WIDE = M3_G5 and M3; 
    M3_EXP = size_inside_wrapper( M3_WIDE, M3, distance = 1, increment = 0.196 ); 
    M3_BRANCH = M3_EXP not M3_WIDE; 
    M3_BRANCH_EDGE = M3_BRANCH coincident_inside_edge M3; 
    sLAYER_130 = size( M3_EXP, clip_acute = NONE, distance = 0.6 ); 
    M3_CHECK = M3 and sLAYER_130; 
    sLAYER_131 = edge_size( M3_BRANCH_EDGE, corner_extension = INTERSECTION, outside = 0.6 ); 
    M3_BRANCH_CHECK = M3 and sLAYER_131; 
    M3_WIDEC = stamp( M3_WIDE, M3XD, CONNECT_DB, CONNECT_DB_M3_S_2, include_touch = NONE ); 
    M3_CHECKC = stamp( M3_CHECK, M3XD, CONNECT_DB_M3_S_2, CONNECT_DB_M3_S_2, include_touch = NONE ); 
    M3_BRANCHC = stamp( M3_BRANCH, M3XD, CONNECT_DB_M3_S_2, CONNECT_DB_M3_S_2, include_touch = NONE ); 
    M3_BRANCH_CHECKC = stamp( M3_BRANCH_CHECK, M3XD, CONNECT_DB_M3_S_2, CONNECT_DB_M3_S_2, include_touch = NONE ); 
    external2( M3_WIDEC, M3_CHECKC, < 0.6, connect_sequence = CONNECT_DB_M3_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
    external2( M3_BRANCHC, M3_BRANCH_CHECKC, < 0.6, connect_sequence = CONNECT_DB_M3_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
} /* end of rule : M3.S.2 */
rM3_S_2_1_A @= { @ "M3.S.2.1.a : Min. space betweem wide metal and small piece of metal with parallel run length >= " + M3_S_2_L + " and same connection >=" + M3_S_2_1 + " um"; 
    sLAYER_134 = shrink( M3, east = 5 ); 
    sLAYER_133 = shrink( sLAYER_134, west = 5 );
    sLAYER_132 = shrink( sLAYER_133, north = 5 );
    M3_S5 = shrink( sLAYER_132, south = 5 ); 
    sLAYER_137 = grow( M3_S5, east = 5 ); 
    sLAYER_136 = grow( sLAYER_137, west = 5 );
    sLAYER_135 = grow( sLAYER_136, north = 5 );
    M3_G5 = grow( sLAYER_135, south = 5 ); 
    M3_WIDE = M3_G5 and M3; 
    M3_SMALL = M3 not M3_WIDE; 
    M3_WIDEC = stamp( M3_WIDE, M3XD, CONNECT_DB, CONNECT_DB_M3_S_2_1_A, include_touch = NONE ); 
    M3_SMALLC = stamp( M3_SMALL, M3XD, CONNECT_DB_M3_S_2_1_A, CONNECT_DB_M3_S_2_1_A, include_touch = NONE ); 
    M3_S_REG = external2( M3_WIDEC, M3_SMALLC, < M3_S_2_1, connect_sequence = CONNECT_DB_M3_S_2_1_A, connectivity = SAME_NET, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    M3_S_REG_CHECK = contains( M3_S_REG, { GRID, M3_S_2_L }, FORTY_FIVE ); 
    WIDEEDGE1 = M3_S_REG_CHECK coincident_outside_edge M3_WIDE; 
    M3_SMALL_EDGE = M3_SMALL coincident_inside_edge M3; 
    WIDEEDGE2 = M3_S_REG_CHECK coincident_outside_edge M3_SMALL_EDGE; 
    length_edge( WIDEEDGE1, >= M3_S_2_L, CONNECT ); 
    length_edge( WIDEEDGE2, >= M3_S_2_L, CONNECT ); 
} /* end of rule : M3.S.2.1.a */
rM3_S_2_1_B @= { @ "M3.S.2.1.b : Min. space between two wide metals with parallel run length >= " + M3_S_2_L + " and same connection >=" + M3_S_2_2 + " um"; 
    sLAYER_140 = shrink( M3, east = 5 ); 
    sLAYER_139 = shrink( sLAYER_140, west = 5 );
    sLAYER_138 = shrink( sLAYER_139, north = 5 );
    M3_S5 = shrink( sLAYER_138, south = 5 ); 
    sLAYER_143 = grow( M3_S5, east = 5 ); 
    sLAYER_142 = grow( sLAYER_143, west = 5 );
    sLAYER_141 = grow( sLAYER_142, north = 5 );
    M3_G5 = grow( sLAYER_141, south = 5 ); 
    M3_WIDE = M3_G5 and M3; 
    M3_WIDEC = stamp( M3_WIDE, M3XD, CONNECT_DB, CONNECT_DB_M3_S_2_1_B, include_touch = NONE ); 
    M3_S_REG = external1( M3_WIDEC, < M3_S_2_2, connect_sequence = CONNECT_DB_M3_S_2_1_B, connectivity = SAME_NET, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    M3_S_REG_CHECK = contains( M3_S_REG, { GRID, M3_S_2_L }, FORTY_FIVE ); 
    WIDEEDGE = M3_S_REG_CHECK coincident_outside_edge M3_WIDE; 
    length_edge( WIDEEDGE, >= M3_S_2_L, CONNECT ); 
} /* end of rule : M3.S.2.1.b */
rM3_E_1 @= { @ "M3.E.1 : Min. extension of a M3 region beyond a VIA2 region < 0.01";
    enclose( VIA2, M3, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    VIA2 not M3; 
} /* end of rule : M3.E.1 */
rM3_E_2 @= { @ "M3.E.2 : Min. extension of M3 end-of-line region beyond VIA2 region < 0.06";
    X = enclose_edge( VIA2, M3, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
    internal1_error( X, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
} /* end of rule : M3.E.2 */
rM3_A_1 @= { @ "M3.A.1 : Min M3 area region < " + MX_A_1; 
    area( M3, < MX_A_1 ); 
} /* end of rule : M3.A.1 */

// Density check M3.R.1 included at the end of this file

// VIA3 checks
//=============
VIA3_CORE = VIA3 not SR_VIA3; 
rVIA3_W_1 @= { @ "VIA3.W.1 : VIA3 must be 0.26 x 0.26";
    A = not_rectangles( VIA3_CORE, orientation = ORTHOGONAL, sides = { == 0.26, == 0.26 } ); 
    A outside RNGX;                       /* exclude from metal fuse protection ring area */ 
} /* end of rule : VIA3.W.1 */
rVIA3_S_1 @= { @ "VIA3.S.1 : Min. VIA3 space < 0.26";
    external1( VIA3, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : VIA3.S.1 */
rVIA3_E_1 @= { @ "VIA3.E.1 : Min. extension of a M3 region beyond a VIA3 region < 0.01";
    enclose( VIA3, M3, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    VIA3 not M3; 
} /* end of rule : VIA3.E.1 */
rVIA3_E_2 @= { @ "VIA3.E.2 : Min. extension of M3 end-of-line region beyond VIA3 region < 0.06";
    X = enclose_edge( VIA3, M3, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
    internal1_error( X, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
} /* end of rule : VIA3.E.2 */
#ifdef RECOMMEND 
   rVIA3_E_3 @= { @ "VIA3.E.3 : Minimum extension of M3 beyond the overlap area that VIA3 and VIA2 are fully or partially touching < " + VIA3_E_3; 
       X = VIA3 and VIA2; 
       enclose( X, M3, < VIA3_E_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
   } /* end of rule : VIA3.E.3 */
#endif /* end of #ifdef RECOMMEND  */ 

// M4 checks
//=============
rM4_W_1 @= { @ "M4.W.1 : Min. M4 width < 0.28";
    internal1( M4, < 0.28, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : M4.W.1 */
rM4_S_1 @= { @ "M4.S.1 : Min. M4 space < 0.28";
    external1( M4, < 0.28, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : M4.S.1 */
rM4_S_2 @= { @ "M4.S.2 : Min. space to wide M4 (>10um) < 0.6";
    sLAYER_146 = shrink( M4, east = 5 ); 
    sLAYER_145 = shrink( sLAYER_146, west = 5 );
    sLAYER_144 = shrink( sLAYER_145, north = 5 );
    M4_S5 = shrink( sLAYER_144, south = 5 ); 
    sLAYER_149 = grow( M4_S5, east = 5 ); 
    sLAYER_148 = grow( sLAYER_149, west = 5 );
    sLAYER_147 = grow( sLAYER_148, north = 5 );
    M4_G5 = grow( sLAYER_147, south = 5 ); 
    M4_WIDE = M4_G5 and M4; 
    M4_EXP = size_inside_wrapper( M4_WIDE, M4, distance = 1, increment = 0.196 ); 
    M4_BRANCH = M4_EXP not M4_WIDE; 
    M4_BRANCH_EDGE = M4_BRANCH coincident_inside_edge M4; 
    sLAYER_150 = size( M4_EXP, clip_acute = NONE, distance = 0.6 ); 
    M4_CHECK = M4 and sLAYER_150; 
    sLAYER_151 = edge_size( M4_BRANCH_EDGE, corner_extension = INTERSECTION, outside = 0.6 ); 
    M4_BRANCH_CHECK = M4 and sLAYER_151; 
    M4_WIDEC = stamp( M4_WIDE, M4XD, CONNECT_DB, CONNECT_DB_M4_S_2, include_touch = NONE ); 
    M4_CHECKC = stamp( M4_CHECK, M4XD, CONNECT_DB_M4_S_2, CONNECT_DB_M4_S_2, include_touch = NONE ); 
    M4_BRANCHC = stamp( M4_BRANCH, M4XD, CONNECT_DB_M4_S_2, CONNECT_DB_M4_S_2, include_touch = NONE ); 
    M4_BRANCH_CHECKC = stamp( M4_BRANCH_CHECK, M4XD, CONNECT_DB_M4_S_2, CONNECT_DB_M4_S_2, include_touch = NONE ); 
    external2( M4_WIDEC, M4_CHECKC, < 0.6, connect_sequence = CONNECT_DB_M4_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
    external2( M4_BRANCHC, M4_BRANCH_CHECKC, < 0.6, connect_sequence = CONNECT_DB_M4_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
} /* end of rule : M4.S.2 */
rM4_S_2_1_A @= { @ "M4.S.2.1.a : Min. space betweem wide metal and small piece of metal with parallel run length >= " + M4_S_2_L + " and same connection >=" + M4_S_2_1 + " um"; 
    sLAYER_154 = shrink( M4, east = 5 ); 
    sLAYER_153 = shrink( sLAYER_154, west = 5 );
    sLAYER_152 = shrink( sLAYER_153, north = 5 );
    M4_S5 = shrink( sLAYER_152, south = 5 ); 
    sLAYER_157 = grow( M4_S5, east = 5 ); 
    sLAYER_156 = grow( sLAYER_157, west = 5 );
    sLAYER_155 = grow( sLAYER_156, north = 5 );
    M4_G5 = grow( sLAYER_155, south = 5 ); 
    M4_WIDE = M4_G5 and M4; 
    M4_SMALL = M4 not M4_WIDE; 
    M4_WIDEC = stamp( M4_WIDE, M4XD, CONNECT_DB, CONNECT_DB_M4_S_2_1_A, include_touch = NONE ); 
    M4_SMALLC = stamp( M4_SMALL, M4XD, CONNECT_DB_M4_S_2_1_A, CONNECT_DB_M4_S_2_1_A, include_touch = NONE ); 
    M4_S_REG = external2( M4_WIDEC, M4_SMALLC, < M4_S_2_1, connect_sequence = CONNECT_DB_M4_S_2_1_A, connectivity = SAME_NET, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    M4_S_REG_CHECK = contains( M4_S_REG, { GRID, M4_S_2_L }, FORTY_FIVE ); 
    WIDEEDGE1 = M4_S_REG_CHECK coincident_outside_edge M4_WIDE; 
    M4_SMALL_EDGE = M4_SMALL coincident_inside_edge M4; 
    WIDEEDGE2 = M4_S_REG_CHECK coincident_outside_edge M4_SMALL_EDGE; 
    length_edge( WIDEEDGE1, >= M4_S_2_L, CONNECT ); 
    length_edge( WIDEEDGE2, >= M4_S_2_L, CONNECT ); 
} /* end of rule : M4.S.2.1.a */
rM4_S_2_1_B @= { @ "M4.S.2.1.b : Min. space between two wide metals with parallel run length >= " + M4_S_2_L + " and same connection >=" + M4_S_2_2 + " um"; 
    sLAYER_160 = shrink( M4, east = 5 ); 
    sLAYER_159 = shrink( sLAYER_160, west = 5 );
    sLAYER_158 = shrink( sLAYER_159, north = 5 );
    M4_S5 = shrink( sLAYER_158, south = 5 ); 
    sLAYER_163 = grow( M4_S5, east = 5 ); 
    sLAYER_162 = grow( sLAYER_163, west = 5 );
    sLAYER_161 = grow( sLAYER_162, north = 5 );
    M4_G5 = grow( sLAYER_161, south = 5 ); 
    M4_WIDE = M4_G5 and M4; 
    M4_WIDEC = stamp( M4_WIDE, M4XD, CONNECT_DB, CONNECT_DB_M4_S_2_1_B, include_touch = NONE ); 
    M4_S_REG = external1( M4_WIDEC, < M4_S_2_2, connect_sequence = CONNECT_DB_M4_S_2_1_B, connectivity = SAME_NET, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    M4_S_REG_CHECK = contains( M4_S_REG, { GRID, M4_S_2_L }, FORTY_FIVE ); 
    WIDEEDGE = M4_S_REG_CHECK coincident_outside_edge M4_WIDE; 
    length_edge( WIDEEDGE, >= M4_S_2_L, CONNECT ); 
} /* end of rule : M4.S.2.1.b */
rM4_E_1 @= { @ "M4.E.1 : Min. extension of a M4 region beyond a VIA3 region < 0.01";
    enclose( VIA3, M4, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    VIA3 not M4; 
} /* end of rule : M4.E.1 */
rM4_E_2 @= { @ "M4.E.2 : Min. extension of M4 end-of-line region beyond VIA3 region < 0.06";
    X = enclose_edge( VIA3, M4, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
    internal1_error( X, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
} /* end of rule : M4.E.2 */
rM4_A_1 @= { @ "M4.A.1 : Min M4 area region < " + MX_A_1; 
    area( M4, < MX_A_1 ); 
} /* end of rule : M4.A.1 */

// Density check M4.R.1 included at the end of this file

// VIA4 checks
//=============
VIA4_CORE = VIA4 not SR_VIA4; 
rVIA4_W_1 @= { @ "VIA4.W.1 : VIA4 must be 0.26 x 0.26";
    A = not_rectangles( VIA4_CORE, orientation = ORTHOGONAL, sides = { == 0.26, == 0.26 } ); 
    A outside RNGX;                       /* exclude from metal fuse protection ring area */ 
} /* end of rule : VIA4.W.1 */
rVIA4_S_1 @= { @ "VIA4.S.1 : Min. VIA4 space < 0.26";
    external1( VIA4, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : VIA4.S.1 */
rVIA4_E_1 @= { @ "VIA4.E.1 : Min. extension of a M4 region beyond a VIA4 region < 0.01";
    enclose( VIA4, M4, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    VIA4 not M4; 
} /* end of rule : VIA4.E.1 */
rVIA4_E_2 @= { @ "VIA4.E.2 : Min. extension of M4 end-of-line region beyond VIA4 region < 0.06";
    X = enclose_edge( VIA4, M4, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
    internal1_error( X, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
} /* end of rule : VIA4.E.2 */
#ifdef RECOMMEND 
   rVIA4_E_3 @= { @ "VIA4.E.3 : Minimum extension of M4 beyond the overlap area that VIA4 and VIA3 are fully or partially touching < " + VIA4_E_3; 
       X = VIA4 and VIA3; 
       enclose( X, M4, < VIA4_E_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
   } /* end of rule : VIA4.E.3 */
#endif /* end of #ifdef RECOMMEND  */ 

// M5 checks
//=============
rM5_W_1 @= { @ "M5.W.1 : Min. M5 width < 0.28";
    internal1( M5, < 0.28, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : M5.W.1 */
rM5_S_1 @= { @ "M5.S.1 : Min. M5 space < 0.28";
    external1( M5, < 0.28, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : M5.S.1 */
rM5_S_2 @= { @ "M5.S.2 : Min. space to wide M5 (>10um) < 0.6";
    sLAYER_166 = shrink( M5, east = 5 ); 
    sLAYER_165 = shrink( sLAYER_166, west = 5 );
    sLAYER_164 = shrink( sLAYER_165, north = 5 );
    M5_S5 = shrink( sLAYER_164, south = 5 ); 
    sLAYER_169 = grow( M5_S5, east = 5 ); 
    sLAYER_168 = grow( sLAYER_169, west = 5 );
    sLAYER_167 = grow( sLAYER_168, north = 5 );
    M5_G5 = grow( sLAYER_167, south = 5 ); 
    M5_WIDE = M5_G5 and M5; 
    M5_EXP = size_inside_wrapper( M5_WIDE, M5, distance = 1, increment = 0.196 ); 
    M5_BRANCH = M5_EXP not M5_WIDE; 
    M5_BRANCH_EDGE = M5_BRANCH coincident_inside_edge M5; 
    sLAYER_170 = size( M5_EXP, clip_acute = NONE, distance = 0.6 ); 
    M5_CHECK = M5 and sLAYER_170; 
    sLAYER_171 = edge_size( M5_BRANCH_EDGE, corner_extension = INTERSECTION, outside = 0.6 ); 
    M5_BRANCH_CHECK = M5 and sLAYER_171; 
    M5_WIDEC = stamp( M5_WIDE, M5XD, CONNECT_DB, CONNECT_DB_M5_S_2, include_touch = NONE ); 
    M5_CHECKC = stamp( M5_CHECK, M5XD, CONNECT_DB_M5_S_2, CONNECT_DB_M5_S_2, include_touch = NONE ); 
    M5_BRANCHC = stamp( M5_BRANCH, M5XD, CONNECT_DB_M5_S_2, CONNECT_DB_M5_S_2, include_touch = NONE ); 
    M5_BRANCH_CHECKC = stamp( M5_BRANCH_CHECK, M5XD, CONNECT_DB_M5_S_2, CONNECT_DB_M5_S_2, include_touch = NONE ); 
    external2( M5_WIDEC, M5_CHECKC, < 0.6, connect_sequence = CONNECT_DB_M5_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
    external2( M5_BRANCHC, M5_BRANCH_CHECKC, < 0.6, connect_sequence = CONNECT_DB_M5_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
} /* end of rule : M5.S.2 */
rM5_S_2_1_A @= { @ "M5.S.2.1.a : Min. space betweem wide metal and small piece of metal with parallel run length >= " + M5_S_2_L + " and same connection >=" + M5_S_2_1 + " um"; 
    sLAYER_174 = shrink( M5, east = 5 ); 
    sLAYER_173 = shrink( sLAYER_174, west = 5 );
    sLAYER_172 = shrink( sLAYER_173, north = 5 );
    M5_S5 = shrink( sLAYER_172, south = 5 ); 
    sLAYER_177 = grow( M5_S5, east = 5 ); 
    sLAYER_176 = grow( sLAYER_177, west = 5 );
    sLAYER_175 = grow( sLAYER_176, north = 5 );
    M5_G5 = grow( sLAYER_175, south = 5 ); 
    M5_WIDE = M5_G5 and M5; 
    M5_SMALL = M5 not M5_WIDE; 
    M5_WIDEC = stamp( M5_WIDE, M5XD, CONNECT_DB, CONNECT_DB_M5_S_2_1_A, include_touch = NONE ); 
    M5_SMALLC = stamp( M5_SMALL, M5XD, CONNECT_DB_M5_S_2_1_A, CONNECT_DB_M5_S_2_1_A, include_touch = NONE ); 
    M5_S_REG = external2( M5_WIDEC, M5_SMALLC, < M5_S_2_1, connect_sequence = CONNECT_DB_M5_S_2_1_A, connectivity = SAME_NET, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    M5_S_REG_CHECK = contains( M5_S_REG, { GRID, M5_S_2_L }, FORTY_FIVE ); 
    WIDEEDGE1 = M5_S_REG_CHECK coincident_outside_edge M5_WIDE; 
    M5_SMALL_EDGE = M5_SMALL coincident_inside_edge M5; 
    WIDEEDGE2 = M5_S_REG_CHECK coincident_outside_edge M5_SMALL_EDGE; 
    length_edge( WIDEEDGE1, >= M5_S_2_L, CONNECT ); 
    length_edge( WIDEEDGE2, >= M5_S_2_L, CONNECT ); 
} /* end of rule : M5.S.2.1.a */
rM5_S_2_1_B @= { @ "M5.S.2.1.b : Min. space between two wide metals with parallel run length >= " + M5_S_2_L + " and same connection >=" + M5_S_2_2 + " um"; 
    sLAYER_180 = shrink( M5, east = 5 ); 
    sLAYER_179 = shrink( sLAYER_180, west = 5 );
    sLAYER_178 = shrink( sLAYER_179, north = 5 );
    M5_S5 = shrink( sLAYER_178, south = 5 ); 
    sLAYER_183 = grow( M5_S5, east = 5 ); 
    sLAYER_182 = grow( sLAYER_183, west = 5 );
    sLAYER_181 = grow( sLAYER_182, north = 5 );
    M5_G5 = grow( sLAYER_181, south = 5 ); 
    M5_WIDE = M5_G5 and M5; 
    M5_WIDEC = stamp( M5_WIDE, M5XD, CONNECT_DB, CONNECT_DB_M5_S_2_1_B, include_touch = NONE ); 
    M5_S_REG = external1( M5_WIDEC, < M5_S_2_2, connect_sequence = CONNECT_DB_M5_S_2_1_B, connectivity = SAME_NET, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    M5_S_REG_CHECK = contains( M5_S_REG, { GRID, M5_S_2_L }, FORTY_FIVE ); 
    WIDEEDGE = M5_S_REG_CHECK coincident_outside_edge M5_WIDE; 
    length_edge( WIDEEDGE, >= M5_S_2_L, CONNECT ); 
} /* end of rule : M5.S.2.1.b */
rM5_E_1 @= { @ "M5.E.1 : Min. extension of a M5 region beyond a VIA4 region < 0.01";
    enclose( VIA4, M5, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    VIA4 not M5; 
} /* end of rule : M5.E.1 */
rM5_E_2 @= { @ "M5.E.2 : Min. extension of M5 end-of-line region beyond VIA4 region < 0.06";
    X = enclose_edge( VIA4, M5, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
    internal1_error( X, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
} /* end of rule : M5.E.2 */
rM5_A_1 @= { @ "M5.A.1 : Min M5 area region < " + MX_A_1; 
    area( M5, < MX_A_1 ); 
} /* end of rule : M5.A.1 */
VIA1_SAME_ARRAY_B = size( size( VIA1MERGE_p_PRE1, - ( VIA_FILTER / 2 ), clip_acute = NONE ), VIA_FILTER / 2, clip_acute = NONE );    /* For broken small metal connection */ 
VIA2_SAME_ARRAY_B = size( size( VIA2MERGE_p_PRE1, - ( VIA_FILTER / 2 ), clip_acute = NONE ), VIA_FILTER / 2, clip_acute = NONE );    /* For broken small metal connection */ 
VIA3_SAME_ARRAY_B = size( size( VIA3MERGE_p_PRE1, - ( VIA_FILTER / 2 ), clip_acute = NONE ), VIA_FILTER / 2, clip_acute = NONE );    /* For broken small metal connection */ 
VIA4_SAME_ARRAY_B = size( size( VIA4MERGE_p_PRE1, - ( VIA_FILTER / 2 ), clip_acute = NONE ), VIA_FILTER / 2, clip_acute = NONE );    /* For broken small metal connection */ 
VIA5_SAME_ARRAY_B = size( size( VIA5MERGE_p_PRE1, - ( VIA_FILTER / 2 ), clip_acute = NONE ), VIA_FILTER / 2, clip_acute = NONE );    /* For broken small metal connection */ 
gLAYER_75 = area( VIA1_SAME_ARRAY_B, >= VIA_A_5_B ); 
gLAYER_76 = area( VIA2_SAME_ARRAY_B, >= VIA_A_5_B ); 
gLAYER_74 = gLAYER_75 and gLAYER_76;
gLAYER_77 = area( VIA3_SAME_ARRAY_B, >= VIA_A_5_B ); 
gLAYER_73 = gLAYER_74 and gLAYER_77;
gLAYER_78 = area( VIA4_SAME_ARRAY_B, >= VIA_A_5_B ); 
gLAYER_72 = gLAYER_73 and gLAYER_78;
gLAYER_79 = area( VIA5_SAME_ARRAY_B, >= VIA_A_5_B ); 
VIA1_SAME_ARRAY_5STACK_S_6_p_PRE1 = gLAYER_72 and gLAYER_79; 
VIA1_SAME_ARRAY_5STACK_S_6_p_PRE2 = area( VIA1_SAME_ARRAY_5STACK_S_6_p_PRE1, >= VIA_A_5_B ); 
gLAYER_83 = area( VIA1_SAME_ARRAY, >= VIA_A_5_B ); 
gLAYER_84 = area( VIA2_SAME_ARRAY, >= VIA_A_5_B ); 
gLAYER_82 = gLAYER_83 and gLAYER_84;
gLAYER_85 = area( VIA3_SAME_ARRAY, >= VIA_A_5_B ); 
gLAYER_81 = gLAYER_82 and gLAYER_85;
gLAYER_86 = area( VIA4_SAME_ARRAY, >= VIA_A_5_B ); 
gLAYER_80 = gLAYER_81 and gLAYER_86;
gLAYER_87 = area( VIA5_SAME_ARRAY, >= VIA_A_5_B ); 
VIA1_SAME_ARRAY_5STACK_MX_S3_p_PRE1 = gLAYER_80 and gLAYER_87; 
VIA1_SAME_ARRAY_5STACK_MX_S3_p_PRE2 = area( VIA1_SAME_ARRAY_5STACK_MX_S3_p_PRE1, >= VIA_A_5_B ); 
gLAYER_96 = area( VIA1_SAME_ARRAY_B, >= VIA_A_4_B ); 
gLAYER_97 = area( VIA2_SAME_ARRAY_B, >= VIA_A_4_B ); 
gLAYER_95 = gLAYER_96 and gLAYER_97;
gLAYER_98 = area( VIA3_SAME_ARRAY_B, >= VIA_A_4_B ); 
gLAYER_94 = gLAYER_95 and gLAYER_98;
gLAYER_99 = area( VIA4_SAME_ARRAY_B, >= VIA_A_4_B ); 
VIA1_SAME_ARRAY_4STACK_S_7_p_PRE1 = gLAYER_94 and gLAYER_99; 
VIA1_SAME_ARRAY_4STACK_S_7_p_PRE2 = area( VIA1_SAME_ARRAY_4STACK_S_7_p_PRE1, >= VIA_A_4_B ); 
gLAYER_102 = area( VIA1_SAME_ARRAY, >= VIA_A_4_B ); 
gLAYER_103 = area( VIA2_SAME_ARRAY, >= VIA_A_4_B ); 
gLAYER_101 = gLAYER_102 and gLAYER_103;
gLAYER_104 = area( VIA3_SAME_ARRAY, >= VIA_A_4_B ); 
gLAYER_100 = gLAYER_101 and gLAYER_104;
gLAYER_105 = area( VIA4_SAME_ARRAY, >= VIA_A_4_B ); 
VIA1_SAME_ARRAY_4STACK_MX_S4_p_PRE1 = gLAYER_100 and gLAYER_105; 
VIA1_SAME_ARRAY_4STACK_MX_S4_p_PRE2 = area( VIA1_SAME_ARRAY_4STACK_MX_S4_p_PRE1, >= VIA_A_4_B ); 
gLAYER_114 = area( VIA2_SAME_ARRAY_B, >= VIA_A_4_B ); 
gLAYER_115 = area( VIA3_SAME_ARRAY_B, >= VIA_A_4_B ); 
gLAYER_113 = gLAYER_114 and gLAYER_115;
gLAYER_116 = area( VIA4_SAME_ARRAY_B, >= VIA_A_4_B ); 
gLAYER_112 = gLAYER_113 and gLAYER_116;
gLAYER_117 = area( VIA5_SAME_ARRAY_B, >= VIA_A_4_B ); 
VIA2_SAME_ARRAY_4STACK_S_7_p_PRE1 = gLAYER_112 and gLAYER_117; 
VIA2_SAME_ARRAY_4STACK_S_7_p_PRE2 = area( VIA2_SAME_ARRAY_4STACK_S_7_p_PRE1, >= VIA_A_4_B ); 
gLAYER_120 = area( VIA2_SAME_ARRAY, >= VIA_A_4_B ); 
gLAYER_121 = area( VIA3_SAME_ARRAY, >= VIA_A_4_B ); 
gLAYER_119 = gLAYER_120 and gLAYER_121;
gLAYER_122 = area( VIA4_SAME_ARRAY, >= VIA_A_4_B ); 
gLAYER_118 = gLAYER_119 and gLAYER_122;
gLAYER_123 = area( VIA5_SAME_ARRAY, >= VIA_A_4_B ); 
VIA2_SAME_ARRAY_4STACK_MX_S4_p_PRE1 = gLAYER_118 and gLAYER_123; 
VIA2_SAME_ARRAY_4STACK_MX_S4_p_PRE2 = area( VIA2_SAME_ARRAY_4STACK_MX_S4_p_PRE1, >= VIA_A_4_B ); 
gLAYER_129 = area( VIA1_SAME_ARRAY_B, >= VIA_A_3_B ); 
gLAYER_130 = area( VIA2_SAME_ARRAY_B, >= VIA_A_3_B ); 
gLAYER_128 = gLAYER_129 and gLAYER_130;
gLAYER_131 = area( VIA3_SAME_ARRAY_B, >= VIA_A_3_B ); 
VIA1_SAME_ARRAY_3STACK_S_8_p_PRE1 = gLAYER_128 and gLAYER_131; 
VIA1_SAME_ARRAY_3STACK_S_8_p_PRE2 = area( VIA1_SAME_ARRAY_3STACK_S_8_p_PRE1, >= VIA_A_3_B ); 
gLAYER_133 = area( VIA1_SAME_ARRAY, >= VIA_A_3_B ); 
gLAYER_134 = area( VIA2_SAME_ARRAY, >= VIA_A_3_B ); 
gLAYER_132 = gLAYER_133 and gLAYER_134;
gLAYER_135 = area( VIA3_SAME_ARRAY, >= VIA_A_3_B ); 
VIA1_SAME_ARRAY_3STACK_MX_S5_p_PRE1 = gLAYER_132 and gLAYER_135; 
VIA1_SAME_ARRAY_3STACK_MX_S5_p_PRE2 = area( VIA1_SAME_ARRAY_3STACK_MX_S5_p_PRE1, >= VIA_A_3_B ); 
gLAYER_141 = area( VIA2_SAME_ARRAY_B, >= VIA_A_3_B ); 
gLAYER_142 = area( VIA3_SAME_ARRAY_B, >= VIA_A_3_B ); 
gLAYER_140 = gLAYER_141 and gLAYER_142;
gLAYER_143 = area( VIA4_SAME_ARRAY_B, >= VIA_A_3_B ); 
VIA2_SAME_ARRAY_3STACK_S_8_p_PRE1 = gLAYER_140 and gLAYER_143; 
VIA2_SAME_ARRAY_3STACK_S_8_p_PRE2 = area( VIA2_SAME_ARRAY_3STACK_S_8_p_PRE1, >= VIA_A_3_B ); 
gLAYER_145 = area( VIA2_SAME_ARRAY, >= VIA_A_3_B ); 
gLAYER_146 = area( VIA3_SAME_ARRAY, >= VIA_A_3_B ); 
gLAYER_144 = gLAYER_145 and gLAYER_146;
gLAYER_147 = area( VIA4_SAME_ARRAY, >= VIA_A_3_B ); 
VIA2_SAME_ARRAY_3STACK_MX_S5_p_PRE1 = gLAYER_144 and gLAYER_147; 
VIA2_SAME_ARRAY_3STACK_MX_S5_p_PRE2 = area( VIA2_SAME_ARRAY_3STACK_MX_S5_p_PRE1, >= VIA_A_3_B ); 
gLAYER_153 = area( VIA3_SAME_ARRAY_B, >= VIA_A_3_B ); 
gLAYER_154 = area( VIA4_SAME_ARRAY_B, >= VIA_A_3_B ); 
gLAYER_152 = gLAYER_153 and gLAYER_154;
gLAYER_155 = area( VIA5_SAME_ARRAY_B, >= VIA_A_3_B ); 
VIA3_SAME_ARRAY_3STACK_S_8_p_PRE1 = gLAYER_152 and gLAYER_155; 
VIA3_SAME_ARRAY_3STACK_S_8_p_PRE2 = area( VIA3_SAME_ARRAY_3STACK_S_8_p_PRE1, >= VIA_A_3_B ); 
gLAYER_157 = area( VIA3_SAME_ARRAY, >= VIA_A_3_B ); 
gLAYER_158 = area( VIA4_SAME_ARRAY, >= VIA_A_3_B ); 
gLAYER_156 = gLAYER_157 and gLAYER_158;
gLAYER_159 = area( VIA5_SAME_ARRAY, >= VIA_A_3_B ); 
VIA3_SAME_ARRAY_3STACK_MX_S5_p_PRE1 = gLAYER_156 and gLAYER_159; 
VIA3_SAME_ARRAY_3STACK_MX_S5_p_PRE2 = area( VIA3_SAME_ARRAY_3STACK_MX_S5_p_PRE1, >= VIA_A_3_B ); 
gLAYER_162 = area( VIA1_SAME_ARRAY_B, >= VIA_A_2_B ); 
gLAYER_163 = area( VIA2_SAME_ARRAY_B, >= VIA_A_2_B ); 
VIA1_SAME_ARRAY_2STACK_S_9_p_PRE1 = gLAYER_162 and gLAYER_163; 
VIA1_SAME_ARRAY_2STACK_S_9_p_PRE2 = area( VIA1_SAME_ARRAY_2STACK_S_9_p_PRE1, >= VIA_A_2_B ); 
gLAYER_164 = area( VIA1_SAME_ARRAY, >= VIA_A_2_B ); 
gLAYER_165 = area( VIA2_SAME_ARRAY, >= VIA_A_2_B ); 
VIA1_SAME_ARRAY_2STACK_MX_S6_p_PRE1 = gLAYER_164 and gLAYER_165; 
VIA1_SAME_ARRAY_2STACK_MX_S6_p_PRE2 = area( VIA1_SAME_ARRAY_2STACK_MX_S6_p_PRE1, >= VIA_A_2_B ); 
gLAYER_168 = area( VIA2_SAME_ARRAY_B, >= VIA_A_2_B ); 
gLAYER_169 = area( VIA3_SAME_ARRAY_B, >= VIA_A_2_B ); 
VIA2_SAME_ARRAY_2STACK_S_9_p_PRE1 = gLAYER_168 and gLAYER_169; 
VIA2_SAME_ARRAY_2STACK_S_9_p_PRE2 = area( VIA2_SAME_ARRAY_2STACK_S_9_p_PRE1, >= VIA_A_2_B ); 
gLAYER_170 = area( VIA2_SAME_ARRAY, >= VIA_A_2_B ); 
gLAYER_171 = area( VIA3_SAME_ARRAY, >= VIA_A_2_B ); 
VIA2_SAME_ARRAY_2STACK_MX_S6_p_PRE1 = gLAYER_170 and gLAYER_171; 
VIA2_SAME_ARRAY_2STACK_MX_S6_p_PRE2 = area( VIA2_SAME_ARRAY_2STACK_MX_S6_p_PRE1, >= VIA_A_2_B ); 
gLAYER_174 = area( VIA3_SAME_ARRAY_B, >= VIA_A_2_B ); 
gLAYER_175 = area( VIA4_SAME_ARRAY_B, >= VIA_A_2_B ); 
VIA3_SAME_ARRAY_2STACK_S_9_p_PRE1 = gLAYER_174 and gLAYER_175; 
VIA3_SAME_ARRAY_2STACK_S_9_p_PRE2 = area( VIA3_SAME_ARRAY_2STACK_S_9_p_PRE1, >= VIA_A_2_B ); 
gLAYER_176 = area( VIA3_SAME_ARRAY, >= VIA_A_2_B ); 
gLAYER_177 = area( VIA4_SAME_ARRAY, >= VIA_A_2_B ); 
VIA3_SAME_ARRAY_2STACK_MX_S6_p_PRE1 = gLAYER_176 and gLAYER_177; 
VIA3_SAME_ARRAY_2STACK_MX_S6_p_PRE2 = area( VIA3_SAME_ARRAY_2STACK_MX_S6_p_PRE1, >= VIA_A_2_B ); 
gLAYER_180 = area( VIA4_SAME_ARRAY_B, >= VIA_A_2_B ); 
gLAYER_181 = area( VIA5_SAME_ARRAY_B, >= VIA_A_2_B ); 
VIA4_SAME_ARRAY_2STACK_S_9_p_PRE1 = gLAYER_180 and gLAYER_181; 
VIA4_SAME_ARRAY_2STACK_S_9_p_PRE2 = area( VIA4_SAME_ARRAY_2STACK_S_9_p_PRE1, >= VIA_A_2_B ); 
gLAYER_182 = area( VIA4_SAME_ARRAY, >= VIA_A_2_B ); 
gLAYER_183 = area( VIA5_SAME_ARRAY, >= VIA_A_2_B ); 
VIA4_SAME_ARRAY_2STACK_MX_S6_p_PRE1 = gLAYER_182 and gLAYER_183; 
VIA4_SAME_ARRAY_2STACK_MX_S6_p_PRE2 = area( VIA4_SAME_ARRAY_2STACK_MX_S6_p_PRE1, >= VIA_A_2_B ); 
VIA1_SAME_ARRAY_1STACK_S_10_p_PRE1 = area( VIA1_SAME_ARRAY_B, >= VIA_A_1 ); 
VIA1_SAME_ARRAY_1STACK_MX_S7_p_PRE1 = area( VIA1_SAME_ARRAY, >= VIA_A_1 ); 
VIA2_SAME_ARRAY_1STACK_S_10_p_PRE1 = area( VIA2_SAME_ARRAY_B, >= VIA_A_1 ); 
VIA2_SAME_ARRAY_1STACK_MX_S7_p_PRE1 = area( VIA2_SAME_ARRAY, >= VIA_A_1 ); 
VIA3_SAME_ARRAY_1STACK_S_10_p_PRE1 = area( VIA3_SAME_ARRAY_B, >= VIA_A_1 ); 
VIA3_SAME_ARRAY_1STACK_MX_S7_p_PRE1 = area( VIA3_SAME_ARRAY, >= VIA_A_1 ); 
VIA4_SAME_ARRAY_1STACK_S_10_p_PRE1 = area( VIA4_SAME_ARRAY_B, >= VIA_A_1 ); 
VIA4_SAME_ARRAY_1STACK_MX_S7_p_PRE1 = area( VIA4_SAME_ARRAY, >= VIA_A_1 ); 
VIA5_SAME_ARRAY_1STACK_S_10_p_PRE1 = area( VIA5_SAME_ARRAY_B, >= VIA_A_1 ); 
VIA5_SAME_ARRAY_1STACK_MX_S7_p_PRE1 = area( VIA5_SAME_ARRAY, >= VIA_A_1 ); 

// Processing for VIAx.S.6 Check    
//**************************************
gLAYER_204 = interacting( M1, VIA1_SAME_ARRAY_5STACK_S_6_p_PRE2 ); 
gLAYER_205 = interacting( M2, VIA1_SAME_ARRAY_5STACK_S_6_p_PRE2 ); 
gLAYER_203 = gLAYER_204 or gLAYER_205;
gLAYER_206 = interacting( M3, VIA1_SAME_ARRAY_5STACK_S_6_p_PRE2 ); 
gLAYER_202 = gLAYER_203 or gLAYER_206;
gLAYER_207 = interacting( M4, VIA1_SAME_ARRAY_5STACK_S_6_p_PRE2 ); 
gLAYER_201 = gLAYER_202 or gLAYER_207;
gLAYER_208 = interacting( M5, VIA1_SAME_ARRAY_5STACK_S_6_p_PRE2 ); 
gLAYER_200 = gLAYER_201 or gLAYER_208;
gLAYER_209 = interacting( M6, VIA1_SAME_ARRAY_5STACK_S_6_p_PRE2 ); 
M1_5STACK_S_6_p_PRE3 = gLAYER_200 or gLAYER_209; 
VIA1_5STACK_S_6_p_PRE3 = size_inside_wrapper( VIA1_SAME_ARRAY_5STACK_S_6_p_PRE2, M1_5STACK_S_6_p_PRE3, distance = VIA_S_4, increment = 0.28 ); 
VIA1_5STACK_S_6_p_PRE4 = VIA1_5STACK_S_6_p_PRE3 touching_edge M1_5STACK_S_6_p_PRE3; 
VIA1_5STACK_S_6_p_PRE5 = touching( VIA1_5STACK_S_6_p_PRE3, VIA1_5STACK_S_6_p_PRE4, >= 1 ); 
VIA1_5STACK_S_6_p_FINAL = interacting( VIA1_SAME_ARRAY_5STACK_S_6_p_PRE2, VIA1_5STACK_S_6_p_PRE5 ); 
VIA1_S_5_B1 = interacting( VIA1, VIA1_5STACK_S_6_p_FINAL ); 
VIA1_REG_4_S_5_B1 = external1( VIA1_S_5_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA1s space smaller than 0.49 (inside small array)   */ 
VIA1_VIOLATE_S_5_B1 = interacting( VIA1_S_5_B1, VIA1_REG_4_S_5_B1 ); 
VIA2_S_5_B1 = interacting( VIA2, VIA1_5STACK_S_6_p_FINAL ); 
VIA2_REG_4_S_5_B1 = external1( VIA2_S_5_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_5_B1 = interacting( VIA2_S_5_B1, VIA2_REG_4_S_5_B1 ); 
VIA3_S_5_B1 = interacting( VIA3, VIA1_5STACK_S_6_p_FINAL ); 
VIA3_REG_4_S_5_B1 = external1( VIA3_S_5_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_5_B1 = interacting( VIA3_S_5_B1, VIA3_REG_4_S_5_B1 ); 
VIA4_S_5_B1 = interacting( VIA4, VIA1_5STACK_S_6_p_FINAL ); 
VIA4_REG_4_S_5_B1 = external1( VIA4_S_5_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_5_B1 = interacting( VIA4_S_5_B1, VIA4_REG_4_S_5_B1 ); 
VIA5_S_5_B1 = interacting( VIA5, VIA1_5STACK_S_6_p_FINAL ); 
VIA5_REG_4_S_5_B1 = external1( VIA5_S_5_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA5s space smaller than 0.49 (inside small array)   */ 
VIA5_VIOLATE_S_5_B1 = interacting( VIA5_S_5_B1, VIA5_REG_4_S_5_B1 ); 

// Processing for Mx.S.3 Check    
//**************************************
VIA1_5STACK_MX_S3_p_PRE3 = contains( VIA1_SAME_ARRAY_5STACK_MX_S3_p_PRE2, { VIA_W_1, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
M1_S_5_C1 = enclose_edge( VIA1_5STACK_MX_S3_p_PRE3, M1, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M1_REG_4_S_5_C1 = external1( M1_S_5_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M1s space smaller than 1.2    */ 
M2_S_5_C1 = enclose_edge( VIA1_5STACK_MX_S3_p_PRE3, M2, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M2_REG_4_S_5_C1 = external1( M2_S_5_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M2s space smaller than 1.2    */ 
M3_S_5_C1 = enclose_edge( VIA1_5STACK_MX_S3_p_PRE3, M3, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M3_REG_4_S_5_C1 = external1( M3_S_5_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M3s space smaller than 1.2    */ 
M4_S_5_C1 = enclose_edge( VIA1_5STACK_MX_S3_p_PRE3, M4, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M4_REG_4_S_5_C1 = external1( M4_S_5_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M4s space smaller than 1.2    */ 
M5_S_5_C1 = enclose_edge( VIA1_5STACK_MX_S3_p_PRE3, M5, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M5_REG_4_S_5_C1 = external1( M5_S_5_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M5s space smaller than 1.2    */ 
rVIA1_S_2_ARRAY1_2_3_4_5_M @= { @ "VIA1.S.2_Array1_2_3_4_5_M : Minimum space between two VIAs in 5-level continuous stacking VIA arrays with below condition. >=0.49um "
                                                              "Via1 violate " + VIA_S_3 + " spacing in Via1/Via2/Via3/Via4/Via5 array & density large or equal " + VIA_D_1; 
    A1 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA1_VIOLATE_S_5_A1, "layer2" => VIA1_5STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A2 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA2_VIOLATE_S_5_A1, "layer2" => VIA1_5STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A3 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA3_VIOLATE_S_5_A1, "layer2" => VIA1_5STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A4 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA4_VIOLATE_S_5_A1, "layer2" => VIA1_5STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A5 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA5_VIOLATE_S_5_A1, "layer2" => VIA1_5STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    sLAYER_186 = A1 or A2; 
    sLAYER_185 = sLAYER_186 or A3; 
    sLAYER_184 = sLAYER_185 or A4; 
    B1 = sLAYER_184 or A5; 
    size( size( B1, VIA_MERGE, clip_acute = NONE ), - VIA_MERGE, clip_acute = NONE ); 
} /* end of rule : VIA1.S.2_Array1_2_3_4_5_M */
rVIA1_S_6_ARRAY1_2_3_4_5_M @= { @ "VIA1.S.6_Array1_2_3_4_5_M : Minimum space between two VIA1 region >= " + VIA_S_3 + " um if the overlap area of 5-level " 
                                                              "continuous stacking VIA arrays >= " + VIA_A_5_B + " um2 (except sealring region)"; 
    sLAYER_187 = interacting( VIA1_5STACK_S_6_p_FINAL, VIA1_VIOLATE_S_5_B1 ); 
    not_interacting( sLAYER_187, SEALRING_ALL ); 
} /* end of rule : VIA1.S.6_Array1_2_3_4_5_M */
rVIA2_S_6_ARRAY1_2_3_4_5_M @= { @ "VIA2.S.6_Array1_2_3_4_5_M : Minimum space between two VIA2 region >= " + VIA_S_3 + " um if the overlap area of 5-level " 
                                                              "continuous stacking VIA arrays >= " + VIA_A_5_B + " um2 (except sealring region)"; 
    sLAYER_188 = interacting( VIA1_5STACK_S_6_p_FINAL, VIA2_VIOLATE_S_5_B1 ); 
    not_interacting( sLAYER_188, SEALRING_ALL ); 
} /* end of rule : VIA2.S.6_Array1_2_3_4_5_M */
rVIA3_S_6_ARRAY1_2_3_4_5_M @= { @ "VIA3.S.6_Array1_2_3_4_5_M : Minimum space between two VIA3 region >= " + VIA_S_3 + " um if the overlap area of 5-level " 
                                                              "continuous stacking VIA arrays >= " + VIA_A_5_B + " um2 (except sealring region)"; 
    sLAYER_189 = interacting( VIA1_5STACK_S_6_p_FINAL, VIA3_VIOLATE_S_5_B1 ); 
    not_interacting( sLAYER_189, SEALRING_ALL ); 
} /* end of rule : VIA3.S.6_Array1_2_3_4_5_M */
rVIA4_S_6_ARRAY1_2_3_4_5_M @= { @ "VIA4.S.6_Array1_2_3_4_5_M : Minimum space between two VIA4 region >= " + VIA_S_3 + " um if the overlap area of 5-level " 
                                                              "continuous stacking VIA arrays >= " + VIA_A_5_B + " um2 (except sealring region)"; 
    sLAYER_190 = interacting( VIA1_5STACK_S_6_p_FINAL, VIA4_VIOLATE_S_5_B1 ); 
    not_interacting( sLAYER_190, SEALRING_ALL ); 
} /* end of rule : VIA4.S.6_Array1_2_3_4_5_M */
rVIA5_S_6_ARRAY1_2_3_4_5_M @= { @ "VIA5.S.6_Array1_2_3_4_5_M : Minimum space between two VIA5 region >= " + VIA_S_3 + " um if the overlap area of 5-level " 
                                                              "continuous stacking VIA arrays >= " + VIA_A_5_B + " um2 (except sealring region)"; 
    sLAYER_191 = interacting( VIA1_5STACK_S_6_p_FINAL, VIA5_VIOLATE_S_5_B1 ); 
    not_interacting( sLAYER_191, SEALRING_ALL ); 
} /* end of rule : VIA5.S.6_Array1_2_3_4_5_M */
rM1_2_3_4_5_S_3 @= { @ "M1_2_3_4_5.S.3 : Minimum space between two Mx region with below conditions >= " + MX_S_3_7 + " um " 
                                        "(a1) both of the Mx with the overlap area of 5-level continuous VIA array area >= " + VIA_A_5_B + " um2 " 
                                        "(a2) Width of 5-level continuous stacking VIA arrays >= " + VIA_W_1 + " um"; 
    sLAYER_194 = M1_REG_4_S_5_C1 or M2_REG_4_S_5_C1; 
    sLAYER_193 = sLAYER_194 or M3_REG_4_S_5_C1; 
    sLAYER_192 = sLAYER_193 or M4_REG_4_S_5_C1; 
    sLAYER_192 or M5_REG_4_S_5_C1; 
} /* end of rule : M1_2_3_4_5.S.3 */

// Processing for VIAx.S.7 Check    
//**************************************
gLAYER_239 = interacting( M1, VIA1_SAME_ARRAY_4STACK_S_7_p_PRE2 ); 
gLAYER_240 = interacting( M2, VIA1_SAME_ARRAY_4STACK_S_7_p_PRE2 ); 
gLAYER_238 = gLAYER_239 or gLAYER_240;
gLAYER_241 = interacting( M3, VIA1_SAME_ARRAY_4STACK_S_7_p_PRE2 ); 
gLAYER_237 = gLAYER_238 or gLAYER_241;
gLAYER_242 = interacting( M4, VIA1_SAME_ARRAY_4STACK_S_7_p_PRE2 ); 
gLAYER_236 = gLAYER_237 or gLAYER_242;
gLAYER_243 = interacting( M5, VIA1_SAME_ARRAY_4STACK_S_7_p_PRE2 ); 
M1_4STACK_S_7_p_PRE3 = gLAYER_236 or gLAYER_243; 
VIA1_4STACK_S_7_p_PRE3 = size_inside_wrapper( VIA1_SAME_ARRAY_4STACK_S_7_p_PRE2, M1_4STACK_S_7_p_PRE3, distance = VIA_S_4, increment = 0.28 ); 
VIA1_4STACK_S_7_p_PRE4 = VIA1_4STACK_S_7_p_PRE3 touching_edge M1_4STACK_S_7_p_PRE3; 
VIA1_4STACK_S_7_p_PRE5 = touching( VIA1_4STACK_S_7_p_PRE3, VIA1_4STACK_S_7_p_PRE4, >= 1 ); 
VIA1_4STACK_S_7_p_FINAL = interacting( VIA1_SAME_ARRAY_4STACK_S_7_p_PRE2, VIA1_4STACK_S_7_p_PRE5 ); 
VIA1_S_4_B1 = interacting( VIA1, VIA1_4STACK_S_7_p_FINAL ); 
VIA1_REG_4_S_4_B1 = external1( VIA1_S_4_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA1s space smaller than 0.49 (inside small array)   */ 
VIA1_VIOLATE_S_4_B1 = interacting( VIA1_S_4_B1, VIA1_REG_4_S_4_B1 ); 
VIA2_S_4_B1 = interacting( VIA2, VIA1_4STACK_S_7_p_FINAL ); 
VIA2_REG_4_S_4_B1 = external1( VIA2_S_4_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_4_B1 = interacting( VIA2_S_4_B1, VIA2_REG_4_S_4_B1 ); 
VIA3_S_4_B1 = interacting( VIA3, VIA1_4STACK_S_7_p_FINAL ); 
VIA3_REG_4_S_4_B1 = external1( VIA3_S_4_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_4_B1 = interacting( VIA3_S_4_B1, VIA3_REG_4_S_4_B1 ); 
VIA4_S_4_B1 = interacting( VIA4, VIA1_4STACK_S_7_p_FINAL ); 
VIA4_REG_4_S_4_B1 = external1( VIA4_S_4_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_4_B1 = interacting( VIA4_S_4_B1, VIA4_REG_4_S_4_B1 ); 
gLAYER_247 = interacting( M2, VIA2_SAME_ARRAY_4STACK_S_7_p_PRE2 ); 
gLAYER_248 = interacting( M3, VIA2_SAME_ARRAY_4STACK_S_7_p_PRE2 ); 
gLAYER_246 = gLAYER_247 or gLAYER_248;
gLAYER_249 = interacting( M4, VIA2_SAME_ARRAY_4STACK_S_7_p_PRE2 ); 
gLAYER_245 = gLAYER_246 or gLAYER_249;
gLAYER_250 = interacting( M5, VIA2_SAME_ARRAY_4STACK_S_7_p_PRE2 ); 
gLAYER_244 = gLAYER_245 or gLAYER_250;
gLAYER_251 = interacting( M6, VIA2_SAME_ARRAY_4STACK_S_7_p_PRE2 ); 
M2_4STACK_S_7_p_PRE3 = gLAYER_244 or gLAYER_251; 
VIA2_4STACK_S_7_p_PRE3 = size_inside_wrapper( VIA2_SAME_ARRAY_4STACK_S_7_p_PRE2, M2_4STACK_S_7_p_PRE3, distance = VIA_S_4, increment = 0.28 ); 
VIA2_4STACK_S_7_p_PRE4 = VIA2_4STACK_S_7_p_PRE3 touching_edge M2_4STACK_S_7_p_PRE3; 
VIA2_4STACK_S_7_p_PRE5 = touching( VIA2_4STACK_S_7_p_PRE3, VIA2_4STACK_S_7_p_PRE4, >= 1 ); 
VIA2_4STACK_S_7_p_FINAL = interacting( VIA2_SAME_ARRAY_4STACK_S_7_p_PRE2, VIA2_4STACK_S_7_p_PRE5 ); 
VIA2_S_4_B2 = interacting( VIA2, VIA2_4STACK_S_7_p_FINAL ); 
VIA2_REG_4_S_4_B2 = external1( VIA2_S_4_B2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_4_B2 = interacting( VIA2_S_4_B2, VIA2_REG_4_S_4_B2 ); 
VIA3_S_4_B2 = interacting( VIA3, VIA2_4STACK_S_7_p_FINAL ); 
VIA3_REG_4_S_4_B2 = external1( VIA3_S_4_B2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_4_B2 = interacting( VIA3_S_4_B2, VIA3_REG_4_S_4_B2 ); 
VIA4_S_4_B2 = interacting( VIA4, VIA2_4STACK_S_7_p_FINAL ); 
VIA4_REG_4_S_4_B2 = external1( VIA4_S_4_B2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_4_B2 = interacting( VIA4_S_4_B2, VIA4_REG_4_S_4_B2 ); 
VIA5_S_4_B2 = interacting( VIA5, VIA2_4STACK_S_7_p_FINAL ); 
VIA5_REG_4_S_4_B2 = external1( VIA5_S_4_B2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA5s space smaller than 0.49 (inside small array)   */ 
VIA5_VIOLATE_S_4_B2 = interacting( VIA5_S_4_B2, VIA5_REG_4_S_4_B2 ); 

// Processing for Mx.S.4 Check    
//**************************************
VIA1_4STACK_MX_S4_p_PRE3 = contains( VIA1_SAME_ARRAY_4STACK_MX_S4_p_PRE2, { VIA_W_1, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
M1_S_4_C1 = enclose_edge( VIA1_4STACK_MX_S4_p_PRE3, M1, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M1_REG_4_S_4_C1 = external1( M1_S_4_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M1s space smaller than 1.2    */ 
M2_S_4_C1 = enclose_edge( VIA1_4STACK_MX_S4_p_PRE3, M2, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M2_REG_4_S_4_C1 = external1( M2_S_4_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M2s space smaller than 1.2    */ 
M3_S_4_C1 = enclose_edge( VIA1_4STACK_MX_S4_p_PRE3, M3, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M3_REG_4_S_4_C1 = external1( M3_S_4_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M3s space smaller than 1.2    */ 
M4_S_4_C1 = enclose_edge( VIA1_4STACK_MX_S4_p_PRE3, M4, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M4_REG_4_S_4_C1 = external1( M4_S_4_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M4s space smaller than 1.2    */ 
VIA2_4STACK_MX_S4_p_PRE3 = contains( VIA2_SAME_ARRAY_4STACK_MX_S4_p_PRE2, { VIA_W_1, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
M2_S_4_C2 = enclose_edge( VIA2_4STACK_MX_S4_p_PRE3, M2, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M2_REG_4_S_4_C2 = external1( M2_S_4_C2, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M2s space smaller than 1.2    */ 
M3_S_4_C2 = enclose_edge( VIA2_4STACK_MX_S4_p_PRE3, M3, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M3_REG_4_S_4_C2 = external1( M3_S_4_C2, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M3s space smaller than 1.2    */ 
M4_S_4_C2 = enclose_edge( VIA2_4STACK_MX_S4_p_PRE3, M4, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M4_REG_4_S_4_C2 = external1( M4_S_4_C2, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M4s space smaller than 1.2    */ 
M5_S_4_C2 = enclose_edge( VIA2_4STACK_MX_S4_p_PRE3, M5, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M5_REG_4_S_4_C2 = external1( M5_S_4_C2, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M5s space smaller than 1.2    */ 
rVIA1_S_3_ARRAY1_2_3_4_M @= { @ "VIA1.S.3_Array1_2_3_4_M : Minimum space between two VIAs in 4-level continuous stacking VIA arrays with below condition >=0.49um "
                                                          "Via1 violate " + VIA_S_3 + " spacing in Via1/Via2/Via3/Via4 array & density large or equal " + VIA_D_1; 
    A1 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA1_VIOLATE_S_4_A1, "layer2" => VIA1_4STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A2 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA2_VIOLATE_S_4_A1, "layer2" => VIA1_4STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A3 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA3_VIOLATE_S_4_A1, "layer2" => VIA1_4STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A4 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA4_VIOLATE_S_4_A1, "layer2" => VIA1_4STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    sLAYER_196 = A1 or A2; 
    sLAYER_195 = sLAYER_196 or A3; 
    B1 = sLAYER_195 or A4; 
    size( size( B1, VIA_MERGE, clip_acute = NONE ), - VIA_MERGE, clip_acute = NONE ); 
} /* end of rule : VIA1.S.3_Array1_2_3_4_M */
rVIA1_S_7_ARRAY1_2_3_4_M @= { @ "VIA1.S.7_Array1_2_3_4_M : Minimum space between two VIA1 region >= " + VIA_S_3 + " um if the overlap area of 4-level " 
                                                          "continuous stacking VIA arrays >= " + VIA_A_4_B + " um2 (except sealring region)"; 
    sLAYER_197 = interacting( VIA1_4STACK_S_7_p_FINAL, VIA1_VIOLATE_S_4_B1 ); 
    not_interacting( sLAYER_197, SEALRING_ALL ); 
} /* end of rule : VIA1.S.7_Array1_2_3_4_M */
rVIA2_S_7_ARRAY1_2_3_4_M @= { @ "VIA2.S.7_Array1_2_3_4_M : Minimum space between two VIA2 region >= " + VIA_S_3 + " um if the overlap area of 4-level " 
                                                          "continuous stacking VIA arrays >= " + VIA_A_4_B + " um2 (except sealring region)"; 
    sLAYER_198 = interacting( VIA1_4STACK_S_7_p_FINAL, VIA2_VIOLATE_S_4_B1 ); 
    not_interacting( sLAYER_198, SEALRING_ALL ); 
} /* end of rule : VIA2.S.7_Array1_2_3_4_M */
rVIA3_S_7_ARRAY1_2_3_4_M @= { @ "VIA3.S.7_Array1_2_3_4_M : Minimum space between two VIA3 region >= " + VIA_S_3 + " um if the overlap area of 4-level " 
                                                          "continuous stacking VIA arrays >= " + VIA_A_4_B + " um2 (except sealring region)"; 
    sLAYER_199 = interacting( VIA1_4STACK_S_7_p_FINAL, VIA3_VIOLATE_S_4_B1 ); 
    not_interacting( sLAYER_199, SEALRING_ALL ); 
} /* end of rule : VIA3.S.7_Array1_2_3_4_M */
rVIA4_S_7_ARRAY1_2_3_4_M @= { @ "VIA4.S.7_Array1_2_3_4_M : Minimum space between two VIA4 region >= " + VIA_S_3 + " um if the overlap area of 4-level " 
                                                          "continuous stacking VIA arrays >= " + VIA_A_4_B + " um2 (except sealring region)"; 
    sLAYER_200 = interacting( VIA1_4STACK_S_7_p_FINAL, VIA4_VIOLATE_S_4_B1 ); 
    not_interacting( sLAYER_200, SEALRING_ALL ); 
} /* end of rule : VIA4.S.7_Array1_2_3_4_M */
rM1_2_3_4_S_4 @= { @ "M1_2_3_4.S.4 : Minimum space between two Mx region with below conditions >= " + MX_S_3_7 + " um " 
                                    "(a1) both of the Mx with the overlap area of 4-level continuous VIA array area >= " + VIA_A_4_B + " um2 " 
                                    "(a2) Width of 4-level continuous stacking VIA arrays >= " + VIA_W_1 + " um"; 
    sLAYER_202 = M1_REG_4_S_4_C1 or M2_REG_4_S_4_C1; 
    sLAYER_201 = sLAYER_202 or M3_REG_4_S_4_C1; 
    sLAYER_201 or M4_REG_4_S_4_C1; 
} /* end of rule : M1_2_3_4.S.4 */
rVIA2_S_3_ARRAY2_3_4_5_M @= { @ "VIA2.S.3_Array2_3_4_5_M : Minimum space between two VIAs in 4-level continuous stacking VIA arrays with below condition >=0.49um "
                                                          "Via2 violate " + VIA_S_3 + " spacing in Via2/Via3/Via4/Via5 array & density large or equal " + VIA_D_1; 
    A2 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA2_VIOLATE_S_4_A2, "layer2" => VIA2_4STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A3 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA3_VIOLATE_S_4_A2, "layer2" => VIA2_4STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A4 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA4_VIOLATE_S_4_A2, "layer2" => VIA2_4STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A5 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA5_VIOLATE_S_4_A2, "layer2" => VIA2_4STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    sLAYER_204 = A2 or A3; 
    sLAYER_203 = sLAYER_204 or A4; 
    B2 = sLAYER_203 or A5; 
    size( size( B2, VIA_MERGE, clip_acute = NONE ), - VIA_MERGE, clip_acute = NONE ); 
} /* end of rule : VIA2.S.3_Array2_3_4_5_M */
rVIA2_S_7_ARRAY2_3_4_5_M @= { @ "VIA2.S.7_Array2_3_4_5_M : Minimum space between two VIA2 region >= " + VIA_S_3 + " um if the overlap area of 4-level " 
                                                          "continuous stacking VIA arrays >= " + VIA_A_4_B + " um2 (except sealring region)"; 
    sLAYER_205 = interacting( VIA2_4STACK_S_7_p_FINAL, VIA2_VIOLATE_S_4_B2 ); 
    not_interacting( sLAYER_205, SEALRING_ALL ); 
} /* end of rule : VIA2.S.7_Array2_3_4_5_M */
rVIA3_S_7_ARRAY2_3_4_5_M @= { @ "VIA3.S.7_Array2_3_4_5_M : Minimum space between two VIA3 region >= " + VIA_S_3 + " um if the overlap area of 4-level " 
                                                          "continuous stacking VIA arrays >= " + VIA_A_4_B + " um2 (except sealring region)"; 
    sLAYER_206 = interacting( VIA2_4STACK_S_7_p_FINAL, VIA3_VIOLATE_S_4_B2 ); 
    not_interacting( sLAYER_206, SEALRING_ALL ); 
} /* end of rule : VIA3.S.7_Array2_3_4_5_M */
rVIA4_S_7_ARRAY2_3_4_5_M @= { @ "VIA4.S.7_Array2_3_4_5_M : Minimum space between two VIA4 region >= " + VIA_S_3 + " um if the overlap area of 4-level " 
                                                          "continuous stacking VIA arrays >= " + VIA_A_4_B + " um2 (except sealring region)"; 
    sLAYER_207 = interacting( VIA2_4STACK_S_7_p_FINAL, VIA4_VIOLATE_S_4_B2 ); 
    not_interacting( sLAYER_207, SEALRING_ALL ); 
} /* end of rule : VIA4.S.7_Array2_3_4_5_M */
rVIA5_S_7_ARRAY2_3_4_5_M @= { @ "VIA5.S.7_Array2_3_4_5_M : Minimum space between two VIA5 region >= " + VIA_S_3 + " um if the overlap area of 4-level " 
                                                          "continuous stacking VIA arrays >= " + VIA_A_4_B + " um2 (except sealring region)"; 
    sLAYER_208 = interacting( VIA2_4STACK_S_7_p_FINAL, VIA5_VIOLATE_S_4_B2 ); 
    not_interacting( sLAYER_208, SEALRING_ALL ); 
} /* end of rule : VIA5.S.7_Array2_3_4_5_M */
rM2_3_4_5_S_4 @= { @ "M2_3_4_5.S.4 : Minimum space between two Mx region with below conditions >= " + MX_S_3_7 + " um " 
                                    "(a1) both of the Mx with the overlap area of 4-level continuous VIA array area >= " + VIA_A_4_B + " um2 " 
                                    "(a2) Width of 4-level continuous stacking VIA arrays >= " + VIA_W_1 + " um"; 
    sLAYER_210 = M2_REG_4_S_4_C2 or M3_REG_4_S_4_C2; 
    sLAYER_209 = sLAYER_210 or M4_REG_4_S_4_C2; 
    sLAYER_209 or M5_REG_4_S_4_C2; 
} /* end of rule : M2_3_4_5.S.4 */

// Processing for VIAx.S.8 Check    
//**************************************
gLAYER_284 = interacting( M1, VIA1_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
gLAYER_285 = interacting( M2, VIA1_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
gLAYER_283 = gLAYER_284 or gLAYER_285;
gLAYER_286 = interacting( M3, VIA1_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
gLAYER_282 = gLAYER_283 or gLAYER_286;
gLAYER_287 = interacting( M4, VIA1_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
M1_3STACK_S_8_p_PRE3 = gLAYER_282 or gLAYER_287; 
VIA1_3STACK_S_8_p_PRE3 = size_inside_wrapper( VIA1_SAME_ARRAY_3STACK_S_8_p_PRE2, M1_3STACK_S_8_p_PRE3, distance = VIA_S_4, increment = 0.28 ); 
VIA1_3STACK_S_8_p_PRE4 = VIA1_3STACK_S_8_p_PRE3 touching_edge M1_3STACK_S_8_p_PRE3; 
VIA1_3STACK_S_8_p_PRE5 = touching( VIA1_3STACK_S_8_p_PRE3, VIA1_3STACK_S_8_p_PRE4, >= 1 ); 
VIA1_3STACK_S_8_p_FINAL = interacting( VIA1_SAME_ARRAY_3STACK_S_8_p_PRE2, VIA1_3STACK_S_8_p_PRE5 ); 
VIA1_S_3_B1 = interacting( VIA1, VIA1_3STACK_S_8_p_FINAL ); 
VIA1_REG_4_S_3_B1 = external1( VIA1_S_3_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA1s space smaller than 0.49 (inside small array)   */ 
VIA1_VIOLATE_S_3_B1 = interacting( VIA1_S_3_B1, VIA1_REG_4_S_3_B1 ); 
VIA2_S_3_B1 = interacting( VIA2, VIA1_3STACK_S_8_p_FINAL ); 
VIA2_REG_4_S_3_B1 = external1( VIA2_S_3_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_3_B1 = interacting( VIA2_S_3_B1, VIA2_REG_4_S_3_B1 ); 
VIA3_S_3_B1 = interacting( VIA3, VIA1_3STACK_S_8_p_FINAL ); 
VIA3_REG_4_S_3_B1 = external1( VIA3_S_3_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_3_B1 = interacting( VIA3_S_3_B1, VIA3_REG_4_S_3_B1 ); 
gLAYER_290 = interacting( M2, VIA2_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
gLAYER_291 = interacting( M3, VIA2_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
gLAYER_289 = gLAYER_290 or gLAYER_291;
gLAYER_292 = interacting( M4, VIA2_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
gLAYER_288 = gLAYER_289 or gLAYER_292;
gLAYER_293 = interacting( M5, VIA2_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
M2_3STACK_S_8_p_PRE3 = gLAYER_288 or gLAYER_293; 
VIA2_3STACK_S_8_p_PRE3 = size_inside_wrapper( VIA2_SAME_ARRAY_3STACK_S_8_p_PRE2, M2_3STACK_S_8_p_PRE3, distance = VIA_S_4, increment = 0.28 ); 
VIA2_3STACK_S_8_p_PRE4 = VIA2_3STACK_S_8_p_PRE3 touching_edge M2_3STACK_S_8_p_PRE3; 
VIA2_3STACK_S_8_p_PRE5 = touching( VIA2_3STACK_S_8_p_PRE3, VIA2_3STACK_S_8_p_PRE4, >= 1 ); 
VIA2_3STACK_S_8_p_FINAL = interacting( VIA2_SAME_ARRAY_3STACK_S_8_p_PRE2, VIA2_3STACK_S_8_p_PRE5 ); 
VIA2_S_3_B2 = interacting( VIA2, VIA2_3STACK_S_8_p_FINAL ); 
VIA2_REG_4_S_3_B2 = external1( VIA2_S_3_B2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_3_B2 = interacting( VIA2_S_3_B2, VIA2_REG_4_S_3_B2 ); 
VIA3_S_3_B2 = interacting( VIA3, VIA2_3STACK_S_8_p_FINAL ); 
VIA3_REG_4_S_3_B2 = external1( VIA3_S_3_B2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_3_B2 = interacting( VIA3_S_3_B2, VIA3_REG_4_S_3_B2 ); 
VIA4_S_3_B2 = interacting( VIA4, VIA2_3STACK_S_8_p_FINAL ); 
VIA4_REG_4_S_3_B2 = external1( VIA4_S_3_B2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_3_B2 = interacting( VIA4_S_3_B2, VIA4_REG_4_S_3_B2 ); 
gLAYER_296 = interacting( M3, VIA3_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
gLAYER_297 = interacting( M4, VIA3_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
gLAYER_295 = gLAYER_296 or gLAYER_297;
gLAYER_298 = interacting( M5, VIA3_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
gLAYER_294 = gLAYER_295 or gLAYER_298;
gLAYER_299 = interacting( M6, VIA3_SAME_ARRAY_3STACK_S_8_p_PRE2 ); 
M3_3STACK_S_8_p_PRE3 = gLAYER_294 or gLAYER_299; 
VIA3_3STACK_S_8_p_PRE3 = size_inside_wrapper( VIA3_SAME_ARRAY_3STACK_S_8_p_PRE2, M3_3STACK_S_8_p_PRE3, distance = VIA_S_4, increment = 0.28 ); 
VIA3_3STACK_S_8_p_PRE4 = VIA3_3STACK_S_8_p_PRE3 touching_edge M3_3STACK_S_8_p_PRE3; 
VIA3_3STACK_S_8_p_PRE5 = touching( VIA3_3STACK_S_8_p_PRE3, VIA3_3STACK_S_8_p_PRE4, >= 1 ); 
VIA3_3STACK_S_8_p_FINAL = interacting( VIA3_SAME_ARRAY_3STACK_S_8_p_PRE2, VIA3_3STACK_S_8_p_PRE5 ); 
VIA3_S_3_B3 = interacting( VIA3, VIA3_3STACK_S_8_p_FINAL ); 
VIA3_REG_4_S_3_B3 = external1( VIA3_S_3_B3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_3_B3 = interacting( VIA3_S_3_B3, VIA3_REG_4_S_3_B3 ); 
VIA4_S_3_B3 = interacting( VIA4, VIA3_3STACK_S_8_p_FINAL ); 
VIA4_REG_4_S_3_B3 = external1( VIA4_S_3_B3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_3_B3 = interacting( VIA4_S_3_B3, VIA4_REG_4_S_3_B3 ); 
VIA5_S_3_B3 = interacting( VIA5, VIA3_3STACK_S_8_p_FINAL ); 
VIA5_REG_4_S_3_B3 = external1( VIA5_S_3_B3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA5s space smaller than 0.49 (inside small array)   */ 
VIA5_VIOLATE_S_3_B3 = interacting( VIA5_S_3_B3, VIA5_REG_4_S_3_B3 ); 

// Processing for Mx.S.5 Check    
//**************************************
VIA1_3STACK_MX_S5_p_PRE3 = contains( VIA1_SAME_ARRAY_3STACK_MX_S5_p_PRE2, { VIA_W_1, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
M1_S_3_C1 = enclose_edge( VIA1_3STACK_MX_S5_p_PRE3, M1, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M1_REG_4_S_3_C1 = external1( M1_S_3_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M1s space smaller than 1.2    */ 
M2_S_3_C1 = enclose_edge( VIA1_3STACK_MX_S5_p_PRE3, M2, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M2_REG_4_S_3_C1 = external1( M2_S_3_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M2s space smaller than 1.2    */ 
M3_S_3_C1 = enclose_edge( VIA1_3STACK_MX_S5_p_PRE3, M3, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M3_REG_4_S_3_C1 = external1( M3_S_3_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M3s space smaller than 1.2    */ 
VIA2_3STACK_MX_S5_p_PRE3 = contains( VIA2_SAME_ARRAY_3STACK_MX_S5_p_PRE2, { VIA_W_1, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
M2_S_3_C2 = enclose_edge( VIA2_3STACK_MX_S5_p_PRE3, M2, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M2_REG_4_S_3_C2 = external1( M2_S_3_C2, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M2s space smaller than 1.2    */ 
M3_S_3_C2 = enclose_edge( VIA2_3STACK_MX_S5_p_PRE3, M3, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M3_REG_4_S_3_C2 = external1( M3_S_3_C2, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M3s space smaller than 1.2    */ 
M4_S_3_C2 = enclose_edge( VIA2_3STACK_MX_S5_p_PRE3, M4, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M4_REG_4_S_3_C2 = external1( M4_S_3_C2, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M4s space smaller than 1.2    */ 
VIA3_3STACK_MX_S5_p_PRE3 = contains( VIA3_SAME_ARRAY_3STACK_MX_S5_p_PRE2, { VIA_W_1, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
M3_S_3_C3 = enclose_edge( VIA3_3STACK_MX_S5_p_PRE3, M3, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M3_REG_4_S_3_C3 = external1( M3_S_3_C3, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M3s space smaller than 1.2    */ 
M4_S_3_C3 = enclose_edge( VIA3_3STACK_MX_S5_p_PRE3, M4, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M4_REG_4_S_3_C3 = external1( M4_S_3_C3, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M4s space smaller than 1.2    */ 
M5_S_3_C3 = enclose_edge( VIA3_3STACK_MX_S5_p_PRE3, M5, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M5_REG_4_S_3_C3 = external1( M5_S_3_C3, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M5s space smaller than 1.2    */ 
rVIA1_S_4_ARRAY1_2_3_M @= { @ "VIA1.S.4_Array1_2_3_M : Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um "
                                                      "Via1 violate " + VIA_S_3 + " spacing in Via1/Via2/Via3 array & density large or equal " + VIA_D_1; 
    A1 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA1_VIOLATE_S_3_A1, "layer2" => VIA1_3STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A2 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA2_VIOLATE_S_3_A1, "layer2" => VIA1_3STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A3 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA3_VIOLATE_S_3_A1, "layer2" => VIA1_3STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    sLAYER_211 = A1 or A2; 
    B1 = sLAYER_211 or A3; 
    size( size( B1, VIA_MERGE, clip_acute = NONE ), - VIA_MERGE, clip_acute = NONE ); 
} /* end of rule : VIA1.S.4_Array1_2_3_M */
rM1_2_3_S_5 @= { @ "M1_2_3.S.5 : Minimum space between two Mx region with below conditions >= " + MX_S_3_7 + " um " 
                                "(a1) both of the Mx with the overlap area of 3-level continuous VIA array area >= " + VIA_A_3_B + " um2 " 
                                "(a2) Width of 3-level continuous stacking VIA arrays >= " + VIA_W_1 + " um"; 
    sLAYER_212 = M1_REG_4_S_3_C1 or M2_REG_4_S_3_C1; 
    sLAYER_212 or M3_REG_4_S_3_C1; 
} /* end of rule : M1_2_3.S.5 */
rVIA2_S_4_ARRAY2_3_4_M @= { @ "VIA2.S.4_Array2_3_4_M : Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um "
                                                      "Via2 violate " + VIA_S_3 + " spacing in Via2/Via3/Via4 array & density large or equal " + VIA_D_1; 
    A2 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA2_VIOLATE_S_3_A2, "layer2" => VIA2_3STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A3 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA3_VIOLATE_S_3_A2, "layer2" => VIA2_3STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A4 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA4_VIOLATE_S_3_A2, "layer2" => VIA2_3STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    sLAYER_213 = A2 or A3; 
    B2 = sLAYER_213 or A4; 
    size( size( B2, VIA_MERGE, clip_acute = NONE ), - VIA_MERGE, clip_acute = NONE ); 
} /* end of rule : VIA2.S.4_Array2_3_4_M */
rM2_3_4_S_5 @= { @ "M2_3_4.S.5 : Minimum space between two Mx region with below conditions >= " + MX_S_3_7 + " um " 
                                "(a1) both of the Mx with the overlap area of 3-level continuous VIA array area >= " + VIA_A_3_B + " um2 " 
                                "(a2) Width of 3-level continuous stacking VIA arrays >= " + VIA_W_1 + " um"; 
    sLAYER_214 = M2_REG_4_S_3_C2 or M3_REG_4_S_3_C2; 
    sLAYER_214 or M4_REG_4_S_3_C2; 
} /* end of rule : M2_3_4.S.5 */
rVIA2_S_8_ARRAY2_3_4_M @= { @ "VIA2.S.8_Array2_3_4_M : Minimum space between two VIA2 region >= " + VIA_S_3 + " um if the overlap area of 3-level " 
                                                      "continuous stacking VIA arrays >= " + VIA_A_3_B + " um2 (except sealring region)"; 
    sLAYER_215 = interacting( VIA2_3STACK_S_8_p_FINAL, VIA2_VIOLATE_S_3_B2 ); 
    not_interacting( sLAYER_215, SEALRING_ALL ); 
} /* end of rule : VIA2.S.8_Array2_3_4_M */
rVIA3_S_8_ARRAY2_3_4_M @= { @ "VIA3.S.8_Array2_3_4_M : Minimum space between two VIA3 region >= " + VIA_S_3 + " um if the overlap area of 3-level " 
                                                      "continuous stacking VIA arrays >= " + VIA_A_3_B + " um2 (except sealring region)"; 
    sLAYER_216 = interacting( VIA2_3STACK_S_8_p_FINAL, VIA3_VIOLATE_S_3_B2 ); 
    not_interacting( sLAYER_216, SEALRING_ALL ); 
} /* end of rule : VIA3.S.8_Array2_3_4_M */
rVIA4_S_8_ARRAY2_3_4_M @= { @ "VIA4.S.8_Array2_3_4_M : Minimum space between two VIA4 region >= " + VIA_S_3 + " um if the overlap area of 3-level " 
                                                      "continuous stacking VIA arrays >= " + VIA_A_3_B + " um2 (except sealring region)"; 
    sLAYER_217 = interacting( VIA2_3STACK_S_8_p_FINAL, VIA4_VIOLATE_S_3_B2 ); 
    not_interacting( sLAYER_217, SEALRING_ALL ); 
} /* end of rule : VIA4.S.8_Array2_3_4_M */
rVIA3_S_4_ARRAY3_4_5_M @= { @ "VIA3.S.4_Array3_4_5_M : Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um "
                                                      "Via3 violate " + VIA_S_3 + " spacing in Via3/Via4/Via5 array & density large or equal " + VIA_D_1; 
    A3 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA3_VIOLATE_S_3_A3, "layer2" => VIA3_3STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A4 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA4_VIOLATE_S_3_A3, "layer2" => VIA3_3STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A5 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA5_VIOLATE_S_3_A3, "layer2" => VIA3_3STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    sLAYER_218 = A3 or A4; 
    B3 = sLAYER_218 or A5; 
    size( size( B3, VIA_MERGE, clip_acute = NONE ), - VIA_MERGE, clip_acute = NONE ); 
} /* end of rule : VIA3.S.4_Array3_4_5_M */
rVIA3_S_8_ARRAY3_4_5_M @= { @ "VIA3.S.8_Array3_4_5_M : Minimum space between two VIA3 region >= " + VIA_S_3 + " um if the overlap area of 3-level " 
                                                      "continuous stacking VIA arrays >= " + VIA_A_3_B + " um2 (except sealring region)"; 
    sLAYER_219 = interacting( VIA3_3STACK_S_8_p_FINAL, VIA3_VIOLATE_S_3_B3 ); 
    not_interacting( sLAYER_219, SEALRING_ALL ); 
} /* end of rule : VIA3.S.8_Array3_4_5_M */
rVIA4_S_8_ARRAY3_4_5_M @= { @ "VIA4.S.8_Array3_4_5_M : Minimum space between two VIA4 region >= " + VIA_S_3 + " um if the overlap area of 3-level " 
                                                      "continuous stacking VIA arrays >= " + VIA_A_3_B + " um2 (except sealring region)"; 
    sLAYER_220 = interacting( VIA3_3STACK_S_8_p_FINAL, VIA4_VIOLATE_S_3_B3 ); 
    not_interacting( sLAYER_220, SEALRING_ALL ); 
} /* end of rule : VIA4.S.8_Array3_4_5_M */
rVIA5_S_8_ARRAY3_4_5_M @= { @ "VIA5.S.8_Array3_4_5_M : Minimum space between two VIA5 region >= " + VIA_S_3 + " um if the overlap area of 3-level " 
                                                      "continuous stacking VIA arrays >= " + VIA_A_3_B + " um2 (except sealring region)"; 
    sLAYER_221 = interacting( VIA3_3STACK_S_8_p_FINAL, VIA5_VIOLATE_S_3_B3 ); 
    not_interacting( sLAYER_221, SEALRING_ALL ); 
} /* end of rule : VIA5.S.8_Array3_4_5_M */
rM3_4_5_S_5 @= { @ "M3_4_5.S.5 : Minimum space between two Mx region with below conditions >= " + MX_S_3_7 + " um " 
                                "(a1) both of the Mx with the overlap area of 3-level continuous VIA array area >= " + VIA_A_3_B + " um2 " 
                                "(a2) Width of 3-level continuous stacking VIA arrays >= " + VIA_W_1 + " um"; 
    sLAYER_222 = M3_REG_4_S_3_C3 or M4_REG_4_S_3_C3; 
    sLAYER_222 or M5_REG_4_S_3_C3; 
} /* end of rule : M3_4_5.S.5 */

// Processing for VIAx.S.9 Check    
//**************************************
gLAYER_329 = interacting( M1, VIA1_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
gLAYER_330 = interacting( M2, VIA1_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
gLAYER_328 = gLAYER_329 or gLAYER_330;
gLAYER_331 = interacting( M3, VIA1_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
M1_2STACK_S_9_p_PRE3 = gLAYER_328 or gLAYER_331; 
VIA1_2STACK_S_9_p_PRE3 = size_inside_wrapper( VIA1_SAME_ARRAY_2STACK_S_9_p_PRE2, M1_2STACK_S_9_p_PRE3, distance = VIA_S_4, increment = 0.28 ); 
VIA1_2STACK_S_9_p_PRE4 = VIA1_2STACK_S_9_p_PRE3 touching_edge M1_2STACK_S_9_p_PRE3; 
VIA1_2STACK_S_9_p_PRE5 = touching( VIA1_2STACK_S_9_p_PRE3, VIA1_2STACK_S_9_p_PRE4, >= 1 ); 
VIA1_2STACK_S_9_p_FINAL = interacting( VIA1_SAME_ARRAY_2STACK_S_9_p_PRE2, VIA1_2STACK_S_9_p_PRE5 ); 
VIA1_S_2_B1 = interacting( VIA1, VIA1_2STACK_S_9_p_FINAL ); 
VIA1_REG_4_S_2_B1 = external1( VIA1_S_2_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA1s space smaller than 0.49 (inside small array)   */ 
VIA1_VIOLATE_S_2_B1 = interacting( VIA1_S_2_B1, VIA1_REG_4_S_2_B1 ); 
VIA2_S_2_B1 = interacting( VIA2, VIA1_2STACK_S_9_p_FINAL ); 
VIA2_REG_4_S_2_B1 = external1( VIA2_S_2_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_2_B1 = interacting( VIA2_S_2_B1, VIA2_REG_4_S_2_B1 ); 
gLAYER_333 = interacting( M2, VIA2_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
gLAYER_334 = interacting( M3, VIA2_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
gLAYER_332 = gLAYER_333 or gLAYER_334;
gLAYER_335 = interacting( M4, VIA2_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
M2_2STACK_S_9_p_PRE3 = gLAYER_332 or gLAYER_335; 
VIA2_2STACK_S_9_p_PRE3 = size_inside_wrapper( VIA2_SAME_ARRAY_2STACK_S_9_p_PRE2, M2_2STACK_S_9_p_PRE3, distance = VIA_S_4, increment = 0.28 ); 
VIA2_2STACK_S_9_p_PRE4 = VIA2_2STACK_S_9_p_PRE3 touching_edge M2_2STACK_S_9_p_PRE3; 
VIA2_2STACK_S_9_p_PRE5 = touching( VIA2_2STACK_S_9_p_PRE3, VIA2_2STACK_S_9_p_PRE4, >= 1 ); 
VIA2_2STACK_S_9_p_FINAL = interacting( VIA2_SAME_ARRAY_2STACK_S_9_p_PRE2, VIA2_2STACK_S_9_p_PRE5 ); 
VIA2_S_2_B2 = interacting( VIA2, VIA2_2STACK_S_9_p_FINAL ); 
VIA2_REG_4_S_2_B2 = external1( VIA2_S_2_B2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_2_B2 = interacting( VIA2_S_2_B2, VIA2_REG_4_S_2_B2 ); 
VIA3_S_2_B2 = interacting( VIA3, VIA2_2STACK_S_9_p_FINAL ); 
VIA3_REG_4_S_2_B2 = external1( VIA3_S_2_B2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_2_B2 = interacting( VIA3_S_2_B2, VIA3_REG_4_S_2_B2 ); 
gLAYER_337 = interacting( M3, VIA3_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
gLAYER_338 = interacting( M4, VIA3_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
gLAYER_336 = gLAYER_337 or gLAYER_338;
gLAYER_339 = interacting( M5, VIA3_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
M3_2STACK_S_9_p_PRE3 = gLAYER_336 or gLAYER_339; 
VIA3_2STACK_S_9_p_PRE3 = size_inside_wrapper( VIA3_SAME_ARRAY_2STACK_S_9_p_PRE2, M3_2STACK_S_9_p_PRE3, distance = VIA_S_4, increment = 0.28 ); 
VIA3_2STACK_S_9_p_PRE4 = VIA3_2STACK_S_9_p_PRE3 touching_edge M3_2STACK_S_9_p_PRE3; 
VIA3_2STACK_S_9_p_PRE5 = touching( VIA3_2STACK_S_9_p_PRE3, VIA3_2STACK_S_9_p_PRE4, >= 1 ); 
VIA3_2STACK_S_9_p_FINAL = interacting( VIA3_SAME_ARRAY_2STACK_S_9_p_PRE2, VIA3_2STACK_S_9_p_PRE5 ); 
VIA3_S_2_B3 = interacting( VIA3, VIA3_2STACK_S_9_p_FINAL ); 
VIA3_REG_4_S_2_B3 = external1( VIA3_S_2_B3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_2_B3 = interacting( VIA3_S_2_B3, VIA3_REG_4_S_2_B3 ); 
VIA4_S_2_B3 = interacting( VIA4, VIA3_2STACK_S_9_p_FINAL ); 
VIA4_REG_4_S_2_B3 = external1( VIA4_S_2_B3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_2_B3 = interacting( VIA4_S_2_B3, VIA4_REG_4_S_2_B3 ); 
gLAYER_341 = interacting( M4, VIA4_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
gLAYER_342 = interacting( M5, VIA4_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
gLAYER_340 = gLAYER_341 or gLAYER_342;
gLAYER_343 = interacting( M6, VIA4_SAME_ARRAY_2STACK_S_9_p_PRE2 ); 
M4_2STACK_S_9_p_PRE3 = gLAYER_340 or gLAYER_343; 
VIA4_2STACK_S_9_p_PRE3 = size_inside_wrapper( VIA4_SAME_ARRAY_2STACK_S_9_p_PRE2, M4_2STACK_S_9_p_PRE3, distance = VIA_S_4, increment = 0.28 ); 
VIA4_2STACK_S_9_p_PRE4 = VIA4_2STACK_S_9_p_PRE3 touching_edge M4_2STACK_S_9_p_PRE3; 
VIA4_2STACK_S_9_p_PRE5 = touching( VIA4_2STACK_S_9_p_PRE3, VIA4_2STACK_S_9_p_PRE4, >= 1 ); 
VIA4_2STACK_S_9_p_FINAL = interacting( VIA4_SAME_ARRAY_2STACK_S_9_p_PRE2, VIA4_2STACK_S_9_p_PRE5 ); 
VIA4_S_2_B4 = interacting( VIA4, VIA4_2STACK_S_9_p_FINAL ); 
VIA4_REG_4_S_2_B4 = external1( VIA4_S_2_B4, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_2_B4 = interacting( VIA4_S_2_B4, VIA4_REG_4_S_2_B4 ); 
VIA5_S_2_B4 = interacting( VIA5, VIA4_2STACK_S_9_p_FINAL ); 
VIA5_REG_4_S_2_B4 = external1( VIA5_S_2_B4, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA5s space smaller than 0.49 (inside small array)   */ 
VIA5_VIOLATE_S_2_B4 = interacting( VIA5_S_2_B4, VIA5_REG_4_S_2_B4 ); 

// Processing for Mx.S.6 Check    
//**************************************
VIA1_2STACK_MX_S6_p_PRE3 = contains( VIA1_SAME_ARRAY_2STACK_MX_S6_p_PRE2, { VIA_W_1, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
M1_S_2_C1 = enclose_edge( VIA1_2STACK_MX_S6_p_PRE3, M1, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M1_REG_4_S_2_C1 = external1( M1_S_2_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M1s space smaller than 1.2    */ 
M2_S_2_C1 = enclose_edge( VIA1_2STACK_MX_S6_p_PRE3, M2, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M2_REG_4_S_2_C1 = external1( M2_S_2_C1, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M2s space smaller than 1.2    */ 
VIA2_2STACK_MX_S6_p_PRE3 = contains( VIA2_SAME_ARRAY_2STACK_MX_S6_p_PRE2, { VIA_W_1, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
M2_S_2_C2 = enclose_edge( VIA2_2STACK_MX_S6_p_PRE3, M2, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M2_REG_4_S_2_C2 = external1( M2_S_2_C2, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M2s space smaller than 1.2    */ 
M3_S_2_C2 = enclose_edge( VIA2_2STACK_MX_S6_p_PRE3, M3, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M3_REG_4_S_2_C2 = external1( M3_S_2_C2, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M3s space smaller than 1.2    */ 
VIA3_2STACK_MX_S6_p_PRE3 = contains( VIA3_SAME_ARRAY_2STACK_MX_S6_p_PRE2, { VIA_W_1, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
M3_S_2_C3 = enclose_edge( VIA3_2STACK_MX_S6_p_PRE3, M3, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M3_REG_4_S_2_C3 = external1( M3_S_2_C3, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M3s space smaller than 1.2    */ 
M4_S_2_C3 = enclose_edge( VIA3_2STACK_MX_S6_p_PRE3, M4, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M4_REG_4_S_2_C3 = external1( M4_S_2_C3, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M4s space smaller than 1.2    */ 
VIA4_2STACK_MX_S6_p_PRE3 = contains( VIA4_SAME_ARRAY_2STACK_MX_S6_p_PRE2, { VIA_W_1, VIA_W_1 }, FORTY_FIVE );    /* Find at least one width >= VIA_W_1 */ 
M4_S_2_C4 = enclose_edge( VIA4_2STACK_MX_S6_p_PRE3, M4, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M4_REG_4_S_2_C4 = external1( M4_S_2_C4, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M4s space smaller than 1.2    */ 
M5_S_2_C4 = enclose_edge( VIA4_2STACK_MX_S6_p_PRE3, M5, <= VIA_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
M5_REG_4_S_2_C4 = external1( M5_S_2_C4, < MX_S_3_7, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* M5s space smaller than 1.2    */ 
rVIA1_S_5_ARRAY1_2_M @= { @ "VIA1.S.5_Array1_2_M : Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um "
                                                  "Via1 violate " + VIA_S_3 + " spacing in Via1/Via2 array & density large or equal " + VIA_D_1; 
    A1 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA1_VIOLATE_S_2_A1, "layer2" => VIA1_2STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A2 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA2_VIOLATE_S_2_A1, "layer2" => VIA1_2STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    B1 = A1 or A2; 
    size( size( B1, VIA_MERGE, clip_acute = NONE ), - VIA_MERGE, clip_acute = NONE ); 
} /* end of rule : VIA1.S.5_Array1_2_M */
rM1_2_S_6 @= { @ "M1_2.S.6 : Minimum space between two Mx region with below conditions >= " + MX_S_3_7 + " um " 
                            "(a1) both of the Mx with the overlap area of 2-level continuous VIA array area >= " + VIA_A_2_B + " um2 " 
                            "(a2) Width of 2-level continuous stacking VIA arrays >= " + VIA_W_1 + " um"; 
    M1_REG_4_S_2_C1 or M2_REG_4_S_2_C1; 
} /* end of rule : M1_2.S.6 */
rVIA2_S_5_ARRAY2_3_M @= { @ "VIA2.S.5_Array2_3_M : Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um "
                                                  "Via2 violate " + VIA_S_3 + " spacing in Via2/Via3 array & density large or equal " + VIA_D_1; 
    A2 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA2_VIOLATE_S_2_A2, "layer2" => VIA2_2STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A3 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA3_VIOLATE_S_2_A2, "layer2" => VIA2_2STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    B2 = A2 or A3; 
    size( size( B2, VIA_MERGE, clip_acute = NONE ), - VIA_MERGE, clip_acute = NONE ); 
} /* end of rule : VIA2.S.5_Array2_3_M */
rM2_3_S_6 @= { @ "M2_3.S.6 : Minimum space between two Mx region with below conditions >= " + MX_S_3_7 + " um " 
                            "(a1) both of the Mx with the overlap area of 2-level continuous VIA array area >= " + VIA_A_2_B + " um2 " 
                            "(a2) Width of 2-level continuous stacking VIA arrays >= " + VIA_W_1 + " um"; 
    M2_REG_4_S_2_C2 or M3_REG_4_S_2_C2; 
} /* end of rule : M2_3.S.6 */
rVIA3_S_5_ARRAY3_4_M @= { @ "VIA3.S.5_Array3_4_M : Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um "
                                                  "Via3 violate " + VIA_S_3 + " spacing in Via3/Via4 array & density large or equal " + VIA_D_1; 
    A3 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA3_VIOLATE_S_2_A3, "layer2" => VIA3_2STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A4 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA4_VIOLATE_S_2_A3, "layer2" => VIA3_2STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    B3 = A3 or A4; 
    size( size( B3, VIA_MERGE, clip_acute = NONE ), - VIA_MERGE, clip_acute = NONE ); 
} /* end of rule : VIA3.S.5_Array3_4_M */
rM3_4_S_6 @= { @ "M3_4.S.6 : Minimum space between two Mx region with below conditions >= " + MX_S_3_7 + " um " 
                            "(a1) both of the Mx with the overlap area of 2-level continuous VIA array area >= " + VIA_A_2_B + " um2 " 
                            "(a2) Width of 2-level continuous stacking VIA arrays >= " + VIA_W_1 + " um"; 
    M3_REG_4_S_2_C3 or M4_REG_4_S_2_C3; 
} /* end of rule : M3_4.S.6 */
rVIA3_S_9_ARRAY3_4_M @= { @ "VIA3.S.9_Array3_4_M : Minimum space between two VIA3 region >= " + VIA_S_3 + " um if the overlap area of 2-level " 
                                                  "continuous stacking VIA arrays >= " + VIA_A_2_B + " um2 (except sealring region)"; 
    sLAYER_223 = interacting( VIA3_2STACK_S_9_p_FINAL, VIA3_VIOLATE_S_2_B3 ); 
    not_interacting( sLAYER_223, SEALRING_ALL ); 
} /* end of rule : VIA3.S.9_Array3_4_M */
rVIA4_S_9_ARRAY3_4_M @= { @ "VIA4.S.9_Array3_4_M : Minimum space between two VIA4 region >= " + VIA_S_3 + " um if the overlap area of 2-level " 
                                                  "continuous stacking VIA arrays >= " + VIA_A_2_B + " um2 (except sealring region)"; 
    sLAYER_224 = interacting( VIA3_2STACK_S_9_p_FINAL, VIA4_VIOLATE_S_2_B3 ); 
    not_interacting( sLAYER_224, SEALRING_ALL ); 
} /* end of rule : VIA4.S.9_Array3_4_M */
rVIA4_S_5_ARRAY4_5_M @= { @ "VIA4.S.5_Array4_5_M : Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um "
                                                  "Via4 violate " + VIA_S_3 + " spacing in Via4/Via5 array & density large or equal " + VIA_D_1; 
    A4 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA4_VIOLATE_S_2_A4, "layer2" => VIA4_2STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    A5 = net_area_ratio( CONNECT_DB, >= VIA_D_1, { "layer1" => VIA5_VIOLATE_S_2_A4, "layer2" => VIA4_2STACK_p_FINAL }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
    B4 = A4 or A5; 
    size( size( B4, VIA_MERGE, clip_acute = NONE ), - VIA_MERGE, clip_acute = NONE ); 
} /* end of rule : VIA4.S.5_Array4_5_M */
rVIA4_S_9_ARRAY4_5_M @= { @ "VIA4.S.9_Array4_5_M : Minimum space between two VIA4 region >= " + VIA_S_3 + " um if the overlap area of 2-level " 
                                                  "continuous stacking VIA arrays >= " + VIA_A_2_B + " um2 (except sealring region)"; 
    sLAYER_225 = interacting( VIA4_2STACK_S_9_p_FINAL, VIA4_VIOLATE_S_2_B4 ); 
    not_interacting( sLAYER_225, SEALRING_ALL ); 
} /* end of rule : VIA4.S.9_Array4_5_M */
rVIA5_S_9_ARRAY4_5_M @= { @ "VIA5.S.9_Array4_5_M : Minimum space between two VIA5 region >= " + VIA_S_3 + " um if the overlap area of 2-level " 
                                                  "continuous stacking VIA arrays >= " + VIA_A_2_B + " um2 (except sealring region)"; 
    sLAYER_226 = interacting( VIA4_2STACK_S_9_p_FINAL, VIA5_VIOLATE_S_2_B4 ); 
    not_interacting( sLAYER_226, SEALRING_ALL ); 
} /* end of rule : VIA5.S.9_Array4_5_M */
rM4_5_S_6 @= { @ "M4_5.S.6 : Minimum space between two Mx region with below conditions >= " + MX_S_3_7 + " um " 
                            "(a1) both of the Mx with the overlap area of 2-level continuous VIA array area >= " + VIA_A_2_B + " um2 " 
                            "(a2) Width of 2-level continuous stacking VIA arrays >= " + VIA_W_1 + " um"; 
    M4_REG_4_S_2_C4 or M5_REG_4_S_2_C4; 
} /* end of rule : M4_5.S.6 */

//****************************  
// Small single layer array
//****************************
// Processing for VIAx.S.10 Check    
//**************************************
gLAYER_344 = interacting( M1, VIA1_SAME_ARRAY_1STACK_S_10_p_PRE1 ); 
gLAYER_345 = interacting( M2, VIA1_SAME_ARRAY_1STACK_S_10_p_PRE1 ); 
M1_1STACK_S_10_p_PRE2 = gLAYER_344 or gLAYER_345; 
VIA1_1STACK_S_10_p_PRE2 = size_inside_wrapper( VIA1_SAME_ARRAY_1STACK_S_10_p_PRE1, M1_1STACK_S_10_p_PRE2, distance = VIA_S_4, increment = 0.28 ); 
VIA1_1STACK_S_10_p_PRE3 = VIA1_1STACK_S_10_p_PRE2 touching_edge M1_1STACK_S_10_p_PRE2; 
VIA1_1STACK_S_10_p_PRE4 = touching( VIA1_1STACK_S_10_p_PRE2, VIA1_1STACK_S_10_p_PRE3, >= 1 ); 
VIA1_1STACK_S_10_p_FINAL = interacting( VIA1_SAME_ARRAY_1STACK_S_10_p_PRE1, VIA1_1STACK_S_10_p_PRE4 ); 
VIA1_S_1_B1 = interacting( VIA1, VIA1_1STACK_S_10_p_FINAL ); 
VIA1_REG_4_S_1_B1 = external1( VIA1_S_1_B1, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA1s space smaller than 0.49 (inside small array)   */ 
VIA1_VIOLATE_S_1_B1 = interacting( VIA1_S_1_B1, VIA1_REG_4_S_1_B1 ); 
gLAYER_346 = interacting( M2, VIA2_SAME_ARRAY_1STACK_S_10_p_PRE1 ); 
gLAYER_347 = interacting( M3, VIA2_SAME_ARRAY_1STACK_S_10_p_PRE1 ); 
M2_1STACK_S_10_p_PRE2 = gLAYER_346 or gLAYER_347; 
VIA2_1STACK_S_10_p_PRE2 = size_inside_wrapper( VIA2_SAME_ARRAY_1STACK_S_10_p_PRE1, M2_1STACK_S_10_p_PRE2, distance = VIA_S_4, increment = 0.28 ); 
VIA2_1STACK_S_10_p_PRE3 = VIA2_1STACK_S_10_p_PRE2 touching_edge M2_1STACK_S_10_p_PRE2; 
VIA2_1STACK_S_10_p_PRE4 = touching( VIA2_1STACK_S_10_p_PRE2, VIA2_1STACK_S_10_p_PRE3, >= 1 ); 
VIA2_1STACK_S_10_p_FINAL = interacting( VIA2_SAME_ARRAY_1STACK_S_10_p_PRE1, VIA2_1STACK_S_10_p_PRE4 ); 
VIA2_S_1_B2 = interacting( VIA2, VIA2_1STACK_S_10_p_FINAL ); 
VIA2_REG_4_S_1_B2 = external1( VIA2_S_1_B2, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA2s space smaller than 0.49 (inside small array)   */ 
VIA2_VIOLATE_S_1_B2 = interacting( VIA2_S_1_B2, VIA2_REG_4_S_1_B2 ); 
gLAYER_348 = interacting( M3, VIA3_SAME_ARRAY_1STACK_S_10_p_PRE1 ); 
gLAYER_349 = interacting( M4, VIA3_SAME_ARRAY_1STACK_S_10_p_PRE1 ); 
M3_1STACK_S_10_p_PRE2 = gLAYER_348 or gLAYER_349; 
VIA3_1STACK_S_10_p_PRE2 = size_inside_wrapper( VIA3_SAME_ARRAY_1STACK_S_10_p_PRE1, M3_1STACK_S_10_p_PRE2, distance = VIA_S_4, increment = 0.28 ); 
VIA3_1STACK_S_10_p_PRE3 = VIA3_1STACK_S_10_p_PRE2 touching_edge M3_1STACK_S_10_p_PRE2; 
VIA3_1STACK_S_10_p_PRE4 = touching( VIA3_1STACK_S_10_p_PRE2, VIA3_1STACK_S_10_p_PRE3, >= 1 ); 
VIA3_1STACK_S_10_p_FINAL = interacting( VIA3_SAME_ARRAY_1STACK_S_10_p_PRE1, VIA3_1STACK_S_10_p_PRE4 ); 
VIA3_S_1_B3 = interacting( VIA3, VIA3_1STACK_S_10_p_FINAL ); 
VIA3_REG_4_S_1_B3 = external1( VIA3_S_1_B3, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA3s space smaller than 0.49 (inside small array)   */ 
VIA3_VIOLATE_S_1_B3 = interacting( VIA3_S_1_B3, VIA3_REG_4_S_1_B3 ); 
gLAYER_350 = interacting( M4, VIA4_SAME_ARRAY_1STACK_S_10_p_PRE1 ); 
gLAYER_351 = interacting( M5, VIA4_SAME_ARRAY_1STACK_S_10_p_PRE1 ); 
M4_1STACK_S_10_p_PRE2 = gLAYER_350 or gLAYER_351; 
VIA4_1STACK_S_10_p_PRE2 = size_inside_wrapper( VIA4_SAME_ARRAY_1STACK_S_10_p_PRE1, M4_1STACK_S_10_p_PRE2, distance = VIA_S_4, increment = 0.28 ); 
VIA4_1STACK_S_10_p_PRE3 = VIA4_1STACK_S_10_p_PRE2 touching_edge M4_1STACK_S_10_p_PRE2; 
VIA4_1STACK_S_10_p_PRE4 = touching( VIA4_1STACK_S_10_p_PRE2, VIA4_1STACK_S_10_p_PRE3, >= 1 ); 
VIA4_1STACK_S_10_p_FINAL = interacting( VIA4_SAME_ARRAY_1STACK_S_10_p_PRE1, VIA4_1STACK_S_10_p_PRE4 ); 
VIA4_S_1_B4 = interacting( VIA4, VIA4_1STACK_S_10_p_FINAL ); 
VIA4_REG_4_S_1_B4 = external1( VIA4_S_1_B4, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA4s space smaller than 0.49 (inside small array)   */ 
VIA4_VIOLATE_S_1_B4 = interacting( VIA4_S_1_B4, VIA4_REG_4_S_1_B4 ); 
gLAYER_352 = interacting( M5, VIA5_SAME_ARRAY_1STACK_S_10_p_PRE1 ); 
gLAYER_353 = interacting( M6, VIA5_SAME_ARRAY_1STACK_S_10_p_PRE1 ); 
M5_1STACK_S_10_p_PRE2 = gLAYER_352 or gLAYER_353; 
VIA5_1STACK_S_10_p_PRE2 = size_inside_wrapper( VIA5_SAME_ARRAY_1STACK_S_10_p_PRE1, M5_1STACK_S_10_p_PRE2, distance = VIA_S_4, increment = 0.28 ); 
VIA5_1STACK_S_10_p_PRE3 = VIA5_1STACK_S_10_p_PRE2 touching_edge M5_1STACK_S_10_p_PRE2; 
VIA5_1STACK_S_10_p_PRE4 = touching( VIA5_1STACK_S_10_p_PRE2, VIA5_1STACK_S_10_p_PRE3, >= 1 ); 
VIA5_1STACK_S_10_p_FINAL = interacting( VIA5_SAME_ARRAY_1STACK_S_10_p_PRE1, VIA5_1STACK_S_10_p_PRE4 ); 
VIA5_S_1_B5 = interacting( VIA5, VIA5_1STACK_S_10_p_FINAL ); 
VIA5_REG_4_S_1_B5 = external1( VIA5_S_1_B5, < VIA_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } );    /* VIA5s space smaller than 0.49 (inside small array)   */ 
VIA5_VIOLATE_S_1_B5 = interacting( VIA5_S_1_B5, VIA5_REG_4_S_1_B5 ); 

// Rule Check    
//**************************************
rVIA4_S_10_ARRAY4_M @= { @ "VIA4.S.10_Array4_M : Minimum space between two VIA4 region >= " + VIA_S_3 + " um if the single layer VIA arrays area >= " + VIA_A_1 + " um2 (except sealring region)"; 
    sLAYER_227 = interacting( VIA4_1STACK_S_10_p_FINAL, VIA4_VIOLATE_S_1_B4 ); 
    not_interacting( sLAYER_227, SEALRING_ALL ); 
} /* end of rule : VIA4.S.10_Array4_M */
rVIA5_S_10_ARRAY5_M @= { @ "VIA5.S.10_Array5_M : Minimum space between two VIA5 region >= " + VIA_S_3 + " um if the single layer VIA arrays area >= " + VIA_A_1 + " um2 (except sealring region)"; 
    sLAYER_228 = interacting( VIA5_1STACK_S_10_p_FINAL, VIA5_VIOLATE_S_1_B5 ); 
    not_interacting( sLAYER_228, SEALRING_ALL ); 
} /* end of rule : VIA5.S.10_Array5_M */
CB_CUP = interacting( CB, WBDMY ); 
NOTCH_CB = external1( CB, < 5, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
CB_SINGLE = CB or NOTCH_CB; 

// VIA5 checks
//=============
VIA5R = VIA5 not_inside CB_SINGLE; 
VIA5R_CORE = VIA5R not SR_VIA5; 
rVIA5_W_1 @= { @ "VIA5.W.1 : VIA5 must be " + VIAN_W_1 + " x " + VIAN_W_1; 
    A = not_rectangles( VIA5R_CORE, orientation = ORTHOGONAL, sides = { == VIAN_W_1, == VIAN_W_1 } ); 
    A outside RNGX;                       /* exclude from metal fuse protection ring area */ 
} /* end of rule : VIA5.W.1 */
rVIA5_S_1 @= { @ "VIA5.S.1 : Min. VIA5 spacing < " + VIAN_S_1; 
    external1( VIA5R, < VIAN_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : VIA5.S.1 */
rVIA5_E_1 @= { @ "VIA5.E.1 : Min. extension of a M5 region beyond a VIA5 region < 0.01";
    enclose( VIA5R, M5, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
    VIA5R not M5; 
} /* end of rule : VIA5.E.1 */
rVIA5_E_2 @= { @ "VIA5.E.2 : Min. extension of a M5 end-of-line region beyond VIA5 region < 0.06";
    X = enclose_edge( VIA5R, M5, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
    internal1_error( X, < 0.36, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
} /* end of rule : VIA5.E.2 */
#ifdef RECOMMEND 
   rVIA5_E_3 @= { @ "VIA5.E.3 : Min. extension of M5 beyond the overlap area that VIA5 and VIA4 are fully or partially touching < " + VIA5_E_3; 
       X = VIA5R and VIA4; 
       enclose( X, M5, < VIA5_E_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
   } /* end of rule : VIA5.E.3 */
#endif /* end of #ifdef RECOMMEND  */ 
#ifdef CHECK_ALRDL 
   #ifndef THICK_20K 
      #ifndef THICK_40K 
         
         // VIAD checks
         //=============
         VIADR = VIAD not_inside CB_SINGLE; 
         VIADR_CORE = VIADR not SR_VIAD; 
         rVIAD_W_1 @= { @ "VIAD.W.1 : VIAD must be " + VIAD_W_1 + " x " + VIAD_W_1; 
             A = not_rectangles( VIADR_CORE, orientation = ORTHOGONAL, sides = { == VIAD_W_1, == VIAD_W_1 } ); 
             A outside RNGX;              /* exclude from metal fuse protection ring area */ 
         } /* end of rule : VIAD.W.1 */
         rVIAD_S_1 @= { @ "VIAD.S.1 : Min. VIAD spacing < " + VIAD_S_1; 
             external1( VIADR, < VIAD_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : VIAD.S.1 */
         rVIAD_E_1 @= { @ "VIAD.E.1 : Min. extension of a M6 region beyond a VIAD region < 0.01";
             enclose( VIADR, M6, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             VIADR not M6; 
         } /* end of rule : VIAD.E.1 */
         rVIAD_E_2 @= { @ "VIAD.E.2 : Min. extension of a M6 end-of-line region beyond VIAD region < 0.06";
             X = enclose_edge( VIADR, M6, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
             internal1_error( X, < 0.36, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
         } /* end of rule : VIAD.E.2 */
         #ifdef RECOMMEND 
            rVIAD_E_3 @= { @ "VIAD.E.3 : Min. extension of M6 beyond the overlap area that VIAD and VIA5 are fully or partially touching < " + VIAD_E_3; 
                X = VIADR and VIA5R; 
                enclose( X, M6, < VIAD_E_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
            } /* end of rule : VIAD.E.3 */
         #endif /* end of #ifdef RECOMMEND  */ 
      #endif /* end of #ifndef THICK_40K  */ 
   #endif /* end of #ifndef THICK_20K  */ 
#endif /* end of #ifdef CHECK_ALRDL  */ 
#ifndef THICK_20K 
   #ifndef THICK_40K 
      
      // M6 checks
      //=============
      rM6_W_1 @= { @ "M6.W.1 : Min. M6 width < 0.44";
          internal1( M6, < 0.44, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : M6.W.1 */
      rM6_S_1 @= { @ "M6.S.1 : Min. M6 space < 0.46";
          external1( M6, < 0.46, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : M6.S.1 */
      rM6_S_2 @= { @ "M6.S.2 : Min. space to wide M6 (>10um) < 0.6";
          sLAYER_231 = shrink( M6, east = 5 ); 
          sLAYER_230 = shrink( sLAYER_231, west = 5 );
          sLAYER_229 = shrink( sLAYER_230, north = 5 );
          M6_S5 = shrink( sLAYER_229, south = 5 ); 
          sLAYER_234 = grow( M6_S5, east = 5 ); 
          sLAYER_233 = grow( sLAYER_234, west = 5 );
          sLAYER_232 = grow( sLAYER_233, north = 5 );
          M6_G5 = grow( sLAYER_232, south = 5 ); 
          M6_WIDE = M6_G5 and M6; 
          M6_EXP = size_inside_wrapper( M6_WIDE, M6, distance = 1, increment = 0.322 ); 
          M6_BRANCH = M6_EXP not M6_WIDE; 
          M6_BRANCH_EDGE = M6_BRANCH coincident_inside_edge M6; 
          sLAYER_235 = size( M6_EXP, clip_acute = NONE, distance = 0.6 ); 
          M6_CHECK = M6 and sLAYER_235; 
          sLAYER_236 = edge_size( M6_BRANCH_EDGE, corner_extension = INTERSECTION, outside = 0.6 ); 
          M6_BRANCH_CHECK = M6 and sLAYER_236; 
          M6_WIDEC = stamp( M6_WIDE, M6XD, CONNECT_DB, CONNECT_DB_M6_S_2, include_touch = NONE ); 
          M6_CHECKC = stamp( M6_CHECK, M6XD, CONNECT_DB_M6_S_2, CONNECT_DB_M6_S_2, include_touch = NONE ); 
          M6_BRANCHC = stamp( M6_BRANCH, M6XD, CONNECT_DB_M6_S_2, CONNECT_DB_M6_S_2, include_touch = NONE ); 
          M6_BRANCH_CHECKC = stamp( M6_BRANCH_CHECK, M6XD, CONNECT_DB_M6_S_2, CONNECT_DB_M6_S_2, include_touch = NONE ); 
          external2( M6_WIDEC, M6_CHECKC, < 0.6, connect_sequence = CONNECT_DB_M6_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
          external2( M6_BRANCHC, M6_BRANCH_CHECKC, < 0.6, connect_sequence = CONNECT_DB_M6_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
      } /* end of rule : M6.S.2 */
      rM6_S_2_1_A @= { @ "M6.S.2.1.a : Min. space betweem wide metal and small piece of metal with parallel run length >= " + M6_S_2_L + " and same connection >=" + M6_S_2_1 + " um"; 
          sLAYER_239 = shrink( M6, east = 5 ); 
          sLAYER_238 = shrink( sLAYER_239, west = 5 );
          sLAYER_237 = shrink( sLAYER_238, north = 5 );
          M6_S5 = shrink( sLAYER_237, south = 5 ); 
          sLAYER_242 = grow( M6_S5, east = 5 ); 
          sLAYER_241 = grow( sLAYER_242, west = 5 );
          sLAYER_240 = grow( sLAYER_241, north = 5 );
          M6_G5 = grow( sLAYER_240, south = 5 ); 
          M6_WIDE = M6_G5 and M6; 
          sM6_SMALL = M6 not M6_WIDE; 
          M6_WIDEC = stamp( M6_WIDE, M6XD, CONNECT_DB, CONNECT_DB_M6_S_2_1_A, include_touch = NONE ); 
          M6_SMALLC = stamp( sM6_SMALL, M6XD, CONNECT_DB_M6_S_2_1_A, CONNECT_DB_M6_S_2_1_A, include_touch = NONE ); 
          M6_S_REG = external2( M6_WIDEC, M6_SMALLC, < M6_S_2_1, connect_sequence = CONNECT_DB_M6_S_2_1_A, connectivity = SAME_NET, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          M6_S_REG_CHECK = contains( M6_S_REG, { GRID, M6_S_2_L }, FORTY_FIVE ); 
          WIDEEDGE1 = M6_S_REG_CHECK coincident_outside_edge M6_WIDE; 
          M6_SMALL_EDGE = sM6_SMALL coincident_inside_edge M6; 
          WIDEEDGE2 = M6_S_REG_CHECK coincident_outside_edge M6_SMALL_EDGE; 
          length_edge( WIDEEDGE1, >= M6_S_2_L, CONNECT ); 
          length_edge( WIDEEDGE2, >= M6_S_2_L, CONNECT ); 
      } /* end of rule : M6.S.2.1.a */
      rM6_S_2_1_B @= { @ "M6.S.2.1.b : Min. space between two wide metals with parallel run length >= " + M6_S_2_L + " and same connection >=" + M6_S_2_2 + " um"; 
          sLAYER_245 = shrink( M6, east = 5 ); 
          sLAYER_244 = shrink( sLAYER_245, west = 5 );
          sLAYER_243 = shrink( sLAYER_244, north = 5 );
          M6_S5 = shrink( sLAYER_243, south = 5 ); 
          sLAYER_248 = grow( M6_S5, east = 5 ); 
          sLAYER_247 = grow( sLAYER_248, west = 5 );
          sLAYER_246 = grow( sLAYER_247, north = 5 );
          M6_G5 = grow( sLAYER_246, south = 5 ); 
          M6_WIDE = M6_G5 and M6; 
          M6_WIDEC = stamp( M6_WIDE, M6XD, CONNECT_DB, CONNECT_DB_M6_S_2_1_B, include_touch = NONE ); 
          M6_S_REG = external1( M6_WIDEC, < M6_S_2_2, connect_sequence = CONNECT_DB_M6_S_2_1_B, connectivity = SAME_NET, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          M6_S_REG_CHECK = contains( M6_S_REG, { GRID, M6_S_2_L }, FORTY_FIVE ); 
          WIDEEDGE = M6_S_REG_CHECK coincident_outside_edge M6_WIDE; 
          length_edge( WIDEEDGE, >= M6_S_2_L, CONNECT ); 
      } /* end of rule : M6.S.2.1.b */
      rM6_E_1 @= { @ "M6.E.1 : Min. extension of a M6 region beyond a VIA5 region < 0.09";
          enclose_edge( VIA5, M6, < 0.09, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
          enclose_edge( VIA5, M6, < 0.09, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
          VIA5 not M6; 
      } /* end of rule : M6.E.1 */
      rM6_A_1 @= { @ "M6.A.1 : Min. M6 area region < 0.562";
          area( M6, < 0.562 ); 
      } /* end of rule : M6.A.1 */
      #ifdef CHECK_ALRDL 
         
         // MD checks
         //=============
         rMD_W_1 @= { @ "MD.W.1 : Min. MD width < 0.44";
             internal1( MD, < 0.44, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : MD.W.1 */
         rMD_S_1 @= { @ "MD.S.1 : Min. MD space < 0.46";
             external1( MD, < 0.46, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : MD.S.1 */
         rMD_S_2 @= { @ "MD.S.2 : Min. space to wide MD (>10um) < 0.6";
             sLAYER_251 = shrink( MD, east = 5 ); 
             sLAYER_250 = shrink( sLAYER_251, west = 5 );
             sLAYER_249 = shrink( sLAYER_250, north = 5 );
             MD_S5 = shrink( sLAYER_249, south = 5 ); 
             sLAYER_254 = grow( MD_S5, east = 5 ); 
             sLAYER_253 = grow( sLAYER_254, west = 5 );
             sLAYER_252 = grow( sLAYER_253, north = 5 );
             MD_G5 = grow( sLAYER_252, south = 5 ); 
             MD_WIDE = MD_G5 and MD; 
             MD_EXP = size_inside_wrapper( MD_WIDE, MD, distance = 1, increment = 0.322 ); 
             MD_BRANCH = MD_EXP not MD_WIDE; 
             MD_BRANCH_EDGE = MD_BRANCH coincident_inside_edge MD; 
             sLAYER_255 = size( MD_EXP, clip_acute = NONE, distance = 0.6 ); 
             MD_CHECK = MD and sLAYER_255; 
             sLAYER_256 = edge_size( MD_BRANCH_EDGE, corner_extension = INTERSECTION, outside = 0.6 ); 
             MD_BRANCH_CHECK = MD and sLAYER_256; 
             MD_WIDEC = stamp( MD_WIDE, MDXD, CONNECT_DB, CONNECT_DB_MD_S_2, include_touch = NONE ); 
             MD_CHECKC = stamp( MD_CHECK, MDXD, CONNECT_DB_MD_S_2, CONNECT_DB_MD_S_2, include_touch = NONE ); 
             MD_BRANCHC = stamp( MD_BRANCH, MDXD, CONNECT_DB_MD_S_2, CONNECT_DB_MD_S_2, include_touch = NONE ); 
             MD_BRANCH_CHECKC = stamp( MD_BRANCH_CHECK, MDXD, CONNECT_DB_MD_S_2, CONNECT_DB_MD_S_2, include_touch = NONE ); 
             external2( MD_WIDEC, MD_CHECKC, < 0.6, connect_sequence = CONNECT_DB_MD_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
             external2( MD_BRANCHC, MD_BRANCH_CHECKC, < 0.6, connect_sequence = CONNECT_DB_MD_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
         } /* end of rule : MD.S.2 */
         rMD_S_2_1_A @= { @ "MD.S.2.1.a : Min. space betweem wide metal and small piece of metal with parallel run length >= " + MD_S_2_L + " and same connection >=" + MD_S_2_1 + " um"; 
             sLAYER_259 = shrink( MD, east = 5 ); 
             sLAYER_258 = shrink( sLAYER_259, west = 5 );
             sLAYER_257 = shrink( sLAYER_258, north = 5 );
             MD_S5 = shrink( sLAYER_257, south = 5 ); 
             sLAYER_262 = grow( MD_S5, east = 5 ); 
             sLAYER_261 = grow( sLAYER_262, west = 5 );
             sLAYER_260 = grow( sLAYER_261, north = 5 );
             MD_G5 = grow( sLAYER_260, south = 5 ); 
             MD_WIDE = MD_G5 and MD; 
             MD_SMALL = MD not MD_WIDE; 
             MD_WIDEC = stamp( MD_WIDE, MDXD, CONNECT_DB, CONNECT_DB_MD_S_2_1_A, include_touch = NONE ); 
             MD_SMALLC = stamp( MD_SMALL, MDXD, CONNECT_DB_MD_S_2_1_A, CONNECT_DB_MD_S_2_1_A, include_touch = NONE ); 
             MD_S_REG = external2( MD_WIDEC, MD_SMALLC, < MD_S_2_1, connect_sequence = CONNECT_DB_MD_S_2_1_A, connectivity = SAME_NET, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             MD_S_REG_CHECK = contains( MD_S_REG, { GRID, MD_S_2_L }, FORTY_FIVE ); 
             WIDEEDGE1 = MD_S_REG_CHECK coincident_outside_edge MD_WIDE; 
             MD_SMALL_EDGE = MD_SMALL coincident_inside_edge MD; 
             WIDEEDGE2 = MD_S_REG_CHECK coincident_outside_edge MD_SMALL_EDGE; 
             length_edge( WIDEEDGE1, >= MD_S_2_L, CONNECT ); 
             length_edge( WIDEEDGE2, >= MD_S_2_L, CONNECT ); 
         } /* end of rule : MD.S.2.1.a */
         rMD_S_2_1_B @= { @ "MD.S.2.1.b : Min. space between two wide metals with parallel run length >= " + MD_S_2_L + " and same connection >=" + MD_S_2_2 + " um"; 
             sLAYER_265 = shrink( MD, east = 5 ); 
             sLAYER_264 = shrink( sLAYER_265, west = 5 );
             sLAYER_263 = shrink( sLAYER_264, north = 5 );
             MD_S5 = shrink( sLAYER_263, south = 5 ); 
             sLAYER_268 = grow( MD_S5, east = 5 ); 
             sLAYER_267 = grow( sLAYER_268, west = 5 );
             sLAYER_266 = grow( sLAYER_267, north = 5 );
             MD_G5 = grow( sLAYER_266, south = 5 ); 
             MD_WIDE = MD_G5 and MD; 
             MD_WIDEC = stamp( MD_WIDE, MDXD, CONNECT_DB, CONNECT_DB_MD_S_2_1_B, include_touch = NONE ); 
             MD_S_REG = external1( MD_WIDEC, < MD_S_2_2, connect_sequence = CONNECT_DB_MD_S_2_1_B, connectivity = SAME_NET, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             MD_S_REG_CHECK = contains( MD_S_REG, { GRID, MD_S_2_L }, FORTY_FIVE ); 
             WIDEEDGE = MD_S_REG_CHECK coincident_outside_edge MD_WIDE; 
             length_edge( WIDEEDGE, >= MD_S_2_L, CONNECT ); 
         } /* end of rule : MD.S.2.1.b */
         rMD_E_1 @= { @ "MD.E.1 : Min. extension of a MD region beyond a VIAD region < 0.09";
             enclose_edge( VIAD, MD, < 0.09, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             enclose_edge( VIAD, MD, < 0.09, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
             VIAD not MD; 
         } /* end of rule : MD.E.1 */
         rMD_A_1 @= { @ "MD.A.1 : Min. MD area region < 0.562";
             area( MD, < 0.562 ); 
         } /* end of rule : MD.A.1 */
      #endif /* end of #ifdef CHECK_ALRDL  */ 
   #endif /* end of #ifndef THICK_40K  */ 
#endif /* end of #ifndef THICK_20K  */ 

// METAL RATIO CHECKS
//======================
rPO_R_3 @= { @ "PO.R.3 : Min poly area coverage < 14%";
    ALL_POLY = POLYI or DPO; 
    sLAYER_460 = chip_extent();
    VAR_1 = density_statistics_file( file = "POLY_DENSITY.log" ); 
_den_con = < 0.14;
_den_polygon_area_clip = true;
_den_print = true;
_den_print_only = false;
    density( window_layer = sLAYER_460, layer_hash = { "layer1" => ALL_POLY }, statistics_files = { VAR_1 }, window_function = den_save_window_7 ); 
} /* end of rule : PO.R.3 */
rM1_R_1 @= { @ "M1.R.1 : Min M1 area coverage < 30%";
    sLAYER_461 = chip_extent();
    VAR_2 = density_statistics_file( file = "M1_DENSITY.log" ); 
_den_con = < 0.3;
_den_polygon_area_clip = true;
_den_print = true;
_den_print_only = false;
    density( window_layer = sLAYER_461, layer_hash = { "layer1" => M1XD }, statistics_files = { VAR_2 }, window_function = den_save_window_7 ); 
} /* end of rule : M1.R.1 */
rM2_R_1 @= { @ "M2.R.1 : Min M2 area coverage < 30%";
    sLAYER_462 = chip_extent();
    VAR_3 = density_statistics_file( file = "M2_DENSITY.log" ); 
_den_con = < 0.3;
_den_polygon_area_clip = true;
_den_print = true;
_den_print_only = false;
    density( window_layer = sLAYER_462, layer_hash = { "layer1" => M2XD }, statistics_files = { VAR_3 }, window_function = den_save_window_7 ); 
} /* end of rule : M2.R.1 */
rM3_R_1 @= { @ "M3.R.1 : Min M3 area coverage < 30%";
    sLAYER_463 = chip_extent();
    VAR_4 = density_statistics_file( file = "M3_DENSITY.log" ); 
_den_con = < 0.3;
_den_polygon_area_clip = true;
_den_print = true;
_den_print_only = false;
    density( window_layer = sLAYER_463, layer_hash = { "layer1" => M3XD }, statistics_files = { VAR_4 }, window_function = den_save_window_7 ); 
} /* end of rule : M3.R.1 */
rM4_R_1 @= { @ "M4.R.1 : Min M4 area coverage < 30%";
    sLAYER_464 = chip_extent();
    VAR_5 = density_statistics_file( file = "M4_DENSITY.log" ); 
_den_con = < 0.3;
_den_polygon_area_clip = true;
_den_print = true;
_den_print_only = false;
    density( window_layer = sLAYER_464, layer_hash = { "layer1" => M4XD }, statistics_files = { VAR_5 }, window_function = den_save_window_7 ); 
} /* end of rule : M4.R.1 */
rM5_R_1 @= { @ "M5.R.1 : Min M5 area coverage < 30%";
    sLAYER_465 = chip_extent();
    VAR_6 = density_statistics_file( file = "M5_DENSITY.log" ); 
_den_con = < 0.3;
_den_polygon_area_clip = true;
_den_print = true;
_den_print_only = false;
    density( window_layer = sLAYER_465, layer_hash = { "layer1" => M5XD }, statistics_files = { VAR_6 }, window_function = den_save_window_7 ); 
} /* end of rule : M5.R.1 */
#ifndef THICK_20K 
   #ifndef THICK_40K 
      rM6_R_1 @= { @ "M6.R.1 : Min M6 area coverage < 30%";
          sLAYER_466 = chip_extent();
          VAR_7 = density_statistics_file( file = "M6_DENSITY.log" ); 
      _den_con = < 0.3;
      _den_polygon_area_clip = true;
      _den_print = true;
      _den_print_only = false;
          density( window_layer = sLAYER_466, layer_hash = { "layer1" => M6XD }, statistics_files = { VAR_7 }, window_function = den_save_window_7 ); 
      } /* end of rule : M6.R.1 */
      rMD_R_1 @= { @ "MD.R.1 : Min MD area coverage < 30%";
          sLAYER_467 = chip_extent();
          VAR_8 = density_statistics_file( file = "MD_DENSITY.log" ); 
      _den_con = ( 0, 0.3 );
      _den_polygon_area_clip = true;
      _den_print = true;
      _den_print_only = false;
          density( window_layer = sLAYER_467, layer_hash = { "layer1" => MDXD }, statistics_files = { VAR_8 }, window_function = den_save_window_7 ); 
      } /* end of rule : MD.R.1 */
   #endif /* end of #ifndef THICK_40K  */ 
#endif /* end of #ifndef THICK_20K  */ 
DP_V1 = DPDMY and VIA1; 
DP_V2 = DPDMY and VIA2; 
DP_V3 = DPDMY and VIA3; 
DP_V4 = DPDMY and VIA4; 
DP_V5 = DPDMY and VIA5; 
DP_VD = DPDMY and VIAD; 
rADP_R_0A @= { @ "ADP.R.0A : chip corner dummy pad structure should be M1/M2.../M6";
    DPDMY not M1; 
    DPDMY not M2; 
    DPDMY not M3; 
    DPDMY not M4; 
    DPDMY not M5; 
    DPDMY not M6; 
} /* end of rule : ADP.R.0A */
rADP_R_0B @= { @ "ADP.R.0B : chip corner dummy pad structure should be VIA1/VIA2.../VIA6";
    not_enclosing( DPDMY, VIA1 ); 
    not_enclosing( DPDMY, VIA2 ); 
    not_enclosing( DPDMY, VIA3 ); 
    not_enclosing( DPDMY, VIA4 ); 
    not_enclosing( DPDMY, VIA5 ); 
} /* end of rule : ADP.R.0B */
rADP_R_0C @= { @ "ADP.R.0C : Via structure in Dummy Pad";
    sLAYER_269 = DP_V2 or DP_V4; 
    GRP1 = sLAYER_269 or DP_VD; 
    sLAYER_270 = DP_V1 or DP_V3; 
    GRP2 = sLAYER_270 or DP_V5; 
    GRP1 and GRP2; 
} /* end of rule : ADP.R.0C */
rADP_S_1_VIA1 @= { @ "ADP.S.1_VIA1 : Via1 spacing (the same level) < 0.58um.";
    external1( DP_V1, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_VIA1 */
rADP_S_1_VIA2 @= { @ "ADP.S.1_VIA2 : Via2 spacing (the same level) < 0.58um.";
    external1( DP_V2, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_VIA2 */
rADP_S_1_VIA3 @= { @ "ADP.S.1_VIA3 : Via3 spacing (the same level) < 0.58um.";
    external1( DP_V3, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_VIA3 */
rADP_S_1_VIA4 @= { @ "ADP.S.1_VIA4 : Via4 spacing (the same level) < 0.58um.";
    external1( DP_V4, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_VIA4 */
rADP_S_1_VIA5 @= { @ "ADP.S.1_VIA5 : Via5 spacing (the same level) < 0.58um.";
    external1( DP_V5, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_VIA5 */
rADP_S_1_VIAD @= { @ "ADP.S.1_VIAD : ViaD spacing (the same level) < 0.58um.";
    external1( DP_VD, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_VIAD */
rADP_C_1_V1_V2 @= { @ "ADP.C.1_V1_V2 : Vias spacing (different level) < 0.23um.";
    external2( DP_V1, DP_V2, < 0.23, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : ADP.C.1_V1_V2 */
rADP_C_1_V2_V3 @= { @ "ADP.C.1_V2_V3 : Vias spacing (different level) < 0.23um.";
    external2( DP_V2, DP_V3, < 0.23, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : ADP.C.1_V2_V3 */
rADP_C_1_V3_V4 @= { @ "ADP.C.1_V3_V4 : Vias spacing (different level) < 0.23um.";
    external2( DP_V3, DP_V4, < 0.23, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : ADP.C.1_V3_V4 */
rADP_C_2_V4_V5 @= { @ "ADP.C.2_V4_V5 : Via4 and Via5 spacing < 0.16um.";
    external2( DP_V4, DP_V5, < 0.16, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : ADP.C.2_V4_V5 */
rADP_C_2_V5_VD @= { @ "ADP.C.2_V5_VD : Via5 and ViaD spacing < 0.16um.";
    external2( DP_V5, DP_VD, < 0.16, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : ADP.C.2_V5_VD */
rADP_E_1_V1_M1 @= { @ "ADP.E.1_V1_M1 : Metal1 enclose Via1 in dummy pad < 3um.";
    enclose( DP_V1, M1, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_V1_M1 */
rADP_E_1_V1_M2 @= { @ "ADP.E.1_V1_M2 : Metal2 enclose Via1 in dummy pad < 3um.";
    enclose( DP_V1, M2, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_V1_M2 */
rADP_E_1_V2_M2 @= { @ "ADP.E.1_V2_M2 : Metal2 enclose Via2 in dummy pad < 3um.";
    enclose( DP_V2, M2, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_V2_M2 */
rADP_E_1_V2_M3 @= { @ "ADP.E.1_V2_M3 : Metal3 enclose Via2 in dummy pad < 3um.";
    enclose( DP_V2, M3, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_V2_M3 */
rADP_E_1_V3_M3 @= { @ "ADP.E.1_V3_M3 : Metal3 enclose Via3 in dummy pad < 3um.";
    enclose( DP_V3, M3, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_V3_M3 */
rADP_E_1_V3_M4 @= { @ "ADP.E.1_V3_M4 : Metal4 enclose Via3 in dummy pad < 3um.";
    enclose( DP_V3, M4, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_V3_M4 */
rADP_E_1_V4_M4 @= { @ "ADP.E.1_V4_M4 : Metal4 enclose Via4 in dummy pad < 3um.";
    enclose( DP_V4, M4, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_V4_M4 */
rADP_E_1_V4_M5 @= { @ "ADP.E.1_V4_M5 : Metal5 enclose Via4 in dummy pad < 3um.";
    enclose( DP_V4, M5, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_V4_M5 */
rADP_E_1_V5_M5 @= { @ "ADP.E.1_V5_M5 : Metal5 enclose Via5 in dummy pad < 3um.";
    enclose( DP_V5, M5, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_V5_M5 */
rADP_E_1_V5_M6 @= { @ "ADP.E.1_V5_M6 : Metal6 enclose Via5 in dummy pad < 3um.";
    enclose( DP_V5, M6, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_V5_M6 */
rADP_E_1_VD_M6 @= { @ "ADP.E.1_VD_M6 : Meta6l enclose ViaD in dummy pad < 3um.";
    enclose( DP_VD, M6, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_VD_M6 */
rADP_E_1_VD_MD @= { @ "ADP.E.1_VD_MD : MD enclose ViaD in dummy pad < 3um.";
    enclose( DP_VD, MD, < 3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.1_VD_MD */

// ADP.W.1 is checked by VIAx.W.1 ( x= 1..4)
// ADP.W.2 is checked by VIA5.W.1

// Guideline
rADP_S_2G @= { @ "ADP.S.2g : dummy pad spacing < 2um.";
    external1( DPDMY, < 2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.2g */
rADP_W_3G @= { @ "ADP.W.3g : dummy pad width > 80um";
    DPADG = internal1( DPDMY, <= 80, extension = NONE, intersecting = {  }, intersection_angle = ( 0, 90 ), projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
    DPDMY not DPADG; 
} /* end of rule : ADP.W.3g */
rADP_W_4G @= { @ "ADP.W.4g : dummy pad width < 40um";
    internal1( DPDMY, < 40, extension = RADIAL, intersecting = {  }, intersection_angle = ( 0, 90 ), relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.W.4g */

// Power Line
//===========
PL_V1 = PLDMY and VIA1; 
PL_V2 = PLDMY and VIA2; 
PL_V3 = PLDMY and VIA3; 
PL_V4 = PLDMY and VIA4; 
PL_V5 = PLDMY and VIA5; 
PL_VD = PLDMY and VIAD; 
rADP_R_0D @= { @ "ADP.R.0D : Via structure in Power Line";
    sLAYER_271 = PL_V2 or PL_V4; 
    GRP1 = sLAYER_271 or PL_VD; 
    sLAYER_272 = PL_V1 or PL_V3; 
    GRP2 = sLAYER_272 or PL_V5; 
    GRP1 and GRP2; 
} /* end of rule : ADP.R.0D */
rADP_S_1_PL_V1 @= { @ "ADP.S.1_PL_V1 : Via1 spacing (the same level) < 0.58um.";
    external1( PL_V1, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_PL_V1 */
rADP_S_1_PL_V2 @= { @ "ADP.S.1_PL_V2 : Via2 spacing (the same level) < 0.58um.";
    external1( PL_V2, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_PL_V2 */
rADP_S_1_PL_V3 @= { @ "ADP.S.1_PL_V3 : Via3 spacing (the same level) < 0.58um.";
    external1( PL_V3, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_PL_V3 */
rADP_S_1_PL_V4 @= { @ "ADP.S.1_PL_V4 : Via4 spacing (the same level) < 0.58um.";
    external1( PL_V4, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_PL_V4 */
rADP_S_1_PL_V5 @= { @ "ADP.S.1_PL_V5 : Via5 spacing (the same level) < 0.58um.";
    external1( PL_V5, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_PL_V5 */
rADP_S_1_PL_VD @= { @ "ADP.S.1_PL_VD : ViaD spacing (the same level) < 0.58um.";
    external1( PL_VD, < 0.58, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : ADP.S.1_PL_VD */
rADP_C_1_PL_V1_V2 @= { @ "ADP.C.1_PL_V1_V2 : Vias spacing (different level) < 0.23um.";
    external2( PL_V1, PL_V2, < 0.23, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : ADP.C.1_PL_V1_V2 */
rADP_C_1_PL_V2_V3 @= { @ "ADP.C.1_PL_V2_V3 : Vias spacing (different level) < 0.23um.";
    external2( PL_V2, PL_V3, < 0.23, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : ADP.C.1_PL_V2_V3 */
rADP_C_1_PL_V3_V4 @= { @ "ADP.C.1_PL_V3_V4 : Vias spacing (different level) < 0.23um.";
    external2( PL_V3, PL_V4, < 0.23, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : ADP.C.1_PL_V3_V4 */
rADP_C_2_PL_V4_V5 @= { @ "ADP.C.2_PL_V4_V5 : Via4 and Via5 spacing < 0.16um.";
    external2( PL_V4, PL_V5, < 0.16, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : ADP.C.2_PL_V4_V5 */
rADP_C_2_PL_V5_VD @= { @ "ADP.C.2_PL_V5_VD : Via5 and ViaD spacing < 0.16um.";
    external2( PL_V5, PL_VD, < 0.16, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
} /* end of rule : ADP.C.2_PL_V5_VD */
rADP_E_2_V1_M1 @= { @ "ADP.E.2_V1_M1 : Metal1 enclose Via1 in chip corner power line < 0.2um.";
    enclose( PL_V1, M1, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_V1_M1 */
rADP_E_2_V1_M2 @= { @ "ADP.E.2_V1_M2 : Metal2 enclose Via1 in chip corner power line < 0.2um.";
    enclose( PL_V1, M2, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_V1_M2 */
rADP_E_2_V2_M2 @= { @ "ADP.E.2_V2_M2 : Metal2 enclose Via2 in chip corner power line < 0.2um.";
    enclose( PL_V2, M2, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_V2_M2 */
rADP_E_2_V2_M3 @= { @ "ADP.E.2_V2_M3 : Metal3 enclose Via2 in chip corner power line < 0.2um.";
    enclose( PL_V2, M3, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_V2_M3 */
rADP_E_2_V3_M3 @= { @ "ADP.E.2_V3_M3 : Metal3 enclose Via3 in chip corner power line < 0.2um.";
    enclose( PL_V3, M3, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_V3_M3 */
rADP_E_2_V3_M4 @= { @ "ADP.E.2_V3_M4 : Metal4 enclose Via3 in chip corner power line < 0.2um.";
    enclose( PL_V3, M4, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_V3_M4 */
rADP_E_2_V4_M4 @= { @ "ADP.E.2_V4_M4 : Metal4 enclose Via4 in chip corner power line < 0.2um.";
    enclose( PL_V4, M4, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_V4_M4 */
rADP_E_2_V4_M5 @= { @ "ADP.E.2_V4_M5 : Metal5 enclose Via4 in chip corner power line < 0.2um.";
    enclose( PL_V4, M5, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_V4_M5 */
rADP_E_2_V5_M5 @= { @ "ADP.E.2_V5_M5 : Metal5 enclose Via5 in chip corner power line < 0.2um.";
    enclose( PL_V5, M5, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_V5_M5 */
rADP_E_2_V5_M6 @= { @ "ADP.E.2_V5_M6 : Metal6 enclose Via5 in chip corner power line < 0.2um.";
    enclose( PL_V5, M6, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_V5_M6 */
rADP_E_2_VD_M6 @= { @ "ADP.E.2_VD_M6 : Metal6 enclose ViaD in chip corner power line < 0.2um.";
    enclose( PL_VD, M6, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_VD_M6 */
rADP_E_2_VD_MD @= { @ "ADP.E.2_VD_MD : MD enclose ViaD in chip corner power line < 0.2um.";
    enclose( PL_VD, MD, < 0.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : ADP.E.2_VD_MD */
rAMS_1_M1 @= { @ "AMS.1.M1 : Wide Metal (>35um) must have slot.";
    sLAYER_274 = size( size( M1EXD, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
    sLAYER_273 = size( size( sLAYER_274, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
    A = sLAYER_273 and M1EXD; 
    contains( A, { 35.005, 35.005 }, FORTY_FIVE ); 
} /* end of rule : AMS.1.M1 */
rAMS_DN_M1 @= { @ "AMS.DN.M1 : Min. Hole density for metal lines that need to apply slot  1.5%";
    net_area_ratio( CONNECT_DB, < 0.015, { "layer1" => LM1X, "layer2" => M1HOLED }, 2, 2, {  }, NAR_SAVE_NET_8, false ); 
} /* end of rule : AMS.DN.M1 */
rAMS_1_M2 @= { @ "AMS.1.M2 : Wide Metal (>35um) must have slot.";
    sLAYER_276 = size( size( M2EXD, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
    sLAYER_275 = size( size( sLAYER_276, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
    A = sLAYER_275 and M2EXD; 
    contains( A, { 35.005, 35.005 }, FORTY_FIVE ); 
} /* end of rule : AMS.1.M2 */
rAMS_DN_M2 @= { @ "AMS.DN.M2 : Min. Hole density for metal lines that need to apply slot  1.5%";
    net_area_ratio( CONNECT_DB, < 0.015, { "layer1" => LM2X, "layer2" => M2HOLED }, 2, 2, {  }, NAR_SAVE_NET_8, false ); 
} /* end of rule : AMS.DN.M2 */
rAMS_1_M3 @= { @ "AMS.1.M3 : Wide Metal (>35um) must have slot.";
    sLAYER_278 = size( size( M3EXD, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
    sLAYER_277 = size( size( sLAYER_278, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
    A = sLAYER_277 and M3EXD; 
    contains( A, { 35.005, 35.005 }, FORTY_FIVE ); 
} /* end of rule : AMS.1.M3 */
rAMS_DN_M3 @= { @ "AMS.DN.M3 : Min. Hole density for metal lines that need to apply slot  1.5%";
    net_area_ratio( CONNECT_DB, < 0.015, { "layer1" => LM3X, "layer2" => M3HOLED }, 2, 2, {  }, NAR_SAVE_NET_8, false ); 
} /* end of rule : AMS.DN.M3 */
rAMS_1_M4 @= { @ "AMS.1.M4 : Wide Metal (>35um) must have slot.";
    sLAYER_280 = size( size( M4EXD, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
    sLAYER_279 = size( size( sLAYER_280, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
    A = sLAYER_279 and M4EXD; 
    contains( A, { 35.005, 35.005 }, FORTY_FIVE ); 
} /* end of rule : AMS.1.M4 */
rAMS_DN_M4 @= { @ "AMS.DN.M4 : Min. Hole density for metal lines that need to apply slot  1.5%";
    net_area_ratio( CONNECT_DB, < 0.015, { "layer1" => LM4X, "layer2" => M4HOLED }, 2, 2, {  }, NAR_SAVE_NET_8, false ); 
} /* end of rule : AMS.DN.M4 */
rAMS_1_M5 @= { @ "AMS.1.M5 : Wide Metal (>35um) must have slot.";
    sLAYER_282 = size( size( M5EXD, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
    sLAYER_281 = size( size( sLAYER_282, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
    A = sLAYER_281 and M5EXD; 
    contains( A, { 35.005, 35.005 }, FORTY_FIVE ); 
} /* end of rule : AMS.1.M5 */
rAMS_DN_M5 @= { @ "AMS.DN.M5 : Min. Hole density for metal lines that need to apply slot  1.5%";
    net_area_ratio( CONNECT_DB, < 0.015, { "layer1" => LM5X, "layer2" => M5HOLED }, 2, 2, {  }, NAR_SAVE_NET_8, false ); 
} /* end of rule : AMS.DN.M5 */
rAMS_1_M6 @= { @ "AMS.1.M6 : Wide Metal (>35um) must have slot.";
    sLAYER_284 = size( size( M6EXD, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
    sLAYER_283 = size( size( sLAYER_284, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
    A = sLAYER_283 and M6EXD; 
    contains( A, { 35.005, 35.005 }, FORTY_FIVE ); 
} /* end of rule : AMS.1.M6 */
rAMS_DN_M6 @= { @ "AMS.DN.M6 : Min. Hole density for metal lines that need to apply slot  1.5%";
    net_area_ratio( CONNECT_DB, < 0.015, { "layer1" => LM6X, "layer2" => M6HOLED }, 2, 2, {  }, NAR_SAVE_NET_8, false ); 
} /* end of rule : AMS.DN.M6 */
rAMS_1_MD @= { @ "AMS.1.MD : Wide Metal (>35um) must have slot";
    sLAYER_286 = size( size( MDEXD, - 1.0, clip_acute = NONE ), 1.0, clip_acute = NONE ); 
    sLAYER_285 = size( size( sLAYER_286, - 17.5, clip_acute = BISECTOR ), 17.5, clip_acute = BISECTOR );
    A = sLAYER_285 and MDEXD; 
    contains( A, { 35.005, 35.005 }, FORTY_FIVE ); 
} /* end of rule : AMS.1.MD */
rAMS_DN_MD @= { @ "AMS.DN.MD : Min. Hole density for metal lines that need to apply slot  1.5%";
    net_area_ratio( CONNECT_DB, < 0.015, { "layer1" => LMDX, "layer2" => MDHOLED }, 2, 2, {  }, NAR_SAVE_NET_8, false ); 
} /* end of rule : AMS.DN.MD */
gLAYER_374 = SDI and CO; 
gLAYER_373 = gLAYER_374 and OD; 
ECO = gLAYER_373 not DIODUMMY; 
EGTE_W = and_edge( EGTE, OD, false ); 
gLAYER_376 = not_interacting( ENSD, ECO ); 
ENSD_NCO = not_interacting( gLAYER_376, PTAP ); 
gLAYER_377 = not_interacting( EPSD, ECO ); 
EPSD_NCO = not_interacting( gLAYER_377, NTAP ); 
ENSD_WCO = ENSD not ENSD_NCO; 
EPSD_WCO = EPSD not EPSD_NCO; 
ENSD_SRC = ENSD_WCO outside RPO; 
PCL_ENMOS = not_interacting( ENMOS, RPO ); 
PTAP_REAL = PTAPI not DIODUMMY; 
NTAP_REAL = NTAPI not DIODUMMY; 
ENSD_PWELI = ENSD and PWELI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ ENSD_PWELI }, ENSD }} ); 
PTAP_REAL_PWELI = PTAP_REAL and PWELI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAP_REAL_PWELI }, PTAPI }} ); 
ENSD_SOURCE_PRE = net_area_ratio( CONNECT_DB, > 0, { "layer1" => ENSD_PWELI, "layer2" => PTAP_REAL_PWELI }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
EPSD_NWELI = EPSD and NWELI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ EPSD_NWELI }, EPSD }} ); 
NTAP_REAL_NWELI = NTAP_REAL and NWELI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAP_REAL_NWELI }, NTAPI }} ); 
EPSD_SOURCE_PRE = net_area_ratio( CONNECT_DB, > 0, { "layer1" => EPSD_NWELI, "layer2" => NTAP_REAL_NWELI }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
gLAYER_379 = ENSD not PCL_ENMOS; 
gLAYER_378 = gLAYER_379 outside RPO; 
ENSD_SOURCE = ENSD_SOURCE_PRE or gLAYER_378; 
gLAYER_380 = EPSD outside RPO; 
EPSD_SOURCE = EPSD_SOURCE_PRE or gLAYER_380; 
ENSD_DRAIN = ENSD not ENSD_SOURCE; 
EPSD_DRAIN = EPSD not EPSD_SOURCE; 
ENSD_DRAINC = interacting( ENSD_DRAIN, ECO ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ ENSD_DRAINC }, ENSD }} ); 
EPSD_DRAINC = interacting( EPSD_DRAIN, ECO ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ EPSD_DRAINC }, EPSD }} ); 
ENMOSC = stamp( ENMOS, ENSD_DRAINC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
EPMOSC = stamp( EPMOS, EPSD_DRAINC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
ESD_PMOS_GATE_W = and_edge( EGTE_W, PP, false ); 
gLAYER_382 = not_interacting( EGTE, PCL_ENMOS ); 
gLAYER_381 = and_edge( gLAYER_382, OD, false ); 
ESD_NMOS_GATE_W = and_edge( gLAYER_381, gNP, false ); 
gLAYER_385 = interacting( EGTE, PCL_ENMOS ); 
gLAYER_384 = and_edge( gLAYER_385, OD, false ); 
gLAYER_383 = or_edge( not_edge( gLAYER_384, OD2 ), coincident_inside_edge( gLAYER_384, OD2 ) ); 
ESD_PCL_GATE_W = and_edge( gLAYER_383, gNP, false ); 
gLAYER_388 = interacting( EGTE, PCL_ENMOS ); 
gLAYER_387 = and_edge( gLAYER_388, OD, false ); 
gLAYER_386 = and_edge( gLAYER_387, OD2, false ); 
ESD_PCL_HV_GATE_W = and_edge( gLAYER_386, gNP, false ); 
ESD_PMOS_GATE_W_EXP = edge_size( ESD_PMOS_GATE_W, outside = GRID ); 
ESD_NMOS_GATE_W_EXP = edge_size( ESD_NMOS_GATE_W, outside = GRID ); 
ESD_PCL_GATE_W_EXP = edge_size( ESD_PCL_GATE_W, outside = GRID ); 
ESD_PCL_HV_GATE_W_EXP = edge_size( ESD_PCL_HV_GATE_W, outside = GRID ); 
ESD_PMOS_GATE_W_EXPC = stamp( ESD_PMOS_GATE_W_EXP, EPSD_DRAINC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
ESD_NMOS_GATE_W_EXPC = stamp( ESD_NMOS_GATE_W_EXP, ENSD_DRAINC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
ESD_PCL_GATE_W_EXPC = stamp( ESD_PCL_GATE_W_EXP, ENSD_DRAINC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
ESD_PCL_HV_GATE_W_EXPC = stamp( ESD_PCL_HV_GATE_W_EXP, ENSD_DRAINC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
ESD1_GATE = EGTE and ESD1DMY; 
ESD1_NCS_GATE = not_interacting( ESD1_GATE, ENSD_NCO ); 
gLAYER_389 = ENMOS and ESD1DMY; 
ESD1_TOL = interacting( gLAYER_389, ENSD_NCO ); 
gLAYER_390 = ENMOS and ESD1DMY; 
ESD1_NCS = not_interacting( gLAYER_390, ENSD_NCO ); 
ENSD_NCO_ESD1DMY = interacting( ENSD_NCO, ESD1DMY ); 
ESD1_TOL_GATE = interacting( EGTE, ENSD_NCO_ESD1DMY ); 
ESD1_TOL_GATE1 = not_interacting( ESD1_TOL_GATE, ENSD_SRC ); 
ESD1_TOL_GATE2 = interacting( ESD1_TOL_GATE, ENSD_SRC ); 
ESD1_NCS_GATE_W = and_edge( ESD1_NCS_GATE, OD, false ); 
ESD1_TOL_GATE1_W = and_edge( ESD1_TOL_GATE1, OD, false ); 
ESD1_TOL_GATE2_W = and_edge( ESD1_TOL_GATE2, OD, false ); 
ESD2_GATE = EGTE and ESD2DMY; 
ESD2_REG_GATE = not_interacting( ESD2_GATE, ENSD_NCO ); 
ESD2_TOL_GATE = interacting( ESD2_GATE, ENSD_NCO ); 
ESD2_TOL_GATE1 = not_interacting( ESD2_TOL_GATE, ENSD_SRC ); 
ESD2_TOL_GATE2 = interacting( ESD2_TOL_GATE, ENSD_SRC ); 
gLAYER_391 = ENMOS and ESD2DMY; 
ESD2_TOL = interacting( gLAYER_391, ENSD_NCO ); 
gLAYER_392 = ENMOS and ESD2DMY; 
ESD2_REG = not_interacting( gLAYER_392, ENSD_NCO ); 
ESD2_REG_GATE_W = and_edge( ESD2_REG_GATE, OD, false ); 
ESD2_TOL_GATE1_W = and_edge( ESD2_TOL_GATE1, OD, false ); 
ESD2_TOL_GATE2_W = and_edge( ESD2_TOL_GATE2, OD, false ); 
gLAYER_394 = RPO and SDI; 
gLAYER_393 = gLAYER_394 outside ESD1DMY; 
RPO1 = gLAYER_393 outside ESD2DMY; 
gLAYER_396 = EGTE outside ESD1DMY; 
gLAYER_395 = gLAYER_396 outside ESD2DMY; 
EGTE1 = not_interacting( gLAYER_395, ENSD_NCO ); 
EGTE1_W = and_edge( EGTE1, OD, false ); 
ERPO = RPO and SDI; 
ERPOH = donut_holes( ERPO, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
ERPOA = ERPOH or ERPO; 
ECOS = ECO outside ERPOA; 
HEGT = EGTE and OD2; 
LEGT = EGTE not OD2; 
HEGN = HEGT and gNP; 
HEGP = HEGT and PP; 

// For LUP.1/LUP.2/LUP.4 - GuardRing
//====================================
NW_INSIDE_GUARD_RING_PRE1 = NWELI not NTAPI; 
NW_INSIDE_GUARD_RING_PRE2 = NW_INSIDE_GUARD_RING_PRE1 not_coincident_outside_edge NTAPI; 
NW_INSIDE_GUARD_RING = NW_INSIDE_GUARD_RING_PRE1 not_touching NW_INSIDE_GUARD_RING_PRE2; 
gLAYER_459 = donut_holes( NTAPI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
gLAYER_458 = gLAYER_459 inside NWELI; 
NTAP_GUARD_RING_HOLE = gLAYER_458 or NW_INSIDE_GUARD_RING; 
PW_INSIDE_GUARD_RING_PRE1 = PWELI not PTAPI; 
PW_INSIDE_GUARD_RING_PRE2 = PW_INSIDE_GUARD_RING_PRE1 not_coincident_outside_edge PTAPI; 
PW_INSIDE_GUARD_RING = PW_INSIDE_GUARD_RING_PRE1 not_touching PW_INSIDE_GUARD_RING_PRE2; 
gLAYER_461 = donut_holes( PTAPI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
gLAYER_460 = gLAYER_461 inside PWELI; 
PTAP_GUARD_RING_HOLE = gLAYER_460 or PW_INSIDE_GUARD_RING; 
#ifdef DISCONNECT_ALL_RESISTOR 
   CBIU = CBK not EMPTYI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBIU }, CBK }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      CBIU = CBU not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBIU }, CBU }} ); 
   #else
      CBIU = CBJ not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBIU }, CBJ }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   UBMNIU = UBMNK not EMPTYI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMNIU }, UBMNK }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      UBMNIU = UBMNU not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMNIU }, UBMNU }} ); 
   #else
      UBMNIU = UBMNJ not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMNIU }, UBMNJ }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   UBMDIU = UBMDK not EMPTYI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMDIU }, UBMDK }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      UBMDIU = UBMDU not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMDIU }, UBMDU }} ); 
   #else
      UBMDIU = UBMDJ not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMDIU }, UBMDJ }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_568 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
   PWR_M1IU_BY_TEXT = M1K interacting gLAYER_568; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M1IU_BY_TEXT }, M1K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_569 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M1IU_BY_TEXT = M1U interacting gLAYER_569; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M1IU_BY_TEXT }, M1U }} ); 
   #else
      gLAYER_570 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M1IU_BY_TEXT = M1J interacting gLAYER_570; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M1IU_BY_TEXT }, M1J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_571 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
   PWR_M2IU_BY_TEXT = M2K interacting gLAYER_571; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M2IU_BY_TEXT }, M2K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_572 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M2IU_BY_TEXT = M2U interacting gLAYER_572; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M2IU_BY_TEXT }, M2U }} ); 
   #else
      gLAYER_573 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M2IU_BY_TEXT = M2J interacting gLAYER_573; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M2IU_BY_TEXT }, M2J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_574 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
   PWR_M3IU_BY_TEXT = M3K interacting gLAYER_574; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M3IU_BY_TEXT }, M3K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_575 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M3IU_BY_TEXT = M3U interacting gLAYER_575; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M3IU_BY_TEXT }, M3U }} ); 
   #else
      gLAYER_576 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M3IU_BY_TEXT = M3J interacting gLAYER_576; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M3IU_BY_TEXT }, M3J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_577 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
   PWR_M4IU_BY_TEXT = M4K interacting gLAYER_577; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M4IU_BY_TEXT }, M4K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_578 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M4IU_BY_TEXT = M4U interacting gLAYER_578; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M4IU_BY_TEXT }, M4U }} ); 
   #else
      gLAYER_579 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M4IU_BY_TEXT = M4J interacting gLAYER_579; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M4IU_BY_TEXT }, M4J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_580 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
   PWR_M5IU_BY_TEXT = M5K interacting gLAYER_580; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M5IU_BY_TEXT }, M5K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_581 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M5IU_BY_TEXT = M5U interacting gLAYER_581; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M5IU_BY_TEXT }, M5U }} ); 
   #else
      gLAYER_582 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M5IU_BY_TEXT = M5J interacting gLAYER_582; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M5IU_BY_TEXT }, M5J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_583 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
   PWR_M6IU_BY_TEXT = M6K interacting gLAYER_583; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M6IU_BY_TEXT }, M6K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_584 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M6IU_BY_TEXT = M6U interacting gLAYER_584; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M6IU_BY_TEXT }, M6U }} ); 
   #else
      gLAYER_585 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_M6IU_BY_TEXT = M6J interacting gLAYER_585; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M6IU_BY_TEXT }, M6J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_586 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
   PWR_MDIU_BY_TEXT = MDK interacting gLAYER_586; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_MDIU_BY_TEXT }, MDK }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_587 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_MDIU_BY_TEXT = MDU interacting gLAYER_587; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_MDIU_BY_TEXT }, MDU }} ); 
   #else
      gLAYER_588 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VDD_TEXT );
      PWR_MDIU_BY_TEXT = MDJ interacting gLAYER_588; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_MDIU_BY_TEXT }, MDJ }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_589 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
   GND_M1IU_BY_TEXT = M1K interacting gLAYER_589; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M1IU_BY_TEXT }, M1K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_590 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M1IU_BY_TEXT = M1U interacting gLAYER_590; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M1IU_BY_TEXT }, M1U }} ); 
   #else
      gLAYER_591 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M1IU_BY_TEXT = M1J interacting gLAYER_591; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M1IU_BY_TEXT }, M1J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_592 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
   PAD_M1IU_BY_TEXT = M1K interacting gLAYER_592; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M1IU_BY_TEXT }, M1K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_593 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M1IU_BY_TEXT = M1U interacting gLAYER_593; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M1IU_BY_TEXT }, M1U }} ); 
   #else
      gLAYER_594 = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M1IU_BY_TEXT = M1J interacting gLAYER_594; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M1IU_BY_TEXT }, M1J }} ); 
   #endif
#endif
gLAYER_419 = PWR_M1IU_BY_TEXT or GND_M1IU_BY_TEXT; 
IO_M1IU_BY_TEXT = not_interacting( PAD_M1IU_BY_TEXT, gLAYER_419 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_M1IU_BY_TEXT }, PAD_M1IU_BY_TEXT }} ); 
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_595 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
   GND_M2IU_BY_TEXT = M2K interacting gLAYER_595; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M2IU_BY_TEXT }, M2K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_596 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M2IU_BY_TEXT = M2U interacting gLAYER_596; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M2IU_BY_TEXT }, M2U }} ); 
   #else
      gLAYER_597 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M2IU_BY_TEXT = M2J interacting gLAYER_597; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M2IU_BY_TEXT }, M2J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_598 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
   PAD_M2IU_BY_TEXT = M2K interacting gLAYER_598; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M2IU_BY_TEXT }, M2K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_599 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M2IU_BY_TEXT = M2U interacting gLAYER_599; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M2IU_BY_TEXT }, M2U }} ); 
   #else
      gLAYER_600 = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M2IU_BY_TEXT = M2J interacting gLAYER_600; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M2IU_BY_TEXT }, M2J }} ); 
   #endif
#endif
gLAYER_420 = PWR_M2IU_BY_TEXT or GND_M2IU_BY_TEXT; 
IO_M2IU_BY_TEXT = not_interacting( PAD_M2IU_BY_TEXT, gLAYER_420 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_M2IU_BY_TEXT }, PAD_M2IU_BY_TEXT }} ); 
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_601 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
   GND_M3IU_BY_TEXT = M3K interacting gLAYER_601; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M3IU_BY_TEXT }, M3K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_602 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M3IU_BY_TEXT = M3U interacting gLAYER_602; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M3IU_BY_TEXT }, M3U }} ); 
   #else
      gLAYER_603 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M3IU_BY_TEXT = M3J interacting gLAYER_603; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M3IU_BY_TEXT }, M3J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_604 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
   PAD_M3IU_BY_TEXT = M3K interacting gLAYER_604; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M3IU_BY_TEXT }, M3K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_605 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M3IU_BY_TEXT = M3U interacting gLAYER_605; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M3IU_BY_TEXT }, M3U }} ); 
   #else
      gLAYER_606 = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M3IU_BY_TEXT = M3J interacting gLAYER_606; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M3IU_BY_TEXT }, M3J }} ); 
   #endif
#endif
gLAYER_421 = PWR_M3IU_BY_TEXT or GND_M3IU_BY_TEXT; 
IO_M3IU_BY_TEXT = not_interacting( PAD_M3IU_BY_TEXT, gLAYER_421 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_M3IU_BY_TEXT }, PAD_M3IU_BY_TEXT }} ); 
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_607 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
   GND_M4IU_BY_TEXT = M4K interacting gLAYER_607; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M4IU_BY_TEXT }, M4K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_608 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M4IU_BY_TEXT = M4U interacting gLAYER_608; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M4IU_BY_TEXT }, M4U }} ); 
   #else
      gLAYER_609 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M4IU_BY_TEXT = M4J interacting gLAYER_609; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M4IU_BY_TEXT }, M4J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_610 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
   PAD_M4IU_BY_TEXT = M4K interacting gLAYER_610; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M4IU_BY_TEXT }, M4K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_611 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M4IU_BY_TEXT = M4U interacting gLAYER_611; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M4IU_BY_TEXT }, M4U }} ); 
   #else
      gLAYER_612 = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M4IU_BY_TEXT = M4J interacting gLAYER_612; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M4IU_BY_TEXT }, M4J }} ); 
   #endif
#endif
gLAYER_422 = PWR_M4IU_BY_TEXT or GND_M4IU_BY_TEXT; 
IO_M4IU_BY_TEXT = not_interacting( PAD_M4IU_BY_TEXT, gLAYER_422 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_M4IU_BY_TEXT }, PAD_M4IU_BY_TEXT }} ); 
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_613 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
   GND_M5IU_BY_TEXT = M5K interacting gLAYER_613; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M5IU_BY_TEXT }, M5K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_614 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M5IU_BY_TEXT = M5U interacting gLAYER_614; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M5IU_BY_TEXT }, M5U }} ); 
   #else
      gLAYER_615 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M5IU_BY_TEXT = M5J interacting gLAYER_615; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M5IU_BY_TEXT }, M5J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_616 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
   PAD_M5IU_BY_TEXT = M5K interacting gLAYER_616; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M5IU_BY_TEXT }, M5K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_617 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M5IU_BY_TEXT = M5U interacting gLAYER_617; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M5IU_BY_TEXT }, M5U }} ); 
   #else
      gLAYER_618 = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M5IU_BY_TEXT = M5J interacting gLAYER_618; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M5IU_BY_TEXT }, M5J }} ); 
   #endif
#endif
gLAYER_423 = PWR_M5IU_BY_TEXT or GND_M5IU_BY_TEXT; 
IO_M5IU_BY_TEXT = not_interacting( PAD_M5IU_BY_TEXT, gLAYER_423 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_M5IU_BY_TEXT }, PAD_M5IU_BY_TEXT }} ); 
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_619 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
   GND_M6IU_BY_TEXT = M6K interacting gLAYER_619; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M6IU_BY_TEXT }, M6K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_620 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M6IU_BY_TEXT = M6U interacting gLAYER_620; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M6IU_BY_TEXT }, M6U }} ); 
   #else
      gLAYER_621 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_M6IU_BY_TEXT = M6J interacting gLAYER_621; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M6IU_BY_TEXT }, M6J }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_622 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
   PAD_M6IU_BY_TEXT = M6K interacting gLAYER_622; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M6IU_BY_TEXT }, M6K }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_623 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M6IU_BY_TEXT = M6U interacting gLAYER_623; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M6IU_BY_TEXT }, M6U }} ); 
   #else
      gLAYER_624 = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_M6IU_BY_TEXT = M6J interacting gLAYER_624; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M6IU_BY_TEXT }, M6J }} ); 
   #endif
#endif
gLAYER_424 = PWR_M6IU_BY_TEXT or GND_M6IU_BY_TEXT; 
IO_M6IU_BY_TEXT = not_interacting( PAD_M6IU_BY_TEXT, gLAYER_424 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_M6IU_BY_TEXT }, PAD_M6IU_BY_TEXT }} ); 
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_625 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
   GND_MDIU_BY_TEXT = MDK interacting gLAYER_625; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_MDIU_BY_TEXT }, MDK }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_626 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_MDIU_BY_TEXT = MDU interacting gLAYER_626; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_MDIU_BY_TEXT }, MDU }} ); 
   #else
      gLAYER_627 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_VSS_TEXT );
      GND_MDIU_BY_TEXT = MDJ interacting gLAYER_627; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_MDIU_BY_TEXT }, MDJ }} ); 
   #endif
#endif
#ifdef DISCONNECT_ALL_RESISTOR 
   gLAYER_628 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
   PAD_MDIU_BY_TEXT = MDK interacting gLAYER_628; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_MDIU_BY_TEXT }, MDK }} ); 
#else
   #ifdef CONNECT_ALL_RESISTOR 
      gLAYER_629 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_MDIU_BY_TEXT = MDU interacting gLAYER_629; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_MDIU_BY_TEXT }, MDU }} ); 
   #else
      gLAYER_630 = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 0.001, text = v_ci_PAD_TEXT );
      PAD_MDIU_BY_TEXT = MDJ interacting gLAYER_630; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_MDIU_BY_TEXT }, MDJ }} ); 
   #endif
#endif
gLAYER_425 = PWR_MDIU_BY_TEXT or GND_MDIU_BY_TEXT; 
IO_MDIU_BY_TEXT = not_interacting( PAD_MDIU_BY_TEXT, gLAYER_425 ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_MDIU_BY_TEXT }, PAD_MDIU_BY_TEXT }} ); 
gLAYER_426 = not_interacting( NTAPIU, RNWEL ); 
NTAPUX = gLAYER_426 not VARDMY; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NTAPUX }, NTAPIU }} ); 

// Power PAD
VDD_CB = net_select( CONNECT_DB, connected_to_any = { NTAPUX }, output_from_layers = { CBIU } ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VDD_CB }, CBIU }} ); 
CB_VDD_DUMMY = interacting( CBIU, VDDDMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB_VDD_DUMMY }, CBIU }} ); 
VDD_UBMN = net_select( CONNECT_DB, connected_to_any = { NTAPUX }, output_from_layers = { UBMNIU } );    /* VDD_UMBn connect to N+ OD pickup */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VDD_UBMN }, UBMNIU }} ); 
UBMN_VDD_DUMMY = interacting( UBMNIU, VDDDMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMN_VDD_DUMMY }, UBMNIU }} ); 
VDD_UBMD = net_select( CONNECT_DB, connected_to_any = { NTAPUX }, output_from_layers = { UBMDIU } );    /* VDD_UMBd connect to N+ OD pickup */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VDD_UBMD }, UBMDIU }} ); 
UBMD_VDD_DUMMY = interacting( UBMDIU, VDDDMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMD_VDD_DUMMY }, UBMDIU }} ); 
#ifdef GUIDELINE_ESD 
   
   // For ESD.1g
   //=============
   gLAYER_397 = interacting( PACTI, POLYI ); 
   PMOSI = interacting( gLAYER_397, COI ); 
   gLAYER_398 = interacting( NACTI, POLYI ); 
   NMOSI = interacting( gLAYER_398, COI ); 
   gLAYER_399 = interacting( NSDK, NMOSI ); 
   NSDK_HVMOS = interacting( gLAYER_399, OD2 ); 
   gLAYER_400 = interacting( NSDK, NMOSI ); 
   NSDK_LVMOS = not_interacting( gLAYER_400, OD2 ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDK_LVMOS }, NSDK }} ); 
   gLAYER_401 = interacting( PSDK, PMOSI ); 
   PSDK_HVMOS = interacting( gLAYER_401, OD2 ); 
   gLAYER_402 = interacting( PSDK, PMOSI ); 
   PSDK_LVMOS = not_interacting( gLAYER_402, OD2 ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDK_LVMOS }, PSDK }} ); 
   NSDK_HVMOS_SDI = interacting( NSDK_HVMOS, SDI ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDK_HVMOS_SDI }, NSDK }} ); 
   NSDK_LVMOS_SDI = interacting( NSDK_LVMOS, SDI ); 
   PSDK_HVMOS_SDI = interacting( PSDK_HVMOS, SDI ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDK_HVMOS_SDI }, PSDK }} ); 
   PSDK_LVMOS_SDI = interacting( PSDK_LVMOS, SDI ); 
   HV_GATEK = stamp( HVGT, ILP1K, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
   LV_GATEK = stamp( LVGT, ILP1K, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
   rESD_1G @= { @ "ESD.1g : Use thin oxide transistor for thin oxide power clamp and thin oxide I/O buffers; "
                           "Use thick oxide transistor for the thick oxide Power Clamp and thick oxide I/O buffers. "
                           "DRC only flag ((MOS INTERACT OD2) INTERACT SDI) connected to (MOS NOT INTERACT OD2). "
                           "DRC will exclude D/S/G connected to PWSTRAP.";
       net_area_ratio( CONNECT_DB, > 0, { "layer1" => NSDK_HVMOS_SDI, "layer2" => NSDK_LVMOS, "layer3" => PSDK_LVMOS, "layer4" => LV_GATEK, "layer5" => PTAPK }, 5, 5, {  }, NAR_SAVE_NET_10, false ); 
       net_area_ratio( CONNECT_DB, > 0, { "layer1" => PSDK_HVMOS_SDI, "layer2" => NSDK_LVMOS, "layer3" => PSDK_LVMOS, "layer4" => LV_GATEK, "layer5" => PTAPK }, 5, 5, {  }, NAR_SAVE_NET_10, false ); 
   } /* end of rule : ESD.1g */
   rESD_7G @= { @ "ESD.7g : For same type OD of the I/O buffer and Power Clamp should be surrounded by a guard-ring. "
                           "All other type ODs should be placed outside this guard-ring.";
       EPMOS not_inside NTAP_GUARD_RING_HOLE; 
       ENMOS not_inside PTAP_GUARD_RING_HOLE; 
   } /* end of rule : ESD.7g */
   rESD_9G @= { @ "ESD.9g : The OD area of the edge side of I/O buffer and Power Clamp should be Source or Bulk rather than Drain "
                           "to avoid an unwanted parasitic bipolar effect or an abnormal discharge path in ESD zapping. "
                           "DRC only flag (((OD INTERACT SDI) NOT PO) INTERACT one Gate) does not connect to STRAP.";
       EDGE_NSD = interacting( NSDU, EGTE, == 1 ); 
       CONNECT_DB_ESD_9G = incremental_connect( CONNECT_DB, {{{ EDGE_NSD }, NSDU }} ); 
       net_area_ratio( CONNECT_DB_ESD_9G, > 0, { "layer1" => EDGE_NSD, "layer2" => PTAPU }, 2, 2, {  }, NAR_SAVE_NET_11, false ); 
       EDGE_PSD = interacting( PSDU, EGTE, == 1 ); 
       CONNECT_DB_ESD_9G = incremental_connect( CONNECT_DB_ESD_9G, {{{ EDGE_PSD }, PSDU }} ); 
       net_area_ratio( CONNECT_DB_ESD_9G, > 0, { "layer1" => EDGE_PSD, "layer2" => NTAPU }, 2, 2, {  }, NAR_SAVE_NET_11, false ); 
   } /* end of rule : ESD.9g */
   VDD_CBK = net_select( CONNECT_DB, connected_to_any = { NTAPK }, output_from_layers = { CBK } ); 
   VSS_CBK = net_select( CONNECT_DB, connected_to_any = { PTAPK }, output_from_layers = { CBK } ); 
   VDD_UBMNK = net_select( CONNECT_DB, connected_to_any = { NTAPK }, output_from_layers = { UBMNK } ); 
   VSS_UBMNK = net_select( CONNECT_DB, connected_to_any = { PTAPK }, output_from_layers = { UBMNK } ); 
   VDD_UBMDK = net_select( CONNECT_DB, connected_to_any = { NTAPK }, output_from_layers = { UBMDK } ); 
   VSS_UBMDK = net_select( CONNECT_DB, connected_to_any = { PTAPK }, output_from_layers = { UBMDK } ); 
   CBK_DUMMY = interacting( CBK, VDD_VSS_DUMMY ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBK_DUMMY }, CBK }} ); 
   UBMNK_DUMMY = interacting( UBMNK, VDD_VSS_DUMMY ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMNK_DUMMY }, UBMNK }} ); 
   UBMDK_DUMMY = interacting( UBMDK, VDD_VSS_DUMMY ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMDK_DUMMY }, UBMDK }} ); 
   gLAYER_404 = CBK not VDD_CBK; 
   gLAYER_403 = gLAYER_404 not VSS_CBK; 
   IO_CBK = gLAYER_403 not CBK_DUMMY; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_CBK }, CBK }} ); 
   gLAYER_406 = UBMNK not VDD_UBMNK; 
   gLAYER_405 = gLAYER_406 not VSS_UBMNK; 
   IO_UBMNK = gLAYER_405 not UBMNK_DUMMY; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_UBMNK }, UBMNK }} ); 
   gLAYER_408 = UBMDK not VDD_UBMDK; 
   gLAYER_407 = gLAYER_408 not VSS_UBMDK; 
   IO_UBMDK = gLAYER_407 not UBMDK_DUMMY; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_UBMDK }, UBMDK }} ); 
   PSDK_CB = net_area_ratio( CONNECT_DB, > 0, { "layer1" => PSDK, "layer2" => IO_CBK, "layer3" => IO_UBMNK, "layer4" => IO_UBMDK }, 4, 4, {  }, NAR_SAVE_NET_12, false ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDK_CB }, PSDK }} ); 
   NSDK_CB = net_area_ratio( CONNECT_DB, > 0, { "layer1" => NSDK, "layer2" => IO_CBK, "layer3" => IO_UBMNK, "layer4" => IO_UBMDK }, 4, 4, {  }, NAR_SAVE_NET_12, false ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDK_CB }, NSDK }} ); 
   rESD_10G @= { @ "ESD.10g : Except the ESD device, either of the following two condition must be followed. "
                             "1. The space of two same type ODs >= " + ESD_10G + " um. " 
                             "2. Two same type ODs should be separated by different type OD. "
                             "The same type ODs are N+OD and N+OD in the same PW, or P+OD and P+OD in the same NW, which connect to two different Pad.";
       sLAYER_287 = interacting( PACT, PSDK_CB ); 
       sPACT_CHECK = sLAYER_287 not EPMOS; 
       PACT_CHECK_CB1 = interacting( sPACT_CHECK, PSDK_CB, == 1, connect_sequence = CONNECT_DB, count_by = NET ); 
       PACT_CHECK_CB = stamp( PACT_CHECK_CB1, PSDK_CB, CONNECT_DB, CONNECT_DB_ESD_10G, include_touch = NONE ); 
       P1 = external1( PACT_CHECK_CB, < ESD_10G, connect_sequence = CONNECT_DB_ESD_10G, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
       sLAYER_288 = interacting( sPACT_CHECK, P1 ); 
       PACT_CHECK_NW = stamp( sLAYER_288, NWELC, CONNECT_DB_ESD_10G, CONNECT_DB_ESD_10G, include_touch = NONE ); 
       P2 = external1( PACT_CHECK_NW, < ESD_10G, connect_sequence = CONNECT_DB_ESD_10G, connectivity = SAME_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
       ESD_P3 = P1 and P2; 
       sLAYER_289 = ESD_P3 not NTAPI; 
       interacting( sLAYER_289, PACT_CHECK_CB, > 1, connect_sequence = CONNECT_DB_ESD_10G, count_by = NET ); 
       interacting( sPACT_CHECK, PSDK_CB, > 1, connect_sequence = CONNECT_DB_ESD_10G, count_by = NET ); 
       sLAYER_290 = interacting( NACT, NSDK_CB ); 
       sNACT_CHECK = sLAYER_290 not ENMOS; 
       sLAYER_291 = interacting( sNACT_CHECK, NSDK_CB, == 1, connect_sequence = CONNECT_DB_ESD_10G, count_by = NET ); 
       NACT_CHECK_CB = stamp( sLAYER_291, NSDK_CB, CONNECT_DB_ESD_10G, CONNECT_DB_ESD_10G, include_touch = NONE ); 
       N1 = external1( NACT_CHECK_CB, < ESD_10G, connect_sequence = CONNECT_DB_ESD_10G, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
       sLAYER_292 = interacting( sNACT_CHECK, N1 ); 
       NACT_CHECK_PW = stamp( sLAYER_292, PWELC, CONNECT_DB_ESD_10G, CONNECT_DB_ESD_10G, include_touch = NONE ); 
       N2 = external1( NACT_CHECK_PW, < ESD_10G, connect_sequence = CONNECT_DB_ESD_10G, connectivity = SAME_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
       ESD_N3 = N1 and N2; 
       sLAYER_293 = ESD_N3 not PTAPI; 
       interacting( sLAYER_293, NACT_CHECK_CB, > 1, connect_sequence = CONNECT_DB_ESD_10G, count_by = NET ); 
       interacting( sNACT_CHECK, NSDK_CB, > 1, connect_sequence = CONNECT_DB_ESD_10G, count_by = NET ); 
   } /* end of rule : ESD.10g */
   rESD_3G @= { @ "ESD.3g : Total finger width for 5.0V, 3.3V, 2.5V, 1.8V and 1.5V N/PMOS I/O buffer in same connection of drain >= " + ESD_3G; 
       A = net_area_ratio( CONNECT_DB, >= ESD_3G, { "layer1" => ESD_PMOS_GATE_W_EXPC }, 0, 0, {  }, NAR_SAVE_NET_13, false ); 
       not_interacting( EPMOS, A ); 
       B = net_area_ratio( CONNECT_DB, >= ESD_3G, { "layer1" => ESD_NMOS_GATE_W_EXPC }, 0, 0, {  }, NAR_SAVE_NET_13, false ); 
       sLAYER_294 = not_interacting( ENMOS, PCL_ENMOS ); 
       not_interacting( sLAYER_294, B ); 
   } /* end of rule : ESD.3g */
   
   //ESD.4g is checked by ESD.3g
   rESD_5G @= { @ "ESD.5g : Total finger width of 1.8V/1.5V NMOS based fully silicided type active Power Clamp in same connection "
                           "of drain. 1.8V/1.5V NMOS BigFET Lg only needs to follow process rules >= " + ESD_5G + "."; 
       net_area_ratio( CONNECT_DB, < ESD_5G, { "layer1" => ESD_PCL_GATE_W_EXPC }, 0, 0, {  }, NAR_SAVE_NET_13, false ); 
   } /* end of rule : ESD.5g */
   rESD_5_1G @= { @ "ESD.5.1g : Total finger width for 3.3V/2.5V NMOS based fully silicided active type Power Clamp in same connection of drain >= " + ESD_5_1G + " um " 
                               "3.3V/2.5V NMOS BigFET Lg only needs follow process rules.";
       net_area_ratio( CONNECT_DB, < ESD_5_1G, { "layer1" => ESD_PCL_HV_GATE_W_EXPC }, 0, 0, {  }, NAR_SAVE_NET_13, false ); 
   } /* end of rule : ESD.5.1g */
   rESD_6G @= { @ "ESD.6g : Unit finger width of NMOS and PMOS for I/O buffer and power clamp device 15um <= width <= 60um.";
       length_edge( EGTE_W, ( 0, 15 ), CONNECT ); 
       length_edge( EGTE_W, ( 60, 999 ), CONNECT ); 
   } /* end of rule : ESD.6g */
   
   // begin of ESD.8, butted or inserted pickup is not allowed
   rESD_8G @= { @ "ESD.8g : It is strictly prohitibied to butting or inserted substrat/well pickups for ESD N/PMOS.";
       EACT = EPACT or ENACT; 
       DTAP = NTAP or PTAP; 
       EACTUP3 = size_outside_wrapper( EACT, DTAP, distance = 3, increment = 0.22 * 0.7 ); 
       D1 = interacting( DTAP, EACTUP3 ); 
       D1R1 = shrink( D1, east = 0.001 ); 
       D1R2 = D1 not D1R1; 
       D1R3 = D1 coincident_edge D1R2; 
       D1R4 = length_edge( D1R3, > 0.001 ); 
       D1R5 = external2_edge( D1R4, EACT, < 3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
       D1L = D1 touching D1R5; 
       D1L1 = shrink( D1L, west = 0.001 ); 
       D1L2 = D1L not D1L1; 
       D1L3 = D1L coincident_edge D1L2; 
       D1L4 = length_edge( D1L3, > 0.001 ); 
       D1L5 = external2_edge( D1L4, EACT, < 3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
       D1X = D1L touching D1L5; 
       D1T1 = shrink( D1, north = 0.001 ); 
       D1T2 = D1 not D1T1; 
       D1T3 = D1 coincident_edge D1T2; 
       D1T4 = length_edge( D1T3, > 0.001 ); 
       D1T5 = external2_edge( D1T4, EACT, < 3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
       D1B = D1 touching D1T5; 
       D1B1 = shrink( D1B, south = 0.001 ); 
       D1B2 = D1B not D1B1; 
       D1B3 = D1B coincident_edge D1B2; 
       D1B4 = length_edge( D1B3, > 0.001 ); 
       D1B5 = external2_edge( D1B4, EACT, < 3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
       D1Y = D1B touching D1B5; 
       DTAP2CHECK = D1X or D1Y; 
       DTAPHOLE = donut_holes( DTAP2CHECK, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
       DTAPSUSPECT = not_outside_touching( DTAP2CHECK, DTAPHOLE ); 
       contains( DTAPSUSPECT, { 0.22, 20 }, FORTY_FIVE ); 
   } /* end of rule : ESD.8g */
   #ifdef _1_5V 
      rESD_18G_1_5V @= { @ "ESD.18g_1.5V : Minimum 1.5V IO ESD NMOS/PMOS gate length >=0.2um";
          internal1( LEGT, < 0.2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : ESD.18g_1.5V */
   #endif /* end of #ifdef _1_5V  */ 
   #ifdef _1_8V 
      rESD_18G_1_8V @= { @ "ESD.18g_1.8V : Minimum 1.8V IO ESD NMOS/PMOS gate length >=0.25um";
          internal1( LEGT, < 0.25, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : ESD.18g_1.8V */
   #endif /* end of #ifdef _1_8V  */ 
   #ifdef _2_5V 
      rESD_18G_2_5V_N @= { @ "ESD.18g_2.5V_N : Minimum 2.5V IO ESD NMOS gate length >= 0.3um";
          internal1( HEGN, < 0.3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : ESD.18g_2.5V_N */
      rESD_18G_2_5V_P @= { @ "ESD.18g_2.5V_P : Minimum 2.5V IO ESD PMOS gate length >= 0.26um";
          internal1( HEGP, < 0.26, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : ESD.18g_2.5V_P */
   #endif /* end of #ifdef _2_5V  */ 
   #ifdef _3_3V 
      rESD_18G_3_3V_N @= { @ "ESD.18g_3.3V_N : Minimum 3.3V IO ESD NMOS gate length >= 0.4um";
          internal1( HEGN, < 0.4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : ESD.18g_3.3V_N */
      rESD_18G_3_3V_P @= { @ "ESD.18g_3.3V_P : Minimum 3.3V IO ESD PMOS gate length >= 0.3um";
          internal1( HEGP, < 0.3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : ESD.18g_3.3V_P */
   #endif /* end of #ifdef _3_3V  */ 
   #ifdef _5V 
      HEGN1 = interacting( HEGN, ESD ); 
      HEGN2 = HEGN not HEGN1; 
      rESD_18G_5V_NESD @= { @ "ESD.18g_5V_NESD : Minimum 5.0V IO ESD NMOS(without ESD implant)/PMOS gate length >= 0.6um";
          internal1( HEGN2, < 0.6, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : ESD.18g_5V_NESD */
      rESD_18G_5V_P @= { @ "ESD.18g_5V_P : Minimum 5.0V IO ESD NMOS(without ESD implant)/PMOS gate length >= 0.6um";
          internal1( HEGP, < 0.6, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : ESD.18g_5V_P */
      rESD_18G_5V_WESD @= { @ "ESD.18g_5V_WESD : Minimum 5.0V IO ESD NMOS (with ESD implant) gate length >=0.9um";
          internal1( HEGN1, < 0.9, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : ESD.18g_5V_WESD */
   #endif /* end of #ifdef _5V  */ 
   rESD_19G @= { @ "ESD.19g : NMOS and PMOS of I/O buffer should have a nonsalicide area on drain side, that is, RPO mask should "
                             "block drain side of device (except contact region should keep silicided).";
       sLAYER_295 = EGTE inside EPMOS; 
       sLAYER_296 = interacting( EPSD, RPO ); 
       not_interacting( sLAYER_295, sLAYER_296 );
       sLAYER_298 = interacting( ENMOS, RPO ); 
       sLAYER_297 = EGTE inside sLAYER_298; 
       sLAYER_299 = interacting( ENSD, RPO ); 
       not_interacting( sLAYER_297, sLAYER_299 );
   } /* end of rule : ESD.19g */
   rESD_20G @= { @ "ESD.20g : For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b) "
                             "RPO should cover all inactive poly gates and extend to active region (Poly spacing==0.25um). "
                             "Minimum and maximum overlap from RPO to the active poly gate 0.05um or 0.06um";
       X = ESD2_TOL_GATE not RPO; 
       not_interacting( ESD2_TOL, X ); 
       ESD2_TOL_GATE2 outside RPO; 
       ESD2_TOL_GATE1 not RPO; 
       internal2( ESD2_TOL_GATE2, RPO, < 0.05, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
       ESD2_TOL_GATE_RPO = cutting( ESD2_TOL_GATE, RPO ); 
       ESD2_TOL_GATE_RPO_CH = ESD2_TOL_GATE_RPO and RPO; 
       A = size( size( ESD2_TOL_GATE_RPO_CH, - 0.025, clip_acute = NONE ), 0.025, clip_acute = NONE ); 
       internal1( A, < 0.06, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
       size( size( A, - 0.03, clip_acute = NONE ), 0.03, clip_acute = NONE ); 
   } /* end of rule : ESD.20g */
   rESD_20G_A @= { @ "ESD.20g_A : For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b) "
                                 "RPO should cover all inactive poly gates and extend to active region (Poly spacing==0.25um). "
                                 "Minimum and maximum overlap from RPO to the active poly gate by 0.05um";
       X = interacting( ENSD_NCO, ESD2DMY ); 
       internal1( X, < 0.25, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
       size( size( X, - ( 0.25 / 2 ), clip_acute = NONE ), 0.25 / 2, clip_acute = NONE ); 
   } /* end of rule : ESD.20g_A */
   rESD_21G @= { @ "ESD.21g : For regular I/O designed by 5V, 3.3V, 2.5V, 1.8V and 1.5V NMOS (see N3 in Fig.6a) "
                             "Minimum and maximum overlap from RPO on the drain side to the active poly gate 0.05um or 0.06um";
       X = ESD2_REG_GATE not RPO; 
       not_interacting( ESD2_REG, X ); 
       ESD2_REG_GATE outside RPO; 
       internal2( ESD2_REG_GATE, RPO, < 0.05, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
       ESD2_REG_GATE_RPO = cutting( ESD2_REG_GATE, RPO ); 
       ESD2_REG_GATE_RPO_CH = ESD2_REG_GATE_RPO and RPO; 
       A = size( size( ESD2_REG_GATE_RPO_CH, - 0.025, clip_acute = NONE ), 0.025, clip_acute = NONE ); 
       internal1( A, < 0.06, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
       size( size( A, - 0.03, clip_acute = NONE ), 0.03, clip_acute = NONE ); 
   } /* end of rule : ESD.21g */
   
   // ESD.22g is checked by ESD.21g
   // ESD.23g is checked by ESD.21g
   rESD_24G @= { @ "ESD.24g : The minimum width of RPO on drain side (X) for 5V,3.3V, 2.5V, 1.8V and 1.5V NMOS and PMOS. "
                             "exclude 1.8V and 1.5V NMOS when used as power clamp device>=1.95um";
       sLAYER_301 = ENSD_WCO or EPSD_WCO; 
       sLAYER_300 = sLAYER_301 and ESD2DMY; 
       X = sLAYER_300 and RPO; 
       Y = EGTE coincident_outside_edge X; 
       Z = RPO coincident_inside_edge X; 
       enclose( Y, Z, < 1.95, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
   } /* end of rule : ESD.24g */
   rESD_25G @= { @ "ESD.25g : The minimum clearance from poly edge to CO edge on source side for NMOS and PMOS (Except ESD.26g)>=0.5um";
       sLAYER_303 = ENMOS or EPMOS; 
       sLAYER_302 = interacting( sLAYER_303, RPO ); 
       X = ECOS and sLAYER_302; 
       external2( X, EGTE_W, < 0.5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
       Y = ECO and ESD1_NCS; 
       external2( Y, EGTE_W, < 0.5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
   } /* end of rule : ESD.25g */
   rESD_26G @= { @ "ESD.26g : The minimum clearance of poly edge to CO edge on D/S side for 3.3V/2.5V/1.8V and 1.5V power clamp device>=0.25um";
       sLAYER_304 = not_interacting( ENMOS, RPO ); 
       X = ECO and sLAYER_304; 
       external2( X, EGTE_W, < 0.25, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
   } /* end of rule : ESD.26g */
   rESD_27G @= { @ "ESD.27g : For RPO DRC purpose,we need a dummy layers in ESD protection device.layers should cover all ESD protection devices. "
                             "ESD2DMY is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b), regular IO designed by "
                             "5V/3.3V/2.5V/1.8V/1.5V NMOS and PMOS (see Fig.6b), power clmap designed by 5V/3.3V/2.5V NMOS.";
       X = cutting( EGTE, RPO ); 
       sLAYER_306 = enclosing( ENMOS, X ); 
       sLAYER_305 = EGTE inside sLAYER_306; 
       sLAYER_305 not ESD2DMY; 
       sLAYER_308 = enclosing( EPMOS, X ); 
       sLAYER_307 = EGTE inside sLAYER_308; 
       sLAYER_307 not ESD2DMY; 
   } /* end of rule : ESD.27g */
   #ifndef _5V 
      rESD_28G @= { @ "ESD.28g : ESD implant is required for High Voltage Tolerant I/O designed by 3.3V NMOS device for 5V signal "
                                "input or 2.5V NMOS device for 3.3V signal input at I/O pad. ESD mask (No. 111) can be generated by "
                                "logical operation. It is not allowed to use ESD mask (No. 111) for 5V NMOS device. "
                                "ESD3DMY or ESDIMP is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b).";
          sLAYER_310 = enclosing( ENMOS, LEGT ); 
          sLAYER_309 = interacting( sLAYER_310, ESD2DMY ); 
          sLAYER_311 = ESD3DMY or ESDIMP; 
          interacting( sLAYER_309, sLAYER_311 );
          sLAYER_314 = ESD2_TOL_GATE and OD2; 
          sLAYER_313 = enclosing( ENMOS, sLAYER_314 ); 
          sLAYER_312 = sLAYER_313 not ESD3DMY; 
          not_interacting( sLAYER_312, ESDIMP ); 
          ESD3DMY and GATE_PP; 
          interacting( ESDIMP, EPMOS ); 
      } /* end of rule : ESD.28g */
   #endif /* end of #ifndef _5V  */ 
   
   // ESD.29g is checked by ESD.19g
   rESD_30G @= { @ "ESD.30g : For regular 1.8V I/O in NMOS region : Minumum clearance from RPO to poly spacing >=0.45um.";
       external2( RPO1, EGTE1_W, < 0.45, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
       EGTE1 and RPO1; 
   } /* end of rule : ESD.30g */
   
   //ESD.31g is checked by ESD.30g
   rESD_32G @= { @ "ESD.32g : The minimum width of RPO on drain side (X) for 1.8V NMOS and 5V/3.3V/1.8V/1.5V PMOS.>=1.5um";
       Y = and_edge( RPO1, OD, false ); 
       internal1( Y, < 1.5, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
   } /* end of rule : ESD.32g */
   
   //ESD.33g is checked by ESD.25g
   rESD_34G @= { @ "ESD.34g : 5V, 3.3V and 2.5V NMOS devices when used as power clamp devices, the RPO can fully cover the "
                             "uncontacted poly gate, source/drain (except contact region should keep silicided).";
       sLAYER_315 = interacting( ENMOS, ESD1DMY ); 
       sLAYER_315 not ERPOA; 
   } /* end of rule : ESD.34g */
   gLAYER_410 = interacting( OD, EGTE ); 
   gLAYER_409 = gLAYER_410 not POLY; 
   NCS_SD_1 = gLAYER_409 and ESD1DMY; 
   NCS_SD = stamp( NCS_SD_1, NSDI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
   NCS_S = net_select( CONNECT_DB, connected_to_any = { PTAPI }, output_from_layers = { NCS_SD } ); 
   NCS_D = NCS_SD not NCS_S; 
   rESD_35G @= { @ "ESD.35g : Minimum width of RPO on drain side (X) for 5V, 3.3V and 2.5V NMOS devices when used as power clamp "
                             "devices. Ncs Drain is defined as (((OD INTERACT GATE) NOT PO) AND ESD1DMY) "
                             "which not connect to PW Pickup.>=1.95um";
       X = NCS_D and RPO; 
       Y = EGTE coincident_outside_edge NCS_D; 
       Z = RPO coincident_inside_edge X; 
       enclose( Y, Z, < 1.95, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
   } /* end of rule : ESD.35g */
   
   //ESD.36g is checked by ESD.25g
   rESD_37G @= { @ "ESD.37g : For RPO DRC purpose, we need a dummy layers for 5V, 3.3Vand 2.5V NMOS devices when used as power "
                             "clamp devices. The layers should cover all ESD protection devices.";
       X = EGTE not_inside RPO; 
       Y = not_enclosing( ENMOS, X ); 
       not_interacting( Y, ESD1DMY ); 
       ESD1DMY and GATE_PP; 
       sLAYER_317 = enclosing( ENMOS, ESD1_GATE ); 
       sLAYER_316 = EGTE inside sLAYER_317; 
       sLAYER_316 not ESD1DMY;             /* ESD1DMY should cover all EGTE in new design rule. */ 
   } /* end of rule : ESD.37g */
   
   //ESD.38g is checked by ESD.3g
   //ESD.39g IS checked by ESD.3g
   rESD_WARN_1 @= { @ "ESD.WARN.1 : CO can't inserted between gate and RPO for 1.8V NMOS and all PMOS I/O pattern.";
       sLAYER_318 = EPSD or ENSD; 
       RED = interacting( sLAYER_318, RPO1 ); 
       XRPO = RED not RPO1; 
       XRPG = outside_touching( XRPO, EGTE1 ); 
       interacting( XRPG, ECO ); 
   } /* end of rule : ESD.WARN.1 */
   #ifdef _5V 
      rESD_WARN_2 @= { @ "ESD.WARN.2 : ESD3DMY OR ESDIMP is not allowed in 5V process.";
          copy( ESD3DMY ); 
          copy( ESDIMP ); 
      } /* end of rule : ESD.WARN.2 */
   #endif /* end of #ifdef _5V  */ 
   #ifndef _5V 
      rESD_WARN_3 @= { @ "ESD.WARN.3 : ESD is not allowed in processes except 5V.";
          copy( ESD ); 
      } /* end of rule : ESD.WARN.3 */
   #endif /* end of #ifndef _5V  */ 
   #ifdef FULL_CHIP 
      rESD_WARN_4 @= { @ "ESD.WARN.4 : SDI (122;0) needs to be found in each of power, ground, or I/O pad of CB, CB2, and UBM. Exception: SEALRING_ALL";
          sLAYER_320 = SDI or HIADMY; 
          sLAYER_319 = sLAYER_320 or DIODUMMY; 
          ESD_NSDIU = NSDIU and sLAYER_319; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB, {{{ ESD_NSDIU }, NSDIU }} ); 
          sLAYER_322 = SDI or HIADMY; 
          sLAYER_321 = sLAYER_322 or DIODUMMY; 
          ESD_PSDIU = PSDIU and sLAYER_321; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ ESD_PSDIU }, PSDIU }} ); 
          sLAYER_324 = SDI or HIADMY; 
          sLAYER_323 = sLAYER_324 or DIODUMMY; 
          ESD_PTAPIU = PTAPIU and sLAYER_323; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ ESD_PTAPIU }, PTAPIU }} ); 
          sLAYER_326 = SDI or HIADMY; 
          sLAYER_325 = sLAYER_326 or DIODUMMY; 
          ESD_NTAPIU = NTAPIU and sLAYER_325; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ ESD_NTAPIU }, NTAPIU }} ); 
          VDD_NSDIU = NSDIU and SDI; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ VDD_NSDIU }, NSDIU }} ); 
          VDD_PSDIU = PSDIU and SDI; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ VDD_PSDIU }, PSDIU }} ); 
          VDD_PTAPIU = PTAPIU and SDI; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ VDD_PTAPIU }, PTAPIU }} ); 
          VDD_NTAPIU = NTAPIU and SDI; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ VDD_NTAPIU }, NTAPIU }} ); 
          sLAYER_327 = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { COIU }, output_from_layers = { CBIU } ); 
          CB_NOT_DUMMY = CBIU and sLAYER_327; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ CB_NOT_DUMMY }, CBIU }} ); 
          sLAYER_328 = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { COIU }, output_from_layers = { UBMNIU } ); 
          UBMN_NOT_DUMMY = UBMNIU and sLAYER_328; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ UBMN_NOT_DUMMY }, UBMNIU }} ); 
          sLAYER_329 = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { COIU }, output_from_layers = { UBMDIU } ); 
          UBMD_NOT_DUMMY = UBMDIU and sLAYER_329; 
          CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ UBMD_NOT_DUMMY }, UBMDIU }} ); 
      #ifdef CHECK_LATCHUP_BY_TEXT 
             PAD_VDD_CB = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { PWR_M1IU_BY_TEXT, PWR_M2IU_BY_TEXT, PWR_M3IU_BY_TEXT, PWR_M4IU_BY_TEXT, PWR_M5IU_BY_TEXT, PWR_M6IU_BY_TEXT, PWR_MDIU_BY_TEXT }, output_from_layers = { CB_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_VDD_CB }, CB_NOT_DUMMY }} ); 
             PAD_IOVSS_CB = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { IO_M1IU_BY_TEXT, IO_M2IU_BY_TEXT, IO_M3IU_BY_TEXT, IO_M4IU_BY_TEXT, IO_M5IU_BY_TEXT, IO_M6IU_BY_TEXT, GND_M1IU_BY_TEXT, GND_M2IU_BY_TEXT, GND_M3IU_BY_TEXT, GND_M4IU_BY_TEXT, GND_M5IU_BY_TEXT, GND_M6IU_BY_TEXT, IO_MDIU_BY_TEXT, GND_MDIU_BY_TEXT }, output_from_layers = { CB_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_IOVSS_CB }, CB_NOT_DUMMY }} ); 
      #else /* the reverse of #ifdef CHECK_LATCHUP_BY_TEXT  */ 
             PAD_VDD_CB = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { VDD_CB, CB_VDD_DUMMY }, output_from_layers = { CB_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_VDD_CB }, CB_NOT_DUMMY }} ); 
             PAD_IOVSS_CB = net_select( CONNECT_DB_ESD_WARN_4, not_connected_to_any = { VDD_CB, CB_VDD_DUMMY }, output_from_layers = { CB_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_IOVSS_CB }, CB_NOT_DUMMY }} ); 
      #endif /* end of #ifdef CHECK_LATCHUP_BY_TEXT  */    /* CHECK_LATCHUP_BY_TEXT */ 
          sLAYER_331 = net_select( CONNECT_DB_ESD_WARN_4, not_connected_to_any = { VDD_NSDIU, VDD_PSDIU, VDD_PTAPIU, VDD_NTAPIU }, output_from_layers = { PAD_VDD_CB } ); 
          sLAYER_330 = sLAYER_331 not SEALRING_ALL; 
          level( sLAYER_330 );
          sLAYER_333 = net_select( CONNECT_DB_ESD_WARN_4, not_connected_to_any = { ESD_NSDIU, ESD_PSDIU, ESD_PTAPIU, ESD_NTAPIU }, output_from_layers = { PAD_IOVSS_CB } ); 
          sLAYER_332 = sLAYER_333 not SEALRING_ALL; 
          level( sLAYER_332 );
      #ifdef CHECK_LATCHUP_BY_TEXT 
             PAD_VDD_UBMN = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { PWR_M1IU_BY_TEXT, PWR_M2IU_BY_TEXT, PWR_M3IU_BY_TEXT, PWR_M4IU_BY_TEXT, PWR_M5IU_BY_TEXT, PWR_M6IU_BY_TEXT, PWR_MDIU_BY_TEXT }, output_from_layers = { UBMN_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_VDD_UBMN }, UBMN_NOT_DUMMY }} ); 
             PAD_IOVSS_UBMN = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { IO_M1IU_BY_TEXT, IO_M2IU_BY_TEXT, IO_M3IU_BY_TEXT, IO_M4IU_BY_TEXT, IO_M5IU_BY_TEXT, IO_M6IU_BY_TEXT, GND_M1IU_BY_TEXT, GND_M2IU_BY_TEXT, GND_M3IU_BY_TEXT, GND_M4IU_BY_TEXT, GND_M5IU_BY_TEXT, GND_M6IU_BY_TEXT, IO_MDIU_BY_TEXT, GND_MDIU_BY_TEXT }, output_from_layers = { UBMN_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_IOVSS_UBMN }, UBMN_NOT_DUMMY }} ); 
      #else /* the reverse of #ifdef CHECK_LATCHUP_BY_TEXT  */ 
             PAD_VDD_UBMN = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { VDD_UBMN, UBMN_VDD_DUMMY }, output_from_layers = { UBMN_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_VDD_UBMN }, UBMN_NOT_DUMMY }} ); 
             PAD_IOVSS_UBMN = net_select( CONNECT_DB_ESD_WARN_4, not_connected_to_any = { VDD_UBMN, UBMN_VDD_DUMMY }, output_from_layers = { UBMN_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_IOVSS_UBMN }, UBMN_NOT_DUMMY }} ); 
      #endif /* end of #ifdef CHECK_LATCHUP_BY_TEXT  */    /* CHECK_LATCHUP_BY_TEXT */ 
          sLAYER_335 = net_select( CONNECT_DB_ESD_WARN_4, not_connected_to_any = { VDD_NSDIU, VDD_PSDIU, VDD_PTAPIU, VDD_NTAPIU }, output_from_layers = { PAD_VDD_UBMN } ); 
          sLAYER_334 = sLAYER_335 not SEALRING_ALL; 
          level( sLAYER_334 );
          sLAYER_337 = net_select( CONNECT_DB_ESD_WARN_4, not_connected_to_any = { ESD_NSDIU, ESD_PSDIU, ESD_PTAPIU, ESD_NTAPIU }, output_from_layers = { PAD_IOVSS_UBMN } ); 
          sLAYER_336 = sLAYER_337 not SEALRING_ALL; 
          level( sLAYER_336 );
      #ifdef CHECK_LATCHUP_BY_TEXT 
             PAD_VDD_UBMD = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { PWR_M1IU_BY_TEXT, PWR_M2IU_BY_TEXT, PWR_M3IU_BY_TEXT, PWR_M4IU_BY_TEXT, PWR_M5IU_BY_TEXT, PWR_M6IU_BY_TEXT, PWR_MDIU_BY_TEXT }, output_from_layers = { UBMD_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_VDD_UBMD }, UBMD_NOT_DUMMY }} ); 
             PAD_IOVSS_UBMD = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { IO_M1IU_BY_TEXT, IO_M2IU_BY_TEXT, IO_M3IU_BY_TEXT, IO_M4IU_BY_TEXT, IO_M5IU_BY_TEXT, IO_M6IU_BY_TEXT, GND_M1IU_BY_TEXT, GND_M2IU_BY_TEXT, GND_M3IU_BY_TEXT, GND_M4IU_BY_TEXT, GND_M5IU_BY_TEXT, GND_M6IU_BY_TEXT, IO_MDIU_BY_TEXT, GND_MDIU_BY_TEXT }, output_from_layers = { UBMD_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_IOVSS_UBMD }, UBMD_NOT_DUMMY }} ); 
      #else /* the reverse of #ifdef CHECK_LATCHUP_BY_TEXT  */ 
             PAD_VDD_UBMD = net_select( CONNECT_DB_ESD_WARN_4, connected_to_any = { VDD_UBMD, UBMD_VDD_DUMMY }, output_from_layers = { UBMD_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_VDD_UBMD }, UBMD_NOT_DUMMY }} ); 
             PAD_IOVSS_UBMD = net_select( CONNECT_DB_ESD_WARN_4, not_connected_to_any = { VDD_UBMD, UBMD_VDD_DUMMY }, output_from_layers = { UBMD_NOT_DUMMY } ); 
             CONNECT_DB_ESD_WARN_4 = incremental_connect( CONNECT_DB_ESD_WARN_4, {{{ PAD_IOVSS_UBMD }, UBMD_NOT_DUMMY }} ); 
      #endif /* end of #ifdef CHECK_LATCHUP_BY_TEXT  */    /* CHECK_LATCHUP_BY_TEXT */ 
          sLAYER_339 = net_select( CONNECT_DB_ESD_WARN_4, not_connected_to_any = { VDD_NSDIU, VDD_PSDIU, VDD_PTAPIU, VDD_NTAPIU }, output_from_layers = { PAD_VDD_UBMD } ); 
          sLAYER_338 = sLAYER_339 not SEALRING_ALL; 
          level( sLAYER_338 );
          sLAYER_341 = net_select( CONNECT_DB_ESD_WARN_4, not_connected_to_any = { ESD_NSDIU, ESD_PSDIU, ESD_PTAPIU, ESD_NTAPIU }, output_from_layers = { PAD_IOVSS_UBMD } ); 
          sLAYER_340 = sLAYER_341 not SEALRING_ALL; 
          level( sLAYER_340 );
      } /* end of rule : ESD.WARN.4 */
   #endif /* end of #ifdef FULL_CHIP  */ 
   rESD_WARN_5 @= { @ "ESD.WARN.5 : SDI encloure of ACTIVE >= 0";
       sLAYER_342 = interacting( DACT, SDI ); 
       sLAYER_342 not SDI; 
   } /* end of rule : ESD.WARN.5 */
   rESD_40G @= { @ "ESD.40g : It is not allowed to use OD resistors or NW resistors connected to IO PAD";
       sLAYER_343 = interacting( NWELI, RWDMY ); 
       NWR_T = sLAYER_343 not RWDMY; 
       sNWRKT = stamp( NWR_T, COK, CONNECT_DB, CONNECT_DB_ESD_40G, include_touch = NONE ); 
       ODRES_A = ODRES_ALL and RPDUMMY; 
       sLAYER_345 = OD not POLY; 
       sLAYER_344 = interacting( sLAYER_345, ODRES_A ); 
       ODR_T = sLAYER_344 not ODRES_A; 
       ODRKT = stamp( ODR_T, COK, CONNECT_DB_ESD_40G, CONNECT_DB_ESD_40G, include_touch = NONE ); 
   #ifndef CHECK_LATCHUP_BY_TEXT 
          net_area_ratio( CONNECT_DB_ESD_40G, > 0, { "layer1" => ODRKT, "layer2" => IO_CBK, "layer3" => IO_UBMNK, "layer4" => IO_UBMDK }, 4, 4, {  }, NAR_SAVE_NET_14, false ); 
          net_area_ratio( CONNECT_DB_ESD_40G, > 0, { "layer1" => sNWRKT, "layer2" => IO_CBK, "layer3" => IO_UBMNK, "layer4" => IO_UBMDK }, 4, 4, {  }, NAR_SAVE_NET_14, false ); 
   #endif /* end of #ifndef CHECK_LATCHUP_BY_TEXT  */ 
   #ifdef CHECK_LATCHUP_BY_TEXT 
          ODRKT_IOPAD = net_area_ratio( CONNECT_DB_ESD_40G, > 0, { "layer1" => ODRKT, "layer2" => IO_CBK, "layer3" => IO_UBMNK, "layer4" => IO_UBMDK }, 4, 4, {  }, NAR_SAVE_NET_14, false ); 
          NWRKT_IOPAD = net_area_ratio( CONNECT_DB_ESD_40G, > 0, { "layer1" => sNWRKT, "layer2" => IO_CBK, "layer3" => IO_UBMNK, "layer4" => IO_UBMDK }, 4, 4, {  }, NAR_SAVE_NET_14, false ); 
          ODRKT_PAD_TEXT = net_select( CONNECT_DB_ESD_40G, connected_to_any = { PAD_M1K_BY_TEXT, PAD_M2K_BY_TEXT, PAD_M3K_BY_TEXT, PAD_M4K_BY_TEXT, PAD_M5K_BY_TEXT, PAD_M6K_BY_TEXT, PAD_MDK_BY_TEXT }, output_from_layers = { ODRKT } ); 
          ODRKT_VDD_VSS_PAD_TEXT = net_select( CONNECT_DB_ESD_40G, connected_to_any = { PWR_M1K_BY_TEXT, PWR_M2K_BY_TEXT, PWR_M3K_BY_TEXT, PWR_M4K_BY_TEXT, PWR_M5K_BY_TEXT, PWR_M6K_BY_TEXT, GND_M1K_BY_TEXT, GND_M2K_BY_TEXT, GND_M3K_BY_TEXT, GND_M4K_BY_TEXT, GND_M5K_BY_TEXT, GND_M6K_BY_TEXT, PWR_MDK_BY_TEXT, GND_MDK_BY_TEXT }, output_from_layers = { ODRKT } ); 
          ODRKT_VDD_VSS_PAD_DUMMY = net_select( CONNECT_DB_ESD_40G, connected_to_any = { CBK_DUMMY, UBMNK_DUMMY, UBMDK_DUMMY }, output_from_layers = { ODRKT } ); 
          NWRKT_PAD_TEXT = net_select( CONNECT_DB_ESD_40G, connected_to_any = { PAD_M1K_BY_TEXT, PAD_M2K_BY_TEXT, PAD_M3K_BY_TEXT, PAD_M4K_BY_TEXT, PAD_M5K_BY_TEXT, PAD_M6K_BY_TEXT, PAD_MDK_BY_TEXT }, output_from_layers = { sNWRKT } ); 
          NWRKT_VDD_VSS_PAD_TEXT = net_select( CONNECT_DB_ESD_40G, connected_to_any = { PWR_M1K_BY_TEXT, PWR_M2K_BY_TEXT, PWR_M3K_BY_TEXT, PWR_M4K_BY_TEXT, PWR_M5K_BY_TEXT, PWR_M6K_BY_TEXT, GND_M1K_BY_TEXT, GND_M2K_BY_TEXT, GND_M3K_BY_TEXT, GND_M4K_BY_TEXT, GND_M5K_BY_TEXT, GND_M6K_BY_TEXT, PWR_MDK_BY_TEXT, GND_MDK_BY_TEXT }, output_from_layers = { sNWRKT } ); 
          NWRKT_VDD_VSS_PAD_DUMMY = net_select( CONNECT_DB_ESD_40G, connected_to_any = { CBK_DUMMY, UBMNK_DUMMY, UBMDK_DUMMY }, output_from_layers = { sNWRKT } ); 
          sLAYER_346 = ODRKT_IOPAD or ODRKT_PAD_TEXT; 
          sLAYER_347 = ODRKT_VDD_VSS_PAD_TEXT or ODRKT_VDD_VSS_PAD_DUMMY; 
          sLAYER_346 not sLAYER_347;
          sLAYER_348 = NWRKT_IOPAD or NWRKT_PAD_TEXT; 
          sLAYER_349 = NWRKT_VDD_VSS_PAD_TEXT or NWRKT_VDD_VSS_PAD_DUMMY; 
          sLAYER_348 not sLAYER_349;
   #endif /* end of #ifdef CHECK_LATCHUP_BY_TEXT  */ 
   } /* end of rule : ESD.40g */
#endif /* end of #ifdef GUIDELINE_ESD  */ 
PTAPUX = PTAPIU not VARDMY; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PTAPUX }, PTAPIU }} ); 
VSS_CB = net_select( CONNECT_DB, connected_to_any = { PTAPUX }, output_from_layers = { CBIU } ); 

// Signal PAD
gLAYER_427 = CBIU not VDD_CB; 
IO_CB = gLAYER_427 not VSS_CB; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_CB }, CBIU }} ); 
VSS_UBMN = net_select( CONNECT_DB, connected_to_any = { PTAPUX }, output_from_layers = { UBMNIU } );    /* VSS_UMBn connect to P+ OD pickup */ 
gLAYER_428 = UBMNIU not VDD_UBMN; 
IO_UBMN = gLAYER_428 not VSS_UBMN; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_UBMN }, UBMNIU }} ); 
VSS_UBMD = net_select( CONNECT_DB, connected_to_any = { PTAPUX }, output_from_layers = { UBMDIU } );    /* VSS_UMBd connect to P+ OD pickup */ 
gLAYER_429 = UBMDIU not VDD_UBMD; 
IO_UBMD = gLAYER_429 not VSS_UBMD; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_UBMD }, UBMDIU }} ); 
PSD_IOPAD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => PSDIU, "layer2" => IO_CB, "layer3" => IO_UBMN, "layer4" => IO_UBMD }, 4, 4, {  }, NAR_SAVE_NET_1, false );    /* P+ S/D, and connect to I/O pad only */ 
PSD_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PAD_M1IU_BY_TEXT, PAD_M2IU_BY_TEXT, PAD_M3IU_BY_TEXT, PAD_M4IU_BY_TEXT, PAD_M5IU_BY_TEXT, PAD_M6IU_BY_TEXT, PAD_MDIU_BY_TEXT }, output_from_layers = { PSDIU } ); 
PSD_VDD_VSS_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PWR_M1IU_BY_TEXT, PWR_M2IU_BY_TEXT, PWR_M3IU_BY_TEXT, PWR_M4IU_BY_TEXT, PWR_M5IU_BY_TEXT, PWR_M6IU_BY_TEXT, GND_M1IU_BY_TEXT, GND_M2IU_BY_TEXT, GND_M3IU_BY_TEXT, GND_M4IU_BY_TEXT, GND_M5IU_BY_TEXT, GND_M6IU_BY_TEXT, PWR_MDIU_BY_TEXT, GND_MDIU_BY_TEXT }, output_from_layers = { PSDIU } ); 
CB_DUMMY = interacting( CBIU, VDD_VSS_DUMMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB_DUMMY }, CBIU }} ); 
UBMN_DUMMY = interacting( UBMNIU, VDD_VSS_DUMMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMN_DUMMY }, UBMNIU }} ); 
UBMD_DUMMY = interacting( UBMDIU, VDD_VSS_DUMMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMD_DUMMY }, UBMDIU }} ); 
PSD_VDD_VSS_PAD_DUMMY = net_select( CONNECT_DB, connected_to_any = { CB_DUMMY, UBMN_DUMMY, UBMD_DUMMY }, output_from_layers = { PSDIU } ); 
NSD_IOPAD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => NSDIU, "layer2" => IO_CB, "layer3" => IO_UBMN, "layer4" => IO_UBMD }, 4, 4, {  }, NAR_SAVE_NET_1, false ); 
NSD_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PAD_M1IU_BY_TEXT, PAD_M2IU_BY_TEXT, PAD_M3IU_BY_TEXT, PAD_M4IU_BY_TEXT, PAD_M5IU_BY_TEXT, PAD_M6IU_BY_TEXT, PAD_MDIU_BY_TEXT }, output_from_layers = { NSDIU } ); 
NSD_VDD_VSS_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PWR_M1IU_BY_TEXT, PWR_M2IU_BY_TEXT, PWR_M3IU_BY_TEXT, PWR_M4IU_BY_TEXT, PWR_M5IU_BY_TEXT, PWR_M6IU_BY_TEXT, GND_M1IU_BY_TEXT, GND_M2IU_BY_TEXT, GND_M3IU_BY_TEXT, GND_M4IU_BY_TEXT, GND_M5IU_BY_TEXT, GND_M6IU_BY_TEXT, PWR_MDIU_BY_TEXT, GND_MDIU_BY_TEXT }, output_from_layers = { NSDIU } ); 
NSD_VDD_VSS_PAD_DUMMY = net_select( CONNECT_DB, connected_to_any = { CB_DUMMY, UBMN_DUMMY, UBMD_DUMMY }, output_from_layers = { NSDIU } ); 
#ifdef CHECK_LATCHUP_BY_TEXT 
   gLAYER_440 = PSD_IOPAD or PSD_PAD_TEXT; 
   gLAYER_441 = PSD_VDD_VSS_PAD_TEXT or PSD_VDD_VSS_PAD_DUMMY; 
   PSD_IOPAD_ALL = gLAYER_440 not gLAYER_441; 
   gLAYER_442 = NSD_IOPAD or NSD_PAD_TEXT; 
   gLAYER_443 = NSD_VDD_VSS_PAD_TEXT or NSD_VDD_VSS_PAD_DUMMY; 
   NSD_IOPAD_ALL = gLAYER_442 not gLAYER_443; 
   SD_IOPAD = PSD_IOPAD_ALL or NSD_IOPAD_ALL; 
#else
   PSD_IOPAD_ALL = PSD_IOPAD not PSD_VDD_VSS_PAD_DUMMY; 
   NSD_IOPAD_ALL = NSD_IOPAD not NSD_VDD_VSS_PAD_DUMMY; 
   SD_IOPAD = PSD_IOPAD_ALL or NSD_IOPAD_ALL; 
#endif
#ifdef GUIDELINE_ESD 
   
   // HIA_DIO LAYOUT GUIDELINES
   //==========================
   HIA_NANODE = PTAP not_outside HIADMY; 
   HIA_PANODE = PACT inside HIADMY; 
   HIA_NCATHODE = NACT inside HIADMY; 
   HIA_PCATHODE = NTAP not_outside HIADMY; 
   HIA_ANODE = HIA_NANODE or HIA_PANODE; 
   HIA_CATHODE = HIA_NCATHODE or HIA_PCATHODE; 
   rHIA_1G @= { @ "HIA.1g : Width of N+ Active (N-HIA diode's cathode) and P+ Active (P-HIA diode's anode) inside HIA_DUMMY. (Figure XXX and Figure XXX) <= " + HIA_1G; 
       wide( HIA_NCATHODE, > HIA_1G ); 
       wide( HIA_PANODE, > HIA_1G ); 
   } /* end of rule : HIA.1g */
   rHIA_2G @= { @ "HIA.2g : Length of N+ Active (N-HIA diode's cathode) and P+ Active (P-HIA diode's anode) inside HIA_DUMMY. (Figure XXX and Figure XXX) <= " + HIA_2G; 
       contains( HIA_NCATHODE, { 0.1, HIA_2G + GRID } ); 
       contains( HIA_PANODE, { 0.1, HIA_2G + GRID } ); 
   } /* end of rule : HIA.2g */
   HIA_NCATHODE_IO_PAD = interacting( HIA_NCATHODE, SD_IOPAD ); 
   HIA_PANODE_IO_PAD = interacting( HIA_PANODE, SD_IOPAD ); 
   NHIA_ESD_IO_PAD = stamp( HIA_NCATHODE_IO_PAD, NSDI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
   PHIA_ESD_IO_PAD = stamp( HIA_PANODE_IO_PAD, PSDI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
   rHIA_3G @= { @ "HIA.3g : Total perimeter of each N+ or P+ ACTIVE inside HIA_dummy in same connection of I/O PAD. (Figure XXX and Figure XXX). The perimeter counts the drawn anode junction parameter region ex. The drawing OD perimeter dimension of active inside HIA_DUMMY= (A+B)*2*N >= 300";
       net_area_ratio( CONNECT_DB, < HIA_3G, { "layer1" => NHIA_ESD_IO_PAD }, 0, 0, {  }, NAR_SAVE_NET_15, false ); 
       net_area_ratio( CONNECT_DB, < HIA_3G, { "layer1" => PHIA_ESD_IO_PAD }, 0, 0, {  }, NAR_SAVE_NET_15, false ); 
   } /* end of rule : HIA.3g */
   rHIA_4G @= { @ "HIA.4g : The OD spacing of longer side of anode (P-diode) between anode and cathode, and vice versa for (N-diode). >= " + HIA_4G; 
       external2( HIA_NCATHODE, HIA_NANODE, < HIA_4G, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       external2( HIA_PCATHODE, HIA_PANODE, < HIA_4G, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : HIA.4g */
   
   //HIA.5g is checked by HIA.4g
   
   //HIA.6g is un-checkable 
   rHIA_9G @= { @ "HIA.9g : HIA_DUMMY enclosure of OD >= 0";
       and_edge( HIADMY, OD, false ); 
   } /* end of rule : HIA.9g */
   rHIA_17G @= { @ "HIA.17g : ALL ACTIVE OD inside same HIA_DUMMY should be in the same net";
       interacting( HIADMY, NSDI, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
       interacting( HIADMY, PSDI, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
   } /* end of rule : HIA.17g */
   rHIA_18G @= { @ "HIA.18g : HIA Dummy must be covered by DIODMY";
       HIADMY not DIODUMMY; 
   } /* end of rule : HIA.18g */
#endif /* end of #ifdef GUIDELINE_ESD  */    /* GUIDELINE_ESD */ 
#ifdef _5V 
   
   // ESD checks
   //===========
   rESD_W_1 @= { @ "ESD.W.1 : Minimum esd width < 0.6";
       internal1( ESD, < 0.6, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
   } /* end of rule : ESD.W.1 */
   rESD_S_1 @= { @ "ESD.S.1 : Minimum esd space < 0.6";
       external1( ESD, < 0.6, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
   } /* end of rule : ESD.S.1 */
   rESD_S_2 @= { @ "ESD.S.2 : Minimum space between ESD and NP or PP < 0.3";
       external2( ESD, PP, < 0.3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
       external2( ESD, gNP, < 0.3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       X = external2_edge( ESD, PP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = COINCIDENT, output_layer = LAYER2 ); 
       Y = edge_size( X, outside = 0.001 ); 
       not_interacting( Y, NPOD ); 
   } /* end of rule : ESD.S.2 */
   rESD_C_1 @= { @ "ESD.C.1 : Minimum clearance from an ESD to an NP OD < 0.6";
       external2( ESD, NPOD, < 0.6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : ESD.C.1 */
   rESD_C_2 @= { @ "ESD.C.2 : Minimum clearance from an ESD to a N-ch PO gate < 0.45";
       enclose( GATE_W, ESD, < 0.45, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 180, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
       cutting( ALL_GATE, ESD ); 
   } /* end of rule : ESD.C.2 */
   rESD_O_1 @= { @ "ESD.O.1 : Minimum overlap from an ESD edge to an OD region < 0.45";
       internal2( ESD, OD, < 0.45, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = RELATED_COINCIDENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : ESD.O.1 */
   rESD_C_4 @= { @ "ESD.C.4 : Min. space from ESD to ESD OD < 0.6";
       X = interacting( NPOD, ESD ); 
       external2( ESD, X, < 0.6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : ESD.C.4 */
   rESD_E_1 @= { @ "ESD.E.1 : Minimum extension of an ESD region beyond an ESD OD < 0.25";
       enclose( OD, ESD, < 0.25, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       ESD inside OD; 
   } /* end of rule : ESD.E.1 */
   
   // ESD.C.5 is not necessary to check
   rESD_R_1 @= { @ "ESD.R.1 : ESD and PP not allowed on same POLY region";
       A = ESD and POLY; 
       A and PP; 
   } /* end of rule : ESD.R.1 */
   rESD_R_2 @= { @ "ESD.R.2 : ESD is for 5.0V NMOS only";
       sLAYER_350 = ALL_GATE and PP; 
       ESD and sLAYER_350; 
       sLAYER_352 = ALL_GATE and gNP; 
       sLAYER_351 = sLAYER_352 not OD2; 
       ESD and sLAYER_351; 
   } /* end of rule : ESD.R.2 */
#endif /* end of #ifdef _5V  */ 
#ifdef _3_3V 
   
   // ESDIMP checks
   //================
   rESDIMP_W_1 @= { @ "ESDIMP.W.1 : Minimum esdimp width >= " + ESDIMP_W_1; 
       internal1( ESDIMP, < ESDIMP_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
   } /* end of rule : ESDIMP.W.1 */
   rESDIMP_S_1 @= { @ "ESDIMP.S.1 : Minimum esdimp space >= " + ESDIMP_S_1; 
       external1( ESDIMP, < ESDIMP_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : ESDIMP.S.1 */
   rESDIMP_S_2 @= { @ "ESDIMP.S.2 : Minimum space to esd3dmy (Overlap is prohibited) >= " + ESDIMP_S_2; 
       external2( ESDIMP, ESD3DMY, < ESDIMP_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       ESDIMP and ESD3DMY; 
   } /* end of rule : ESDIMP.S.2 */
   rESDIMP_EN_1 @= { @ "ESDIMP.EN.1 : (OD not POLY) enclosure of esdimp (esdimp must be fully inside (OD not POLY)) >= " + ESDIMP_EN_1; 
       A = OD not POLY; 
       enclose( ESDIMP, A, < ESDIMP_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       ESDIMP not A; 
   } /* end of rule : ESDIMP.EN.1 */
   #ifdef RECOMMEND 
      rESDIMP_EN_1_R @= { @ "ESDIMP.EN.1_R : (OD not POLY) enclosure of esdimp (esdimp must be fully inside (OD not POLY)) = " + ESDIMP_EN_1; 
          A = OD not POLY; 
          enclose( ESDIMP, A, < ESDIMP_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_353 = donut_holes( ESDIMP, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = sLAYER_353 or ESDIMP; 
          C = size( B, clip_acute = NONE, distance = ESDIMP_EN_1 ); 
          C not_touching_edge A; 
      } /* end of rule : ESDIMP.EN.1_R */
   #endif /* end of #ifdef RECOMMEND  */ 
   rESDIMP_A_1 @= { @ "ESDIMP.A.1 : Minimum esdimp area >= " + ESDIMP_A_1; 
       area( ESDIMP, < ESDIMP_A_1 ); 
   } /* end of rule : ESDIMP.A.1 */
   rESDIMP_A_2 @= { @ "ESDIMP.A.2 : Minimum esdimp enclosed area >= " + ESDIMP_A_2; 
       sLAYER_354 = donut_holes( ESDIMP, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
       A = sLAYER_354 not ESDIMP; 
       area( A, < ESDIMP_A_2 ); 
   } /* end of rule : ESDIMP.A.2 */
   rESDIMP_R_1 @= { @ "ESDIMP.R.1 : esdimp must be fully inside N+ active";
       ESDIMP not NACT; 
   } /* end of rule : ESDIMP.R.1 */
#endif /* end of #ifdef _3_3V  */ 
SRM = copy( EXCL ); 
#ifdef DISCONNECT_ALL_RESISTOR 
   NWRIU = NWRKT not EMPTYI; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWRIU }, NWRKT }} ); 
   ILP1IU = ILP1K not EMPTYI; 
   GND_M1IU_TEXT = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
   PWR_M1IU_TEXT = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
   GND_M2IU_TEXT = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
   PWR_M2IU_TEXT = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
   GND_M3IU_TEXT = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
   PWR_M3IU_TEXT = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
   GND_M4IU_TEXT = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
   PWR_M4IU_TEXT = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
   GND_M5IU_TEXT = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
   PWR_M5IU_TEXT = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
   GND_M6IU_TEXT = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
   PWR_M6IU_TEXT = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
   GND_MDIU_TEXT = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
   PWR_MDIU_TEXT = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
#else /* the reverse of #ifdef DISCONNECT_ALL_RESISTOR  */ 
   #ifdef CONNECT_ALL_RESISTOR 
      NWRIU = NWRUT not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWRIU }, NWRUT }} ); 
      ILP1IU = ILP1U not EMPTYI; 
      GND_M1IU_TEXT = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M1IU_TEXT = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_M2IU_TEXT = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M2IU_TEXT = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_M3IU_TEXT = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M3IU_TEXT = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_M4IU_TEXT = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M4IU_TEXT = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_M5IU_TEXT = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M5IU_TEXT = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_M6IU_TEXT = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M6IU_TEXT = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_MDIU_TEXT = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_MDIU_TEXT = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
   #else /* the reverse of #ifdef CONNECT_ALL_RESISTOR  */ 
      NWRIU = NWRJT not EMPTYI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWRIU }, NWRJT }} ); 
      ILP1IU = ILP1J not EMPTYI; 
      GND_M1IU_TEXT = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M1IU_TEXT = text_origin( tM1_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_M2IU_TEXT = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M2IU_TEXT = text_origin( tM2_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_M3IU_TEXT = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M3IU_TEXT = text_origin( tM3_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_M4IU_TEXT = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M4IU_TEXT = text_origin( tM4_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_M5IU_TEXT = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M5IU_TEXT = text_origin( tM5_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_M6IU_TEXT = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_M6IU_TEXT = text_origin( tM6_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
      GND_MDIU_TEXT = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VSS_TEXT ); 
      PWR_MDIU_TEXT = text_origin( tMD_PIN_TEXT, cells = { get_top_cell() }, shape_size = 1, text = v_ci_VDD_TEXT ); 
   #endif /* end of #ifdef CONNECT_ALL_RESISTOR  */ 
#endif /* end of #ifdef DISCONNECT_ALL_RESISTOR  */ 
PSD_PAD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => PSDIU, "layer2" => CBIU, "layer3" => UBMNIU, "layer4" => UBMDIU }, 4, 4, {  }, NAR_SAVE_NET_1, false );    /* P+ S/D, and connect to all CB/UBM pad */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSD_PAD }, PSDIU }} ); 
NSD_PAD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => NSDIU, "layer2" => CBIU, "layer3" => UBMNIU, "layer4" => UBMDIU }, 4, 4, {  }, NAR_SAVE_NET_1, false ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSD_PAD }, NSDIU }} ); 
NWR_IOPAD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => NWRIU, "layer2" => IO_CB, "layer3" => IO_UBMN, "layer4" => IO_UBMD }, 4, 4, {  }, NAR_SAVE_NET_1, false ); 
CB_VSS_DUMMY = interacting( CBIU, VSSDMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB_VSS_DUMMY }, CBIU }} ); 
UBMN_VSS_DUMMY = interacting( UBMNIU, VSSDMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMN_VSS_DUMMY }, UBMNIU }} ); 
UBMD_VSS_DUMMY = interacting( UBMDIU, VSSDMY ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMD_VSS_DUMMY }, UBMDIU }} ); 
PSD_VDD_PAD_DUMMY = net_select( CONNECT_DB, connected_to_any = { CB_VDD_DUMMY, UBMN_VDD_DUMMY, UBMD_VDD_DUMMY }, output_from_layers = { PSDIU } ); 
PSD_VSS_PAD_DUMMY = net_select( CONNECT_DB, connected_to_any = { CB_VSS_DUMMY, UBMN_VSS_DUMMY, UBMD_VSS_DUMMY }, output_from_layers = { PSDIU } ); 
NWR_VDD_VSS_PAD_DUMMY = net_select( CONNECT_DB, connected_to_any = { CB_DUMMY, UBMN_DUMMY, UBMD_DUMMY }, output_from_layers = { NWRIU } ); 
NSD_VDD_PAD_DUMMY = net_select( CONNECT_DB, connected_to_any = { CB_VDD_DUMMY, UBMN_VDD_DUMMY, UBMD_VDD_DUMMY }, output_from_layers = { NSDIU } ); 
NSD_VSS_PAD_DUMMY = net_select( CONNECT_DB, connected_to_any = { CB_VSS_DUMMY, UBMN_VSS_DUMMY, UBMD_VSS_DUMMY }, output_from_layers = { NSDIU } ); 
NWR_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PAD_M1IU_BY_TEXT, PAD_M2IU_BY_TEXT, PAD_M3IU_BY_TEXT, PAD_M4IU_BY_TEXT, PAD_M5IU_BY_TEXT, PAD_M6IU_BY_TEXT, PAD_MDIU_BY_TEXT }, output_from_layers = { NWRIU } ); 
NWR_VDD_VSS_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PWR_M1IU_BY_TEXT, PWR_M2IU_BY_TEXT, PWR_M3IU_BY_TEXT, PWR_M4IU_BY_TEXT, PWR_M5IU_BY_TEXT, PWR_M6IU_BY_TEXT, GND_M1IU_BY_TEXT, GND_M2IU_BY_TEXT, GND_M3IU_BY_TEXT, GND_M4IU_BY_TEXT, GND_M5IU_BY_TEXT, GND_M6IU_BY_TEXT, PWR_MDIU_BY_TEXT, GND_MDIU_BY_TEXT }, output_from_layers = { NWRIU } ); 
gLAYER_434 = PWR_M1IU_TEXT or PWR_M2IU_TEXT; 
gLAYER_433 = gLAYER_434 or PWR_M3IU_TEXT; 
gLAYER_432 = gLAYER_433 or PWR_M4IU_TEXT; 
gLAYER_431 = gLAYER_432 or PWR_M5IU_TEXT; 
gLAYER_430 = gLAYER_431 or PWR_M6IU_TEXT; 
PWR_TEXT = gLAYER_430 or PWR_MDIU_TEXT; 
gLAYER_439 = GND_M1IU_TEXT or GND_M2IU_TEXT; 
gLAYER_438 = gLAYER_439 or GND_M3IU_TEXT; 
gLAYER_437 = gLAYER_438 or GND_M4IU_TEXT; 
gLAYER_436 = gLAYER_437 or GND_M5IU_TEXT; 
gLAYER_435 = gLAYER_436 or GND_M6IU_TEXT; 
GND_TEXT = gLAYER_435 or GND_MDIU_TEXT; 
#ifdef CHECK_LATCHUP_BY_TEXT 
   gLAYER_444 = NWR_IOPAD or NWR_PAD_TEXT; 
   gLAYER_445 = NWR_VDD_VSS_PAD_TEXT or NWR_VDD_VSS_PAD_DUMMY; 
   NWR_IOPAD_ALL = gLAYER_444 not gLAYER_445; 
   MOS = interacting( DACT, ALL_GATE ); 
   PMOS_FILTER = copy( EMPTYI ); 
   NMOS_FILTER = copy( EMPTYI ); 
#endif /* end of #ifdef CHECK_LATCHUP_BY_TEXT  */ 
#ifndef CHECK_LATCHUP_BY_TEXT 
   NWR_IOPAD_ALL = NWR_IOPAD not NWR_VDD_VSS_PAD_DUMMY; 
   MOS = interacting( DACT, ALL_GATE ); 
   gLAYER_446 = VDDDMY or VSSDMY; 
   MOS_FILTER_DMY = interacting( gCHIP, gLAYER_446 ); 
   gLAYER_447 = interacting( MOS, PSD_PAD, == 1, connect_sequence = CONNECT_DB, count_by = NET ); 
   PMOS_FILTER = gLAYER_447 not MOS_FILTER_DMY; 
   gLAYER_448 = interacting( MOS, NSD_PAD, == 1, connect_sequence = CONNECT_DB, count_by = NET ); 
   NMOS_FILTER = gLAYER_448 not MOS_FILTER_DMY; 
#endif /* end of #ifndef CHECK_LATCHUP_BY_TEXT  */ 
gLAYER_449 = not_interacting( MOS, CO ); 
gLAYER_450 = interacting( POLY, CO ); 
DUMMY_MOS = not_interacting( gLAYER_449, gLAYER_450 ); 
gLAYER_451 = not_interacting( DACT, POLY ); 
DUMMY_DIODE = not_interacting( gLAYER_451, CO ); 
gLAYER_452 = DACT not DUMMY_MOS; 
DACT_REAL = gLAYER_452 not DUMMY_DIODE; 
PACT_REAL = PACT not DUMMY_MOS; 
NACT_REAL = NACT not DUMMY_MOS; 
gLAYER_456 = DACT_REAL not PMOS_FILTER; 
gLAYER_455 = gLAYER_456 not NMOS_FILTER; 
gLAYER_454 = interacting( gLAYER_455, SD_IOPAD ); 
gLAYER_457 = interacting( OD, NWR_IOPAD ); 
gLAYER_453 = gLAYER_454 or gLAYER_457;
POST_DRIVER_ACT = gLAYER_453 not_inside LUPWDMY; 
#ifdef DISCONNECT_ALL_RESISTOR 
   #ifdef CONNECT_ALL_RESISTOR 
      rLUP_WARN_1 @= { @ "LUP.WARN.1 : DRC LUP switch setting conflict detected (refer to section XXX for details): Please follow one of the following LUP switch settings: 0 [Default setting: RES200 usage] Turns off both 'DISCONNECT_ALL_RESISTOR', and 'CONNECT_ALL_RESISTOR': circuits after RES200 will NOT be recognized as OD injector, or 1 Turns on 'DISCONNECT_ALL_RESISTOR' only: circuits after any resistor will NOT recognized as OD injector, or 2 Turns on 'CONNECT_ALL_RESISTOR' only: circuits after any resistor will always be recognized as OD injector Please DO NOT turn on both 'DISCONNECT_ALL_RESISTOR', and 'CONNECT_ALL_RESISTOR' at the same time, otherwise 'DISCONNECT_ALL_RESISTOR' will have higher priority";
          sLAYER_355 = copy( CHIPX ); 
          level( sLAYER_355 );
      } /* end of rule : LUP.WARN.1 */
   #endif /* end of #ifdef CONNECT_ALL_RESISTOR  */ 
#endif /* end of #ifdef DISCONNECT_ALL_RESISTOR  */ 

// For LUP.1 - I/O PAD N/P ACTIVE
//=================================
gLAYER_462 = interacting( POST_DRIVER_ACT, PSDIU ); 
POST_DRIVER_PACT = gLAYER_462 not_inside LUPWDMY; 
gLAYER_464 = interacting( POST_DRIVER_ACT, NSDIU ); 
gLAYER_465 = interacting( OD, NWR_IOPAD_ALL ); 
gLAYER_463 = gLAYER_464 or gLAYER_465;
POST_DRIVER_NACT = gLAYER_463 not_inside LUPWDMY; 

// For LUP.3
//==================
POST_DRIVER_PMOS = interacting( POST_DRIVER_PACT, ALL_GATE ); 
POST_DRIVER_PMOS_NW = stamp( POST_DRIVER_PMOS, NWEL, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
POST_DRIVER_PMOS_NW_HV = interacting( POST_DRIVER_PMOS_NW, HVGT ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_HV }, POST_DRIVER_PMOS_NW }} ); 
POST_DRIVER_PMOS_NW_33V = interacting( POST_DRIVER_PMOS_NW_HV, OD2I ); 
POST_DRIVER_PMOS_NW_25V = interacting( POST_DRIVER_PMOS_NW_HV, OD2I ); 
POST_DRIVER_PMOS_NW_50V = interacting( POST_DRIVER_PMOS_NW_HV, OD2I ); 
POST_DRIVER_PMOS_NW_LV = POST_DRIVER_PMOS_NW not POST_DRIVER_PMOS_NW_HV; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_LV }, POST_DRIVER_PMOS_NW }} ); 
POST_DRIVER_PMOS_NWI = stamp( POST_DRIVER_PMOS, NWELI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
POST_DRIVER_PMOS_NWI_HV = interacting( POST_DRIVER_PMOS_NWI, HVGT ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_HV }, POST_DRIVER_PMOS_NWI }} ); 
POST_DRIVER_PMOS_NWI_33V = interacting( POST_DRIVER_PMOS_NWI_HV, OD2I ); 
POST_DRIVER_PMOS_NWI_25V = interacting( POST_DRIVER_PMOS_NWI_HV, OD2I ); 
POST_DRIVER_PMOS_NWI_50V = interacting( POST_DRIVER_PMOS_NWI_HV, OD2I ); 
POST_DRIVER_PMOS_NWI_LV = POST_DRIVER_PMOS_NWI not POST_DRIVER_PMOS_NWI_HV; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_LV }, POST_DRIVER_PMOS_NWI }} ); 
POST_DRIVER_PINJ = copy( POST_DRIVER_PACT ); 
POST_DRIVER_PINJ_NW = stamp( POST_DRIVER_PINJ, NWEL, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
POST_DRIVER_PINJ_NW_HV = interacting( POST_DRIVER_PINJ_NW, OD2I ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_HV }, POST_DRIVER_PINJ_NW }} ); 
POST_DRIVER_PINJ_NW_LV = POST_DRIVER_PINJ_NW not POST_DRIVER_PINJ_NW_HV; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_LV }, POST_DRIVER_PINJ_NW }} ); 
POST_DRIVER_PINJ_NWI = stamp( POST_DRIVER_PINJ, NWELI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
POST_DRIVER_PINJ_NWI_HV = interacting( POST_DRIVER_PINJ_NWI, OD2I ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_HV }, POST_DRIVER_PINJ_NWI }} ); 
POST_DRIVER_PINJ_NWI_LV = POST_DRIVER_PINJ_NWI not POST_DRIVER_PINJ_NWI_HV; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_LV }, POST_DRIVER_PINJ_NWI }} ); 
POST_DRIVER_NINJ = copy( POST_DRIVER_NACT ); 
gLAYER_466 = POST_DRIVER_NINJ inside DNW; 
POST_DRIVER_NINJ_RW = stamp( gLAYER_466, DNW, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
POST_DRIVER_NINJ_PW = POST_DRIVER_NINJ not POST_DRIVER_NINJ_RW; 
DNWC = stamp( DNW, NWELI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
gLAYER_467 = POST_DRIVER_NINJ inside DNW; 
POST_DRIVER_NINJ_RWI = stamp( gLAYER_467, DNWC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
POST_DRIVER_NMOS = interacting( POST_DRIVER_NACT, ALL_GATE ); 
gLAYER_468 = POST_DRIVER_NMOS inside DNW; 
POST_DRIVER_NMOS_RW = stamp( gLAYER_468, DNW, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
POST_DRIVER_NMOS_PW = POST_DRIVER_NMOS not POST_DRIVER_NMOS_RW; 
POST_DRIVER_NMOS_RW_HV = interacting( POST_DRIVER_NMOS_RW, HVGT ); 
POST_DRIVER_NMOS_RW_33V = interacting( POST_DRIVER_NMOS_RW_HV, OD2I ); 
POST_DRIVER_NMOS_RW_25V = interacting( POST_DRIVER_NMOS_RW_HV, OD2I ); 
POST_DRIVER_NMOS_RW_50V = interacting( POST_DRIVER_NMOS_RW_HV, OD2I ); 
POST_DRIVER_NMOS_RW_LV = POST_DRIVER_NMOS_RW not POST_DRIVER_NMOS_RW_HV; 
POST_DRIVER_NMOS_PW_HV = interacting( POST_DRIVER_NMOS_PW, HVGT ); 
POST_DRIVER_NMOS_PW_33V = interacting( POST_DRIVER_NMOS_PW_HV, OD2I ); 
POST_DRIVER_NMOS_PW_25V = interacting( POST_DRIVER_NMOS_PW_HV, OD2I ); 
POST_DRIVER_NMOS_PW_50V = interacting( POST_DRIVER_NMOS_PW_HV, OD2I ); 
POST_DRIVER_NMOS_PW_LV = POST_DRIVER_NMOS_PW not POST_DRIVER_NMOS_PW_HV; 
gLAYER_469 = POST_DRIVER_NMOS inside DNWC; 
POST_DRIVER_NMOS_RWI = stamp( gLAYER_469, DNWC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
POST_DRIVER_NMOS_RWI_HV = interacting( POST_DRIVER_NMOS_RWI, HVGT ); 
POST_DRIVER_NMOS_RWI_33V = interacting( POST_DRIVER_NMOS_RWI_HV, OD2I ); 
POST_DRIVER_NMOS_RWI_25V = interacting( POST_DRIVER_NMOS_RWI_HV, OD2I ); 
POST_DRIVER_NMOS_RWI_50V = interacting( POST_DRIVER_NMOS_RWI_HV, OD2I ); 
POST_DRIVER_NMOS_RWI_LV = POST_DRIVER_NMOS_RWI not POST_DRIVER_NMOS_RWI_HV; 
POST_DRIVER_MOS = POST_DRIVER_NMOS or POST_DRIVER_PMOS; 
BESIDE_POST_DRIVER = size( POST_DRIVER_MOS, clip_acute = NONE, corner_extension = RADIAL_INSIDE, distance = LUP_2, radial_sectors = 4 ); 
gLAYER_472 = interacting( NACT_REAL, ALL_GATE ); 
gLAYER_471 = gLAYER_472 not_outside BESIDE_POST_DRIVER; 
gLAYER_470 = gLAYER_471 not POST_DRIVER_NACT; 
BESIDE_POST_DRIVER_NMOS = gLAYER_470 not DUMMY_MOS; 
gLAYER_474 = NACT_REAL not_outside BESIDE_POST_DRIVER; 
gLAYER_473 = gLAYER_474 not POST_DRIVER_NACT; 
BESIDE_POST_DRIVER_NACT = gLAYER_473 not DUMMY_MOS; 
gLAYER_477 = interacting( PACT_REAL, ALL_GATE ); 
gLAYER_476 = gLAYER_477 not_outside BESIDE_POST_DRIVER; 
gLAYER_475 = gLAYER_476 not POST_DRIVER_PACT; 
BESIDE_POST_DRIVER_PMOS = gLAYER_475 not DUMMY_MOS; 
gLAYER_479 = PACT_REAL not_outside BESIDE_POST_DRIVER; 
gLAYER_478 = gLAYER_479 not POST_DRIVER_PACT; 
BESIDE_POST_DRIVER_PACT = gLAYER_478 not DUMMY_MOS; 

// for LUP.5.4
BESIDE_POST_DRIVER_1 = size( POST_DRIVER_MOS, clip_acute = NONE, corner_extension = RADIAL_INSIDE, distance = LUP_5_4_1, radial_sectors = 4 ); 
gLAYER_482 = interacting( NACT_REAL, ALL_GATE ); 
gLAYER_481 = gLAYER_482 not_outside BESIDE_POST_DRIVER_1; 
gLAYER_480 = gLAYER_481 not POST_DRIVER_NACT; 
BESIDE_POST_DRIVER_NMOS_1 = gLAYER_480 not DUMMY_MOS; 
gLAYER_485 = interacting( PACT_REAL, ALL_GATE ); 
gLAYER_484 = gLAYER_485 not_outside BESIDE_POST_DRIVER_1; 
gLAYER_483 = gLAYER_484 not POST_DRIVER_PACT; 
BESIDE_POST_DRIVER_PMOS_1 = gLAYER_483 not DUMMY_MOS; 
BESIDE_POST_DRIVER_PMOS_NW = stamp( BESIDE_POST_DRIVER_PMOS, NWEL, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
BESIDE_POST_DRIVER_PMOS_NW_HV = interacting( BESIDE_POST_DRIVER_PMOS_NW, HVGT ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ BESIDE_POST_DRIVER_PMOS_NW_HV }, BESIDE_POST_DRIVER_PMOS_NW }} ); 
BESIDE_POST_DRIVER_PMOS_NW_33V = interacting( BESIDE_POST_DRIVER_PMOS_NW_HV, OD2I ); 
BESIDE_POST_DRIVER_PMOS_NW_25V = interacting( BESIDE_POST_DRIVER_PMOS_NW_HV, OD2I ); 
BESIDE_POST_DRIVER_PMOS_NW_50V = interacting( BESIDE_POST_DRIVER_PMOS_NW_HV, OD2I ); 
BESIDE_POST_DRIVER_PMOS_NW_LV = BESIDE_POST_DRIVER_PMOS_NW not BESIDE_POST_DRIVER_PMOS_NW_HV; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ BESIDE_POST_DRIVER_PMOS_NW_LV }, BESIDE_POST_DRIVER_PMOS_NW }} ); 
BESIDE_POST_DRIVER_PMOS_NWI = stamp( BESIDE_POST_DRIVER_PMOS, NWELI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
BESIDE_POST_DRIVER_PMOS_NWI_HV = interacting( BESIDE_POST_DRIVER_PMOS_NWI, HVGT ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ BESIDE_POST_DRIVER_PMOS_NWI_HV }, BESIDE_POST_DRIVER_PMOS_NWI }} ); 
BESIDE_POST_DRIVER_PMOS_NWI_33V = interacting( BESIDE_POST_DRIVER_PMOS_NWI_HV, OD2I ); 
BESIDE_POST_DRIVER_PMOS_NWI_25V = interacting( BESIDE_POST_DRIVER_PMOS_NWI_HV, OD2I ); 
BESIDE_POST_DRIVER_PMOS_NWI_50V = interacting( BESIDE_POST_DRIVER_PMOS_NWI_HV, OD2I ); 
BESIDE_POST_DRIVER_PMOS_NWI_LV = BESIDE_POST_DRIVER_PMOS_NWI not BESIDE_POST_DRIVER_PMOS_NWI_HV; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ BESIDE_POST_DRIVER_PMOS_NWI_LV }, BESIDE_POST_DRIVER_PMOS_NWI }} ); 
gLAYER_486 = BESIDE_POST_DRIVER_NMOS inside DNW; 
BESIDE_POST_DRIVER_NMOS_RW = stamp( gLAYER_486, DNW, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
BESIDE_POST_DRIVER_NMOS_PW = BESIDE_POST_DRIVER_NMOS not BESIDE_POST_DRIVER_NMOS_RW; 
BESIDE_POST_DRIVER_NMOS_RW_HV = interacting( BESIDE_POST_DRIVER_NMOS_RW, HVGT ); 
BESIDE_POST_DRIVER_NMOS_RW_33V = interacting( BESIDE_POST_DRIVER_NMOS_RW_HV, OD2I ); 
BESIDE_POST_DRIVER_NMOS_RW_25V = interacting( BESIDE_POST_DRIVER_NMOS_RW_HV, OD2I ); 
BESIDE_POST_DRIVER_NMOS_RW_50V = interacting( BESIDE_POST_DRIVER_NMOS_RW_HV, OD2I ); 
BESIDE_POST_DRIVER_NMOS_RW_LV = BESIDE_POST_DRIVER_NMOS_RW not BESIDE_POST_DRIVER_NMOS_RW_HV; 
BESIDE_POST_DRIVER_NMOS_PW_HV = interacting( BESIDE_POST_DRIVER_NMOS_PW, HVGT ); 
BESIDE_POST_DRIVER_NMOS_PW_33V = interacting( BESIDE_POST_DRIVER_NMOS_PW_HV, OD2I ); 
BESIDE_POST_DRIVER_NMOS_PW_25V = interacting( BESIDE_POST_DRIVER_NMOS_PW_HV, OD2I ); 
BESIDE_POST_DRIVER_NMOS_PW_50V = interacting( BESIDE_POST_DRIVER_NMOS_PW_HV, OD2I ); 
BESIDE_POST_DRIVER_NMOS_PW_LV = BESIDE_POST_DRIVER_NMOS_PW not BESIDE_POST_DRIVER_NMOS_PW_HV; 
gLAYER_487 = BESIDE_POST_DRIVER_NMOS inside DNWC; 
BESIDE_POST_DRIVER_NMOS_RWI = stamp( gLAYER_487, DNWC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
BESIDE_POST_DRIVER_NMOS_RWI_HV = interacting( BESIDE_POST_DRIVER_NMOS_RWI, HVGT ); 
BESIDE_POST_DRIVER_NMOS_RWI_33V = interacting( BESIDE_POST_DRIVER_NMOS_RWI_HV, OD2I ); 
BESIDE_POST_DRIVER_NMOS_RWI_25V = interacting( BESIDE_POST_DRIVER_NMOS_RWI_HV, OD2I ); 
BESIDE_POST_DRIVER_NMOS_RWI_50V = interacting( BESIDE_POST_DRIVER_NMOS_RWI_HV, OD2I ); 
BESIDE_POST_DRIVER_NMOS_RWI_LV = BESIDE_POST_DRIVER_NMOS_RWI not BESIDE_POST_DRIVER_NMOS_RWI_HV; 

// for LUP.5.4
BESIDE_POST_DRIVER_PMOS_NW_1 = stamp( BESIDE_POST_DRIVER_PMOS_1, NWEL, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
BESIDE_POST_DRIVER_PMOS_NW_HV_1 = interacting( BESIDE_POST_DRIVER_PMOS_NW_1, HVGT ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ BESIDE_POST_DRIVER_PMOS_NW_HV_1 }, BESIDE_POST_DRIVER_PMOS_NW_1 }} ); 
BESIDE_POST_DRIVER_PMOS_NWI_1 = stamp( BESIDE_POST_DRIVER_PMOS_1, NWELI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
BESIDE_POST_DRIVER_PMOS_NWI_HV_1 = interacting( BESIDE_POST_DRIVER_PMOS_NWI_1, HVGT ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ BESIDE_POST_DRIVER_PMOS_NWI_HV_1 }, BESIDE_POST_DRIVER_PMOS_NWI_1 }} ); 
gLAYER_488 = BESIDE_POST_DRIVER_NMOS_1 inside DNW; 
BESIDE_POST_DRIVER_NMOS_RW_1 = stamp( gLAYER_488, DNW, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
BESIDE_POST_DRIVER_NMOS_PW_1 = BESIDE_POST_DRIVER_NMOS_1 not BESIDE_POST_DRIVER_NMOS_RW_1; 
gLAYER_489 = BESIDE_POST_DRIVER_NMOS_1 inside DNWC; 
BESIDE_POST_DRIVER_NMOS_RWI_1 = stamp( gLAYER_489, DNWC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
#ifdef GUIDELINE_LUP 
   rLUP_1G @= { @ "LUP.1g : Any N+ OD injector or an N+ OD injector cluster connected to an I/O pad must be surrounded by a P+ guard-ring. "
                           "Any P+ OD injector or a P+ OD injector cluster connected to an I/O pad must be surrounded by a N+ guard-ring.";
       POST_DRIVER_NACT not_inside PTAP_GUARD_RING_HOLE; 
       POST_DRIVER_PACT not_inside NTAP_GUARD_RING_HOLE; 
   } /* end of rule : LUP.1g */
   rLUP_2G @= { @ "LUP.2g : Within " + LUP_2 + " um space from the OD injector connected to an I/O pad, a P+ guard-ring is required to surround an NACT or an NACT cluster. And an N+ guard-ring is required to surround a PACT or a PACT cluster."; 
       sLAYER_359 = interacting( DNW, BESIDE_POST_DRIVER_NMOS_RW ); 
       sLAYER_358 = interacting( NWEL, sLAYER_359 ); 
       sLAYER_357 = interacting( sLAYER_358, POST_DRIVER_PMOS_NW ); 
       sLAYER_356 = interacting( DNW, sLAYER_357 ); 
       X = interacting( BESIDE_POST_DRIVER_NMOS_RW, sLAYER_356 ); 
       Y = external2_edge( POST_DRIVER_PMOS_NWI, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
       sLAYER_360 = not_interacting( BESIDE_POST_DRIVER_NMOS_RWI, X ); 
       BESIDE_POST_DRIVER_NMOS_WAIVE = sLAYER_360 not_touching Y; 
       sLAYER_361 = BESIDE_POST_DRIVER_NACT not BESIDE_POST_DRIVER_NMOS_WAIVE; 
       sLAYER_361 not_inside PTAP_GUARD_RING_HOLE; 
       BESIDE_POST_DRIVER_PACT not_inside NTAP_GUARD_RING_HOLE; 
   } /* end of rule : LUP.2g */
   #ifdef _1_8V 
      rLUP_3_1G_1_8V @= { @ "LUP.3.1g_1.8V : For the N/PMOS which connects to an I/O pad, space between the NMOS and the 1.8V PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= " + LUP_3_1 + " um"; 
          external2( POST_DRIVER_PMOS_NW_LV, POST_DRIVER_NMOS_PW, < LUP_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PMOS_NW_LV, POST_DRIVER_NMOS_RW, < LUP_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PMOS_NWI_LV, POST_DRIVER_NMOS_RWI, < LUP_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : LUP.3.1g_1.8V */
   #endif /* end of #ifdef _1_8V  */ 
   #ifdef _1_5V 
      rLUP_3_1G_1_5V @= { @ "LUP.3.1g_1.5V : For the N/PMOS which connects to an I/O pad, space between the NMOS and the 1.5V PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= " + LUP_3_1 + " um"; 
          external2( POST_DRIVER_PMOS_NW_LV, POST_DRIVER_NMOS_PW, < LUP_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PMOS_NW_LV, POST_DRIVER_NMOS_RW, < LUP_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PMOS_NWI_LV, POST_DRIVER_NMOS_RWI, < LUP_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : LUP.3.1g_1.5V */
   #endif /* end of #ifdef _1_5V  */ 
   #ifdef _2_5V 
      rLUP_3_2G_2_5V @= { @ "LUP.3.2g_2.5V : For the N/PMOS which connects to an I/O pad directly, space between the the 2.5V PMOS and NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= " + LUP_3_2 + " um"; 
          external2( POST_DRIVER_NMOS_PW, POST_DRIVER_PMOS_NW_HV, < LUP_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NMOS_RW, POST_DRIVER_PMOS_NW_HV, < LUP_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NMOS_RWI, POST_DRIVER_PMOS_NWI_HV, < LUP_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : LUP.3.2g_2.5V */
   #endif /* end of #ifdef _2_5V  */ 
   #ifdef _3_3V 
      rLUP_3_3G_3_3V @= { @ "LUP.3.3g_3.3V : For the N/PMOS which connects to an I/O pad directly, space between the 3.3V PMOS and NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= " + LUP_3_3 + " um"; 
          external2( POST_DRIVER_NMOS_PW, POST_DRIVER_PMOS_NW_HV, < LUP_3_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NMOS_RW, POST_DRIVER_PMOS_NW_HV, < LUP_3_3, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NMOS_RWI, POST_DRIVER_PMOS_NWI_HV, < LUP_3_3, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : LUP.3.3g_3.3V */
   #endif /* end of #ifdef _3_3V  */ 
   #ifdef _5V 
      rLUP_3_4G_5V @= { @ "LUP.3.4g_5V : For the N/PMOS which connects to an I/O pad directly, space between the 5V PMOS and NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= " + LUP_3_4 + " um"; 
          external2( POST_DRIVER_NMOS_PW, POST_DRIVER_PMOS_NW_HV, < LUP_3_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NMOS_RW, POST_DRIVER_PMOS_NW_HV, < LUP_3_4, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NMOS_RWI, POST_DRIVER_PMOS_NWI_HV, < LUP_3_4, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : LUP.3.4g_5V */
   #endif /* end of #ifdef _5V  */ 
   rLUP_4G @= { @ "LUP.4g : Width of the N+ guard-ring, P+ guard-ring, N+ STRAP and P+ STRAP for the Active connected to an I/O pad, and also MOS within 20um space from the MOS connected to an I/O pad. >= " + LUP_4 + " um"; 
       sLAYER_362 = POST_DRIVER_NACT or BESIDE_POST_DRIVER_NMOS; 
       PTAP_GUARD_RING_HOLEX = enclosing( PTAP_GUARD_RING_HOLE, sLAYER_362 ); 
       sLAYER_363 = POST_DRIVER_PACT or BESIDE_POST_DRIVER_PMOS; 
       NTAP_GUARD_RING_HOLEX = enclosing( NTAP_GUARD_RING_HOLE, sLAYER_363 ); 
       sLAYER_364 = outside_touching( PTAPI, PTAP_GUARD_RING_HOLEX ); 
       PTAP_GUARD_RING_WIDE = wide( sLAYER_364, >= LUP_4 ); 
       sLAYER_365 = outside_touching( NTAPI, NTAP_GUARD_RING_HOLEX ); 
       NTAP_GUARD_RING_WIDE = wide( sLAYER_365, >= LUP_4 ); 
       sLAYER_366 = donut_holes( PTAP_GUARD_RING_WIDE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
       PTAP_GUARD_RING_WIDE_HOLE = sLAYER_366 inside PWELI; 
       sLAYER_367 = donut_holes( NTAP_GUARD_RING_WIDE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
       NTAP_GUARD_RING_WIDE_HOLE = sLAYER_367 inside NWELI; 
       PTAP_GUARD_RING_HOLE_CHECK = PTAP_GUARD_RING_HOLEX not_inside PTAP_GUARD_RING_WIDE_HOLE; 
       NTAP_GUARD_RING_HOLE_CHECK = NTAP_GUARD_RING_HOLEX not_inside NTAP_GUARD_RING_WIDE_HOLE; 
       PTAP_GUARD_RING_CHECK = PTAPI coincident_outside_edge PTAP_GUARD_RING_HOLE_CHECK; 
       NTAP_GUARD_RING_CHECK = NTAPI coincident_outside_edge NTAP_GUARD_RING_HOLE_CHECK; 
       internal2( PTAP_GUARD_RING_CHECK, PTAPI, < LUP_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
       internal2( NTAP_GUARD_RING_CHECK, NTAPI, < LUP_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
   } /* end of rule : LUP.4g */
   #ifdef _1_8V 
      rLUP_5_1G_1_8V @= { @ "LUP.5.1g_1.8V : Minimum space >= " + LUP_5_1 + " um " 
                                            "1. between N+ OD injector and the the 1.8V PMOS in the internal circuit "
                                            "2. between 1.8V P+ OD injector and the NMOS in the internal circuit";
          external2( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PINJ_NWI_LV, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_PW, BESIDE_POST_DRIVER_PMOS_NW_LV, < LUP_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_RW, BESIDE_POST_DRIVER_PMOS_NW_LV, < LUP_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_RWI, BESIDE_POST_DRIVER_PMOS_NWI_LV, < LUP_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : LUP.5.1g_1.8V */
   #endif /* end of #ifdef _1_8V  */ 
   #ifdef _1_5V 
      rLUP_5_1G_1_5V @= { @ "LUP.5.1g_1.5V : Minimum space >= " + LUP_5_1 + " um " 
                                            "1. between N+ OD injector and the the 1.5V PMOS in the internal circuit "
                                            "2. between 1.5V P+ OD injector and the NMOS in the internal circuit";
          external2( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PINJ_NWI_LV, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_PW, BESIDE_POST_DRIVER_PMOS_NW_LV, < LUP_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_RW, BESIDE_POST_DRIVER_PMOS_NW_LV, < LUP_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_RWI, BESIDE_POST_DRIVER_PMOS_NWI_LV, < LUP_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : LUP.5.1g_1.5V */
   #endif /* end of #ifdef _1_5V  */ 
   #ifdef _2_5V 
      rLUP_5_2G_2_5V @= { @ "LUP.5.2g_2.5V : Minimum space >= " + LUP_5_2 + " um " 
                                            "1. between N+ OD injector and the the 2.5V PMOS in the internal circuit "
                                            "2. between 2.5V P+ OD injector and the NMOS in the internal circuit";
          external2( POST_DRIVER_PINJ_NW_HV, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PINJ_NW_HV, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PINJ_NWI_HV, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_PW, BESIDE_POST_DRIVER_PMOS_NW_HV, < LUP_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_RW, BESIDE_POST_DRIVER_PMOS_NW_HV, < LUP_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_RWI, BESIDE_POST_DRIVER_PMOS_NWI_HV, < LUP_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : LUP.5.2g_2.5V */
   #endif /* end of #ifdef _2_5V  */ 
   #ifdef _3_3V 
      rLUP_5_3G_3_3V @= { @ "LUP.5.3g_3.3V : Minimum space >= " + LUP_5_3 + " um " 
                                            "1. between N+ OD injector and the the 3.3V PMOS in the internal circuit "
                                            "2. between 3.3V P+ OD injector and the NMOS in the internal circuit";
          external2( POST_DRIVER_PINJ_NW_HV, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PINJ_NW_HV, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_3, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PINJ_NWI_HV, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_3, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_PW, BESIDE_POST_DRIVER_PMOS_NW_HV, < LUP_5_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_RW, BESIDE_POST_DRIVER_PMOS_NW_HV, < LUP_5_3, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_RWI, BESIDE_POST_DRIVER_PMOS_NWI_HV, < LUP_5_3, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : LUP.5.3g_3.3V */
   #endif /* end of #ifdef _3_3V  */ 
   #ifdef _5V 
      rLUP_5_4G_5V @= { @ "LUP.5.4g_5V : Minimum space >= " + LUP_5_4 + " um " 
                                        "1. between N+ OD injector and the the 5V PMOS in the internal circuit "
                                        "2. between 5V P+ OD injector and the NMOS in the internal circuit";
          external2( POST_DRIVER_PINJ_NW_HV, BESIDE_POST_DRIVER_NMOS_PW_1, < LUP_5_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PINJ_NW_HV, BESIDE_POST_DRIVER_NMOS_RW_1, < LUP_5_4, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_PINJ_NWI_HV, BESIDE_POST_DRIVER_NMOS_RWI_1, < LUP_5_4, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_PW, BESIDE_POST_DRIVER_PMOS_NW_HV_1, < LUP_5_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_RW, BESIDE_POST_DRIVER_PMOS_NW_HV_1, < LUP_5_4, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          external2( POST_DRIVER_NINJ_RWI, BESIDE_POST_DRIVER_PMOS_NWI_HV_1, < LUP_5_4, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : LUP.5.4g_5V */
   #endif /* end of #ifdef _5V  */ 
   gLAYER_490 = PSDC not_outside COI; 
   CO_PACT = COI or gLAYER_490; 
   NPUI = interacting( NTAPI, CO_PACT ); 
   NPUI_SRAM = NPUI inside SRM; 
   NSTP_OS = size_inside_wrapper( NPUI, NWELI, distance = LUP_6, increment = NW_S_1 * 0.7 ); 
   NSTP_OS_SRAM = size_inside_wrapper( NPUI_SRAM, NWELI, distance = LUP_6_SRAM, increment = NW_S_1 * 0.7 ); 
   gLAYER_492 = interacting( PACTI, COI ); 
   gLAYER_491 = interacting( gLAYER_492, POLYI ); 
   PACT_CHECK = gLAYER_491 not POLYI; 
   PACT_CHECK_NON_SRAM = PACT_CHECK not_inside SRM; 
   PACT_CHECK_SRAM = PACT_CHECK inside SRM; 
   gLAYER_493 = NSDC not_outside COI; 
   CO_NACT = COI or gLAYER_493; 
   PPUI = interacting( PTAPI, CO_NACT ); 
   PPUI_SRAM = PPUI inside SRM; 
   PSTP_OS = size_inside_wrapper( PPUI, PWELI, distance = LUP_6, increment = NW_S_1 * 0.7 ); 
   PSTP_OS_SRAM = size_inside_wrapper( PPUI_SRAM, PWELI, distance = LUP_6_SRAM, increment = NW_S_1 * 0.7 ); 
   gLAYER_495 = interacting( NACTI, COI ); 
   gLAYER_494 = interacting( gLAYER_495, POLYI ); 
   NACT_CHECK = gLAYER_494 not POLYI; 
   NACT_CHECK_NON_SRAM = NACT_CHECK not_inside SRM; 
   NACT_CHECK_SRAM = NACT_CHECK inside SRM; 
   rLUP_6G @= { @ "LUP.6g : Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= " + LUP_6 + " um " 
                           "Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= " + LUP_6 + " um " 
                           "In SRAM bit cell region, the rule is relaxed to " + LUP_6_SRAM + " um"; 
       PACT_CHECK_NON_SRAM not NSTP_OS; 
       sLAYER_368 = NSTP_OS or NSTP_OS_SRAM; 
       PACT_CHECK_SRAM not sLAYER_368; 
       NACT_CHECK_NON_SRAM not PSTP_OS; 
       sLAYER_369 = PSTP_OS or PSTP_OS_SRAM; 
       NACT_CHECK_SRAM not sLAYER_369; 
   } /* end of rule : LUP.6g */
   
   // LUP.10 is checked by LUP.10__LUP.13
   // LUP.13 is checked by LUP.10__LUP.13
   #ifdef ALL_AREA_IO 
      rLUP_10G__LUP_13G @= { @ "LUP.10g__LUP.13g : For Area I/O, within " + LUP_10 + " um from OD injector,"; 
   #else /* the reverse of #ifdef ALL_AREA_IO  */ 
      rLUP_10G__LUP_13G @= { @ "LUP.10g__LUP.13g : For Area I/O, within " + LUP_10 + " um from OD injector (covered by LUPWDMY_2), " 
                                                  "Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= " + LUP_13 + " um " 
                                                  "Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= " + LUP_13 + " um"; 
   #endif /* end of #ifdef ALL_AREA_IO  */ 
   #ifdef ALL_AREA_IO 
          TRIGGER_SOURCE = copy( POST_DRIVER_ACT ); 
   #else /* the reverse of #ifdef ALL_AREA_IO  */ 
          TRIGGER_SOURCE = POST_DRIVER_ACT not_outside LUPWDMY_2; 
   #endif /* end of #ifdef ALL_AREA_IO  */ 
       sLAYER_370 = NACT_CHECK not TRIGGER_SOURCE; 
       CORE_LOGIC_NACT = sLAYER_370 not_inside PTAP_GUARD_RING_HOLE; 
       sLAYER_371 = PACT_CHECK not TRIGGER_SOURCE; 
       CORE_LOGIC_PACT = sLAYER_371 not_inside NTAP_GUARD_RING_HOLE; 
       sLAYER_372 = size( TRIGGER_SOURCE, clip_acute = NONE, distance = LUP_10 ); 
       NACT_LUP = CORE_LOGIC_NACT not_outside sLAYER_372; 
       sLAYER_373 = size( TRIGGER_SOURCE, clip_acute = NONE, distance = LUP_10 ); 
       PACT_LUP = CORE_LOGIC_PACT not_outside sLAYER_373; 
       sPSTP_OS = size_inside_wrapper( PPUI, PWELI, distance = LUP_13, increment = NW_S_1 * 0.7 ); 
       NACT_LUP not sPSTP_OS; 
       sNSTP_OS = size_inside_wrapper( NPUI, NWELI, distance = LUP_13, increment = NW_S_1 * 0.7 ); 
       PACT_LUP not sNSTP_OS; 
   } /* end of rule : LUP.10g__LUP.13g */
   
   // LUP.11 is not necessary to check. It is checked in ICV PERC.
   // LUP.12 is not necessary to check. It is checked in ICV PERC.
   rLUP_14G @= { @ "LUP.14g : For Area I/O, width of picup ring and guard rings for the OD injector >= " + LUP_14; 
   #ifdef ALL_AREA_IO 
          AREA_IO_NACT = copy( POST_DRIVER_NACT ); 
          AREA_IO_PACT = copy( POST_DRIVER_PACT ); 
   #else /* the reverse of #ifdef ALL_AREA_IO  */ 
          AREA_IO_NACT = POST_DRIVER_NACT not_outside LUPWDMY_2; 
          AREA_IO_PACT = POST_DRIVER_PACT not_outside LUPWDMY_2; 
   #endif /* end of #ifdef ALL_AREA_IO  */ 
       AREA_IO_NACT not_inside PTAP_GUARD_RING_HOLE; 
       AREA_IO_PACT not_inside NTAP_GUARD_RING_HOLE; 
       sLAYER_375 = donut_holes( PTAPI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
       sLAYER_374 = interacting( sLAYER_375, AREA_IO_PACT ); 
       PTAP_GUARD_RING_2ND = not_interacting( sLAYER_374, NACT ); 
       sLAYER_377 = donut_holes( NTAPI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
       sLAYER_376 = interacting( sLAYER_377, AREA_IO_NACT ); 
       NTAP_GUARD_RING_2ND = not_interacting( sLAYER_376, PACT ); 
       AREA_IO_NACT not_inside NTAP_GUARD_RING_2ND; 
       AREA_IO_PACT not_inside PTAP_GUARD_RING_2ND; 
       sLAYER_378 = interacting( PTAP_GUARD_RING_HOLE, AREA_IO_NACT ); 
       PTAP_GUARD_RING_HOLE_EDGE = PTAPI coincident_outside_edge sLAYER_378; 
       sLAYER_379 = interacting( NTAP_GUARD_RING_HOLE, AREA_IO_PACT ); 
       NTAP_GUARD_RING_HOLE_EDGE = NTAPI coincident_outside_edge sLAYER_379; 
       internal2( PTAP_GUARD_RING_HOLE_EDGE, PTAPI, < LUP_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
       internal2( NTAP_GUARD_RING_HOLE_EDGE, NTAPI, < LUP_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
       PTAP_GUARD_RING_2ND_EDGE = PTAPI coincident_outside_edge PTAP_GUARD_RING_2ND; 
       NTAP_GUARD_RING_2ND_EDGE = NTAPI coincident_outside_edge NTAP_GUARD_RING_2ND; 
       internal2( PTAP_GUARD_RING_2ND_EDGE, PTAPI, < LUP_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
       internal2( NTAP_GUARD_RING_2ND_EDGE, NTAPI, < LUP_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
   } /* end of rule : LUP.14g */
#endif /* end of #ifdef GUIDELINE_LUP  */ 

// LOGO CHECKS
//============
rLOGO_S_1 @= { @ "LOGO.S.1 : Min. LOGO space to NW, OD, PO, or Metals >= 3um";
    sLAYER_380 = size( LOGO, clip_acute = NONE, distance = 3 ); 
    LOGO_EXT = sLAYER_380 not LOGO; 
    LOGO_EXT and NWELI; 
    LOGO_EXT and ALL_OD; 
    LOGO_EXT and ALL_PO; 
    sLAYER_381 = M1I or M1DMY; 
    LOGO_EXT and sLAYER_381; 
    sLAYER_382 = M2I or M2DMY; 
    LOGO_EXT and sLAYER_382; 
    sLAYER_383 = M3I or M3DMY; 
    LOGO_EXT and sLAYER_383; 
    sLAYER_384 = M4I or M4DMY; 
    LOGO_EXT and sLAYER_384; 
    sLAYER_385 = M5I or M5DMY; 
    LOGO_EXT and sLAYER_385; 
    sLAYER_386 = M6I or M6DMY; 
    LOGO_EXT and sLAYER_386; 
    sLAYER_387 = MD or MDDMY; 
    LOGO_EXT and sLAYER_387; 
} /* end of rule : LOGO.S.1 */
rLOGO_O_1 @= { @ "LOGO.O.1 : LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, PPI or DMx is not allowed.";
    LOGO and CBI; 
    LOGO and CBDI; 
    LOGO and PPII; 
    LOGO and FWI; 
    LOGO and PLMIDEI; 
    LOGO and UBMI; 
    LOGO and DOD; 
    LOGO and DPO; 
    LOGO and M1DMY; 
    LOGO and M2DMY; 
    LOGO and M3DMY; 
    LOGO and M4DMY; 
    LOGO and M5DMY; 
    LOGO and M6DMY; 
    LOGO and MDDMY; 
} /* end of rule : LOGO.O.1 */
rLOGO_R_1 @= { @ "LOGO.R.1 : A circuit in LOGO is not allowed.";
    LOGO and ALL_GATE; 
    LOGO and PORES; 
    LOGO and ODRES; 
    LOGO and RNWEL; 
    LOGO and BJTDUMMY; 
    LOGO and DIODUMMY; 
    LOGO and VARDMY; 
    LOGO and CTM5I; 
} /* end of rule : LOGO.R.1 */

//LOGO.R.2 has been check by other DRC rules
#ifdef FULL_CHIP 
   #ifdef WITH_SEALRING 
      
      // Sealring Rulecheck
      //=================================
      rSR_S_1 @= { @ "SR.S.1 : Minimum width of Assembly isolation >= " + SR_S_1 + " um"; 
          ASS_REGION and COI; 
          ASS_REGION and DNWI; 
          ASS_REGION and NWELI; 
          ASS_REGION and POLYI; 
          ASS_REGION and DPO; 
          ASS_REGION and ODI; 
          ASS_REGION and DOD; 
          ASS_REGION and VIA1I; 
          ASS_REGION and VIA2I; 
          ASS_REGION and VIA3I; 
          ASS_REGION and VIA4I; 
          ASS_REGION and VIA5I; 
          ASS_REGION and M1I; 
          ASS_REGION and M2I; 
          ASS_REGION and M3I; 
          ASS_REGION and M4I; 
          ASS_REGION and M5I; 
          ASS_REGION and M6I; 
          ASS_REGION and VIADI; 
          ASS_REGION and MDI; 
          ASS_REGION and UBMI; 
          ASS_REGION and CBDI; 
          ASS_REGION and CBI; 
      } /* end of rule : SR.S.1 */
      rSR_R_1 @= { @ "SR.R.1 : sealring layer (126;0) is a must if customer adds sealring by thenmselves.";
          not_interacting( CHIPX, SEALRING ); 
      } /* end of rule : SR.R.1 */
      rSR_E_1 @= { @ "SR.E.1 : Minimum extension of metal to CO/VIA in seal ring. >= " + SR_E_1 + " um"; 
          enclose( SR_CO, M1, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_CO not M1; 
          enclose( SR_VIA1, M1, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_VIA1 not M1; 
          enclose( SR_VIA1, M2, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_VIA1 not M2; 
          enclose( SR_VIA2, M2, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_VIA2 not M2; 
          enclose( SR_VIA2, M3, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_VIA2 not M3; 
          enclose( SR_VIA3, M3, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_VIA3 not M3; 
          enclose( SR_VIA3, M4, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_VIA3 not M4; 
          enclose( SR_VIA4, M4, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_VIA4 not M4; 
          enclose( SR_VIA4, M5, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_VIA4 not M5; 
          enclose( SR_VIA5, M5, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_VIA5 not M5; 
          enclose( SR_VIA5, M6, < SR_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          SR_VIA5 not M6; 
      } /* end of rule : SR.E.1 */
      rSR_E_2 @= { @ "SR.E.2 : (OD interact sealring) enclosure of metal with the outer edge of sealring == " + SR_E_2 + " um"; 
          SR_OD = interacting( OD, SEALRING ); 
          SR_OD_HOLES = donut_holes( SR_OD, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          SR_OD_FULL = SR_OD or SR_OD_HOLES; 
          enclose( SR_M1, SR_OD_FULL, < SR_E_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
          enclose( SR_M2, SR_OD_FULL, < SR_E_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
          enclose( SR_M3, SR_OD_FULL, < SR_E_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
          enclose( SR_M4, SR_OD_FULL, < SR_E_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
          enclose( SR_M5, SR_OD_FULL, < SR_E_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
          enclose( SR_M6, SR_OD_FULL, < SR_E_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
          SR_OD_FULL_SIZE = size( SR_OD_FULL, clip_acute = NONE, distance = - SR_E_2 ); 
          SR_OD_FULL_SIZE not_coincident_inside_edge SR_M1; 
          SR_OD_FULL_SIZE not_coincident_inside_edge SR_M2; 
          SR_OD_FULL_SIZE not_coincident_inside_edge SR_M3; 
          SR_OD_FULL_SIZE not_coincident_inside_edge SR_M4; 
          SR_OD_FULL_SIZE not_coincident_inside_edge SR_M5; 
          SR_OD_FULL_SIZE not_coincident_inside_edge SR_M6; 
      } /* end of rule : SR.E.2 */
      rSR_R_2 @= { @ "SR.R.2 : It's not allowed that odd VIA bar(VIA1,3,5) overlap even VIA bar(VIA2,4)";
          SR_VIA1 and SR_VIA2; 
          SR_VIA2 and SR_VIA3; 
          SR_VIA3 and SR_VIA4; 
          SR_VIA4 and SR_VIA5; 
      } /* end of rule : SR.R.2 */
      rCO_W_2 @= { @ "CO.W.2 : Minimum and maximum width of CO bar. CO bar is only allowed in seal ring. == " + CO_W_2 + " um"; 
          internal1( SR_CO, < CO_W_2, extension = RADIAL, intersecting = {  }, relational = { POINT_TOUCH } ); 
          wide( SR_CO, > CO_W_2 ); 
      } /* end of rule : CO.W.2 */
      rVIA1_W_2 @= { @ "VIA1.W.2 : Minimum and maximum width of VIAx bar. VIAx bar is only allowed in seal ring. == " + VIA1_W_2 + " um"; 
          internal1( SR_VIA1, < VIA1_W_2, extension = RADIAL, intersecting = {  }, relational = { POINT_TOUCH } ); 
          wide( SR_VIA1, > VIA1_W_2 ); 
      } /* end of rule : VIA1.W.2 */
      rVIA2_W_2 @= { @ "VIA2.W.2 : Minimum and maximum width of VIAx bar. VIAx bar is only allowed in seal ring. == " + VIA2_W_2 + " um"; 
          internal1( SR_VIA2, < VIA2_W_2, extension = RADIAL, intersecting = {  }, relational = { POINT_TOUCH } ); 
          wide( SR_VIA2, > VIA2_W_2 ); 
      } /* end of rule : VIA2.W.2 */
      rVIA3_W_2 @= { @ "VIA3.W.2 : Minimum and maximum width of VIAx bar. VIAx bar is only allowed in seal ring. == " + VIA3_W_2 + " um"; 
          internal1( SR_VIA3, < VIA3_W_2, extension = RADIAL, intersecting = {  }, relational = { POINT_TOUCH } ); 
          wide( SR_VIA3, > VIA3_W_2 ); 
      } /* end of rule : VIA3.W.2 */
      rVIA4_W_2 @= { @ "VIA4.W.2 : Minimum and maximum width of VIAx bar. VIAx bar is only allowed in seal ring. == " + VIA4_W_2 + " um"; 
          internal1( SR_VIA4, < VIA4_W_2, extension = RADIAL, intersecting = {  }, relational = { POINT_TOUCH } ); 
          wide( SR_VIA4, > VIA4_W_2 ); 
      } /* end of rule : VIA4.W.2 */
      rVIAN_W_2 @= { @ "VIAn.W.2 : Minimum and maximum width of VIAn bar. VIAn bar is only allowed in seal ring. == " + VIAN_W_2 + " um"; 
          internal1( SR_VIA5, < VIAN_W_2, extension = RADIAL, intersecting = {  }, relational = { POINT_TOUCH } ); 
          wide( SR_VIA5, > VIAN_W_2 ); 
      } /* end of rule : VIAn.W.2 */
      #ifdef RECOMMEND 
         rCB_W_3 @= { @ "CB.W.3 : Mininum width of CB/CBD bar in seal ring region(butts the outer edge of seal ring) >= 2.0 um";
             ALL_PAD = CB or CBD; 
             sLAYER_388 = donut_holes( SEALRING_ALL, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
             C = SEALRING_ALL or sLAYER_388; 
             sLAYER_389 = donut_holes( ALL_PAD, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
             X = outside_touching( ALL_PAD, sLAYER_389 ); 
             internal1( X, < 2.0, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
             sLAYER_390 = donut_holes( ALL_PAD, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
             Y = ALL_PAD or sLAYER_390; 
             Y xor C; 
         } /* end of rule : CB.W.3 */
      #endif /* end of #ifdef RECOMMEND  */ 
   #endif /* end of #ifdef WITH_SEALRING  */ 
#endif /* end of #ifdef FULL_CHIP  */ 
#ifdef MIX_MODE 
   
   //===============================================================================
   // Mixed-Singal/RF part
   //===============================================================================
   
   // POLY CHECKS
   //==============
   rPO_W_1_HRI @= { @ "PO.W.1_HRI : Min. width of PO region for HRI poly resistor >= 1.0um";
       sHREPC = interacting( HREP, RLPPDMY ); 
       internal1( sHREPC, < 1.0, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } );
   } /* end of rule : PO.W.1_HRI */
   r_PO_R_1A_MM @= { @ "_PO.R.1A.MM : 90 degree L shape and U shape bent gates are not allowed";
       NORM_GATE_W = not_edge( GATE_W, VARDMY, coincident = false ); 
       external1_error( NORM_GATE_W, < 0.18, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ); 
       internal1_error( NORM_GATE_W, < 0.18, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } ); 
   } /* end of rule : _PO.R.1A.MM */
   
   // PP CHECKS
   //============
   r_PP_E_6_MM @= { @ "_PP.E.6.MM : Min. extension of a PP region beyond a PO as resistor >= " + PP_E_6_2 + " um"; 
       enclose( PORES, PP, < PP_E_6_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       sLAYER_392 = RPO and POLY; 
       sLAYER_391 = sLAYER_392 not IMP; 
       sLAYER_391 not HRI; 
   } /* end of rule : _PP.E.6.MM */
   
   // RPO CHECKS
   //=============
   rRPO_O_1_HRI @= { @ "RPO.O.1_HRI : Min. and Max. overlap of a PP region to RPO region for HRI == 0.3um";
       X = interacting( POLY_ISO, HRI ); 
       Y = and_edge( RPO, X, false ); 
       internal2_error( PP, Y, < 0.3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = RELATED_COINCIDENT ); 
       not_edge( Y, PP, coincident = false );    /* not overlap by P+ not allowed. */ 
       Z = edge_size( Y, inside = 0.30 ); 
       PPPO = PP and POLY; 
       A = PPPO and PORES; 
       B = interacting( A, HRI ); 
       B not Z; 
   } /* end of rule : RPO.O.1_HRI */
   #ifndef C0152 
      
      // M6 checks
      //=============
      M6T_NIND = M6XD not INDDMY; 
      INDDMYI = size( INDDMY, clip_acute = NONE, distance = - 7 );    /* exclude M1 substrate pick up node */ 
      INDM = INDDMY and M4; 
      INDME = INDM coincident_inside_edge INDDMY; 
      INDDMYA = touching( INDDMY, INDME, < 2 ); 
      INDDMY3 = enclosing( INDDMYA, M5 );    /* for 3 terminals inductor(central tap) */ 
      INDDMY2 = INDDMY not INDDMY3;      /* for 2 terminals inductor */ 
      #ifdef THICK_20K 
         rUTM20K_W_1 @= { @ "UTM20K.W.1 : Min. M6 width >= " + UTM20K_W_1 + " um"; 
             internal1( M6, < UTM20K_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : UTM20K.W.1 */
         rUTM20K_S_1 @= { @ "UTM20K.S.1 : Min. M6 spacing >= " + UTM20K_S_1 + " um"; 
             external1( M6, < UTM20K_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : UTM20K.S.1 */
         rUTM20K_E_1 @= { @ "UTM20K.E.1 : Min. extension of a M6 region beyond a VIA5 region >= 0.3 um";
             enclose( VIA5, M6, < 0.3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             VIA5 not M6; 
         } /* end of rule : UTM20K.E.1 */
         rUTM20K_E_2 @= { @ "UTM20K.E.2 : Min. extension of M6 end-of-line region beyond VIA5 region >= 0.45 um";
             X = enclose_edge( VIA5, M6, < 0.45, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
             internal1_error( X, < 0.36, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
         } /* end of rule : UTM20K.E.2 */
         rUTM20K_S_2 @= { @ "UTM20K.S.2 : Min. space of Wide M6 (>16um) and M6 >= 3.0 um (exclude application for inductor)";
             sLAYER_395 = shrink( M6T_NIND, east = 8 ); 
             sLAYER_394 = shrink( sLAYER_395, west = 8 );
             sLAYER_393 = shrink( sLAYER_394, north = 8 );
             M6T_NIND_S8 = shrink( sLAYER_393, south = 8 ); 
             sLAYER_398 = grow( M6T_NIND_S8, east = 8 ); 
             sLAYER_397 = grow( sLAYER_398, west = 8 );
             sLAYER_396 = grow( sLAYER_397, north = 8 );
             M6T_NIND_G8 = grow( sLAYER_396, south = 8 ); 
             M6T_NIND_WIDE = M6T_NIND_G8 and M6T_NIND; 
             M6T_NIND_EXP = size_inside_wrapper( M6T_NIND_WIDE, M6T_NIND, distance = 1, increment = 1.05 ); 
             M6T_NIND_BRANCH = M6T_NIND_EXP not M6T_NIND_WIDE; 
             M6T_NIND_BRANCH_EDGE = M6T_NIND_BRANCH coincident_inside_edge M6T_NIND; 
             sLAYER_399 = size( M6T_NIND_EXP, clip_acute = NONE, distance = 3.0 ); 
             M6T_NIND_CHECK = M6T_NIND and sLAYER_399; 
             sLAYER_400 = edge_size( M6T_NIND_BRANCH_EDGE, corner_extension = INTERSECTION, outside = 3.0 ); 
             M6T_NIND_BRANCH_CHECK = M6T_NIND and sLAYER_400; 
             M6T_NIND_WIDEC = stamp( M6T_NIND_WIDE, M6XD, CONNECT_DB, CONNECT_DB_UTM20K_S_2, include_touch = NONE ); 
             M6T_NIND_CHECKC = stamp( M6T_NIND_CHECK, M6XD, CONNECT_DB_UTM20K_S_2, CONNECT_DB_UTM20K_S_2, include_touch = NONE ); 
             M6T_NIND_BRANCHC = stamp( M6T_NIND_BRANCH, M6XD, CONNECT_DB_UTM20K_S_2, CONNECT_DB_UTM20K_S_2, include_touch = NONE ); 
             M6T_NIND_BRANCH_CHECKC = stamp( M6T_NIND_BRANCH_CHECK, M6XD, CONNECT_DB_UTM20K_S_2, CONNECT_DB_UTM20K_S_2, include_touch = NONE ); 
             external2( M6T_NIND_WIDEC, M6T_NIND_CHECKC, < 3.0, connect_sequence = CONNECT_DB_UTM20K_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
             external2( M6T_NIND_BRANCHC, M6T_NIND_BRANCH_CHECKC, < 3.0, connect_sequence = CONNECT_DB_UTM20K_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
         } /* end of rule : UTM20K.S.2 */
         rUTM20K_A_1 @= { @ "UTM20K.A.1 : Min. area of M6 region >= " + UTM20K_A_1 + " um2"; 
             area( M6, < UTM20K_A_1 ); 
         } /* end of rule : UTM20K.A.1 */
         rUTM20K_R_1 @= { @ "UTM20K.R.1 : Min. density of M6 area >= 30% (exclude application for inductor)";
             CHIP_NIND = gCHIP not INDDMY; 
             sLAYER_468 = chip_extent();
             VAR_9 = density_statistics_file( file = "M6T_DENSITY.log" ); 
         _den_con = < 0.3;
         _den_polygon_area_clip = true;
         _den_print = true;
         _den_print_only = false;
             density( window_layer = sLAYER_468, layer_hash = { "layer1" => M6T_NIND, "layer2" => CHIP_NIND }, statistics_files = { VAR_9 }, window_function = den_save_window_16 ); 
         } /* end of rule : UTM20K.R.1 */
         #ifdef RECOMMEND 
            rUTM20K_C_1 @= { @ "UTM20K.C.1 : Min. clearance from M6 as inductor to M6 >= " + UTM20K_C_1 + " um"; 
                sLAYER_401 = size( INDDMY, clip_acute = NONE, distance = - ( UTM20K_C_1 + 0.5 ) ); 
                IND_M6 = interacting( M6, sLAYER_401 ); 
                IND_M6V5 = interacting( VIA5, IND_M6 ); 
                IND_M5 = interacting( M5, IND_M6V5 ); 
                IND_M5V5 = interacting( VIA5, IND_M5 ); 
                IND_M6_CONN = interacting( M6, IND_M5V5 ); 
                IND_M6_ALL = IND_M6 or IND_M6_CONN; 
                IM6 = IND_M6_ALL and INDDMY; 
                RM6 = M6 not IND_M6_ALL; 
                OM6 = IND_M6_ALL not IM6; 
                external2( RM6, IM6, < UTM20K_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
                external2( IM6, OM6, < UTM20K_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, orientation = { PARALLEL }, projection = { IN } ); 
            } /* end of rule : UTM20K.C.1 */
         #endif /* end of #ifdef RECOMMEND  */ 
         rUTM20K_E_3 @= { @ "UTM20K.E.3 : Min. extension of INDDMY beyond M6 >= " + UTM20K_E_3 + " um"; 
             enclose( M6, INDDMY, < UTM20K_E_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
         } /* end of rule : UTM20K.E.3 */
         rUTM20K_I_1 @= { @ "UTM20K.I.1 : No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, "
                                         "and the M1 substrate pick up node of inductor";
             INDDMYI and M1; 
             INDDMY and VIA1; 
             INDDMY and M2; 
             INDDMY and VIA2; 
             INDDMY and M3; 
             INDDMY and VIA3; 
             INDDMY2 and M4; 
             INDDMY2 and VIA4; 
         } /* end of rule : UTM20K.I.1 */
         rUTM20K_I_2 @= { @ "UTM20K.I.2 : Both active and passive devices not allow inside INDDMY besides guard ring";
             INDDMY and NWEL; 
             INDDMY and POLY; 
             INDDMYI and OD;              /* exclude M1 substrate pick up node of inductor */ 
         } /* end of rule : UTM20K.I.2 */
         #ifdef RECOMMEND 
            rUTM20K_I_3 @= { @ "UTM20K.I.3 : It is recommended that NT_N fully overlap the region of inductor to achieve the high quality factor.";
                INDDMY not NTN; 
            } /* end of rule : UTM20K.I.3 */
         #endif /* end of #ifdef RECOMMEND  */ 
      #endif /* end of #ifdef THICK_20K  */ 
      #ifndef C016 
         #ifdef THICK_40K 
            rUTM40K_W_1 @= { @ "UTM40K.W.1 : Min. M6 width >= " + UTM40K_W_1 + " um"; 
                internal1( M6, < UTM40K_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
            } /* end of rule : UTM40K.W.1 */
            rUTM40K_S_1 @= { @ "UTM40K.S.1 : Min. M6 space >= " + UTM40K_S_1 + " um"; 
                external1( M6, < UTM40K_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
            } /* end of rule : UTM40K.S.1 */
            rUTM40K_E_1 @= { @ "UTM40K.E.1 : Min. extension of a M6 region beyond a VIA5 region >= 0.4 um";
                enclose( VIA5, M6, < 0.4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
                VIA5 not M6; 
            } /* end of rule : UTM40K.E.1 */
            rUTM40K_E_2 @= { @ "UTM40K.E.2 : Min. extension of M6 end-of-line region beyond VIA5 region >= 0.45 um";
                X = enclose_edge( VIA5, M6, < 0.45, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* a narrow side */ 
                internal1_error( X, < 0.36, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
            } /* end of rule : UTM40K.E.2 */
            rUTM40K_S_2 @= { @ "UTM40K.S.2 : Min. space of Wide M6 (>16um) and M6 >= 4.0 um (exclude application for inductor)";
                sLAYER_404 = shrink( M6T_NIND, east = 8 ); 
                sLAYER_403 = shrink( sLAYER_404, west = 8 );
                sLAYER_402 = shrink( sLAYER_403, north = 8 );
                M6T_NIND_S8 = shrink( sLAYER_402, south = 8 ); 
                sLAYER_407 = grow( M6T_NIND_S8, east = 8 ); 
                sLAYER_406 = grow( sLAYER_407, west = 8 );
                sLAYER_405 = grow( sLAYER_406, north = 8 );
                M6T_NIND_G8 = grow( sLAYER_405, south = 8 ); 
                M6T_NIND_WIDE = M6T_NIND_G8 and M6T_NIND; 
                M6T_NIND_EXP = size_inside_wrapper( M6T_NIND_WIDE, M6T_NIND, distance = 1, increment = 1.75 ); 
                M6T_NIND_BRANCH = M6T_NIND_EXP not M6T_NIND_WIDE; 
                M6T_NIND_BRANCH_EDGE = M6T_NIND_BRANCH coincident_inside_edge M6T_NIND; 
                sLAYER_408 = size( M6T_NIND_EXP, clip_acute = NONE, distance = 4.0 ); 
                M6T_NIND_CHECK = M6T_NIND and sLAYER_408; 
                sLAYER_409 = edge_size( M6T_NIND_BRANCH_EDGE, corner_extension = INTERSECTION, outside = 4.0 ); 
                M6T_NIND_BRANCH_CHECK = M6T_NIND and sLAYER_409; 
                M6T_NIND_WIDEC = stamp( M6T_NIND_WIDE, M6XD, CONNECT_DB, CONNECT_DB_UTM40K_S_2, include_touch = NONE ); 
                M6T_NIND_CHECKC = stamp( M6T_NIND_CHECK, M6XD, CONNECT_DB_UTM40K_S_2, CONNECT_DB_UTM40K_S_2, include_touch = NONE ); 
                M6T_NIND_BRANCHC = stamp( M6T_NIND_BRANCH, M6XD, CONNECT_DB_UTM40K_S_2, CONNECT_DB_UTM40K_S_2, include_touch = NONE ); 
                M6T_NIND_BRANCH_CHECKC = stamp( M6T_NIND_BRANCH_CHECK, M6XD, CONNECT_DB_UTM40K_S_2, CONNECT_DB_UTM40K_S_2, include_touch = NONE ); 
                external2( M6T_NIND_WIDEC, M6T_NIND_CHECKC, < 4.0, connect_sequence = CONNECT_DB_UTM40K_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
                external2( M6T_NIND_BRANCHC, M6T_NIND_BRANCH_CHECKC, < 4.0, connect_sequence = CONNECT_DB_UTM40K_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 89.5 ), look_thru = COINCIDENT ); 
            } /* end of rule : UTM40K.S.2 */
            rUTM40K_A_1 @= { @ "UTM40K.A.1 : Min. area of M6 region >= " + UTM40K_A_1 + " um2"; 
                area( M6, < UTM40K_A_1 ); 
            } /* end of rule : UTM40K.A.1 */
            rUTM40K_R_1 @= { @ "UTM40K.R.1 : Min. density of M6 area >= 30% (exclude application for inductor)";
                CHIP_NIND = gCHIP not INDDMY; 
                sLAYER_469 = chip_extent();
                VAR_10 = density_statistics_file( file = "M6T_DENSITY.log.2" ); 
            _den_con = < 0.3;
            _den_polygon_area_clip = true;
            _den_print = true;
            _den_print_only = false;
                density( window_layer = sLAYER_469, layer_hash = { "layer1" => M6T_NIND, "layer2" => CHIP_NIND }, statistics_files = { VAR_10 }, window_function = den_save_window_16 ); 
            } /* end of rule : UTM40K.R.1 */
            #ifdef RECOMMEND 
               rUTM40K_C_1 @= { @ "UTM40K.C.1 : Min. clearance from M6 as inductor to M6 >= " + UTM40K_C_1 + " um"; 
                   sLAYER_410 = size( INDDMY, clip_acute = NONE, distance = - ( UTM40K_C_1 + 0.5 ) ); 
                   IND_M6 = interacting( M6, sLAYER_410 ); 
                   IND_M6V5 = interacting( VIA5, IND_M6 ); 
                   IND_M5 = interacting( M5, IND_M6V5 ); 
                   IND_M5V5 = interacting( VIA5, IND_M5 ); 
                   IND_M6_CONN = interacting( M6, IND_M5V5 ); 
                   IND_M6_ALL = IND_M6 or IND_M6_CONN; 
                   IM6 = IND_M6_ALL and INDDMY; 
                   RM6 = M6 not IND_M6_ALL; 
                   OM6 = IND_M6_ALL not IM6; 
                   external2( RM6, IM6, < UTM40K_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
                   external2( IM6, OM6, < UTM40K_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, orientation = { PARALLEL }, projection = { IN } ); 
               } /* end of rule : UTM40K.C.1 */
            #endif /* end of #ifdef RECOMMEND  */ 
            rUTM40K_E_3 @= { @ "UTM40K.E.3 : Min. extension of INDDMY beyond M6 >= " + UTM40K_E_3 + " um"; 
                enclose( M6, INDDMY, < UTM40K_E_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
            } /* end of rule : UTM40K.E.3 */
            rUTM40K_I_1 @= { @ "UTM40K.I.1 : No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, "
                                            "and the M1 substrate pick up node of inductor";
                INDDMYI and M1; 
                INDDMY and VIA1; 
                INDDMY and M2; 
                INDDMY and VIA2; 
                INDDMY and M3; 
                INDDMY and VIA3; 
                INDDMY2 and M4; 
                INDDMY2 and VIA4; 
            } /* end of rule : UTM40K.I.1 */
            rUTM40K_I_2 @= { @ "UTM40K.I.2 : Both active and passive devices not allow inside INDDMY besides guard ring";
                INDDMY and NWEL; 
                INDDMY and POLY; 
                INDDMYI and OD;           /* exclude M1 substrate pick up node of inductor */ 
            } /* end of rule : UTM40K.I.2 */
            #ifdef RECOMMEND 
               rUTM40K_I_3 @= { @ "UTM40K.I.3 : It is recommended that NT_N fully overlap the region of inductor to achieve the high quality factor.";
                   INDDMY not NTN; 
               } /* end of rule : UTM40K.I.3 */
            #endif /* end of #ifdef RECOMMEND  */ 
            rUTM40K_R_2 @= { @ "UTM40K.R.2 : Max. density of {UTM OR dummy UTM} area <= " + UTM40K_R_2 + "% " 
                                            "Exclude application for inductor";
                CHIP_NIND = gCHIP not INDDMY; 
                sLAYER_470 = chip_extent();
                VAR_11 = density_statistics_file( file = "M6T_DENSITY_MAX.log" ); 
            _den_con = > ( UTM40K_R_2 / 100 ); 
            _den_polygon_area_clip = true;
            _den_print = true;
            _den_print_only = false;
                density( window_layer = sLAYER_470, layer_hash = { "layer1" => M6T_NIND, "layer2" => CHIP_NIND }, statistics_files = { VAR_11 }, window_function = den_save_window_16 ); 
            } /* end of rule : UTM40K.R.2 */
            rUTM40K_R_3 @= { @ "UTM40K.R.3 : The square number for dummy UTM <= " + UTM40K_R_3 + " " 
                                            "DRC only flag rectangle";
                M6DMY_REC = rectangles( M6DMY, orientation = ORTHOGONAL ); 
                not_aspect_ratio( M6DMY_REC, direction = SHORT_BY_LONG, ratio = >= (1/UTM40K_R_3) ); 
            } /* end of rule : UTM40K.R.3 */
            M6_SMALL = area( M6, < UTM40K_A_2 ); 
            M6_CONVEX = adjacent_edge( M6_SMALL, length = > 0, angle1 = (0, 180), angle2 = (0, 180) ); 
            gLAYER_496 = grow( M6_SMALL, east = GRID ); 
            M6_SMALL_R_EDGE = gLAYER_496 not M6_SMALL; 
            gLAYER_497 = M6_CONVEX touching_edge M6_SMALL_R_EDGE; 
            M6_SMALL_R_END = angle_edge( gLAYER_497, == 90 ); 
            M6_SMALL_R_GOOD = external2_edge( M6_SMALL_R_END, M6, < UTM40K_A_2_S, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
            M6_SMALL_R_BAD = M6_SMALL_R_END not_touching_edge M6_SMALL_R_GOOD; 
            M6_SMALL_R_EXCL = M6_SMALL not_touching M6_SMALL_R_BAD; 
            gLAYER_498 = grow( M6_SMALL, north = GRID ); 
            M6_SMALL_T_EDGE = gLAYER_498 not M6_SMALL; 
            gLAYER_499 = M6_CONVEX touching_edge M6_SMALL_T_EDGE; 
            M6_SMALL_T_END = angle_edge( gLAYER_499, == 0 ); 
            M6_SMALL_T_GOOD = external2_edge( M6_SMALL_T_END, M6, < UTM40K_A_2_S, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
            M6_SMALL_T_BAD = M6_SMALL_T_END not_touching_edge M6_SMALL_T_GOOD; 
            M6_SMALL_T_EXCL = M6_SMALL not_touching M6_SMALL_T_BAD; 
            gLAYER_500 = grow( M6_SMALL, west = GRID ); 
            M6_SMALL_L_EDGE = gLAYER_500 not M6_SMALL; 
            gLAYER_501 = M6_CONVEX touching_edge M6_SMALL_L_EDGE; 
            M6_SMALL_L_END = angle_edge( gLAYER_501, == 90 ); 
            M6_SMALL_L_GOOD = external2_edge( M6_SMALL_L_END, M6, < UTM40K_A_2_S, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
            M6_SMALL_L_BAD = M6_SMALL_L_END not_touching_edge M6_SMALL_L_GOOD; 
            M6_SMALL_L_EXCL = M6_SMALL not_touching M6_SMALL_L_BAD; 
            gLAYER_502 = grow( M6_SMALL, south = GRID ); 
            M6_SMALL_B_EDGE = gLAYER_502 not M6_SMALL; 
            gLAYER_503 = M6_CONVEX touching_edge M6_SMALL_B_EDGE; 
            M6_SMALL_B_END = angle_edge( gLAYER_503, == 0 ); 
            M6_SMALL_B_GOOD = external2_edge( M6_SMALL_B_END, M6, < UTM40K_A_2_S, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
            M6_SMALL_B_BAD = M6_SMALL_B_END not_touching_edge M6_SMALL_B_GOOD; 
            M6_SMALL_B_EXCL = M6_SMALL not_touching M6_SMALL_B_BAD; 
            rUTM40K_A_2 @= { @ "UTM40K.A.2 : Min. area of {UTM OR dummy UTM} island >= " + UTM40K_A_2 + " um2 " 
                                            "UTM island: space to another adjacent edge of {UTM or dummy UTM} >= " + UTM40K_A_2_S + " um"; 
                sLAYER_413 = M6_SMALL_R_EXCL or M6_SMALL_T_EXCL; 
                sLAYER_412 = sLAYER_413 or M6_SMALL_L_EXCL; 
                sLAYER_411 = sLAYER_412 or M6_SMALL_B_EXCL; 
                not_interacting( M6_SMALL, sLAYER_411 ); 
            } /* end of rule : UTM40K.A.2 */
         #endif /* end of #ifdef THICK_40K  */ 
      #endif /* end of #ifndef C016  */ 
   #endif /* end of #ifndef C0152  */ 
   
   // DNW CHECKS
   //==============
   RW = PWEL inside DNW; 
   #ifndef C016 
      #ifndef C0152 
         rDNW_W_1 @= { @ "DNW.W.1 : Min. width of a DNW region >= 3um";
             internal1( DNW, < 3.0, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : DNW.W.1 */
         rDNW_S_1 @= { @ "DNW.S.1 : Min. space between two DNW regions >= 5um";
             external1( DNW, < 5.0, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : DNW.S.1 */
      #endif /* end of #ifndef C0152  */ 
   #endif /* end of #ifndef C016  */ 
   #ifdef RECOMMEND 
      RW_NODAL = stamp( RW, RWI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      PWELX = PWEL not_inside DNW; 
      PWEL_NODAL = stamp( PWELX, PWELI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      rDNW_S_2 @= { @ "DNW.S.2 : Min. space between RW and {RW OR PW} with different potential >= 1.4um";
          external1( RW_NODAL, < 1.4, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          external2( RW_NODAL, PWEL_NODAL, < 1.4, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : DNW.S.2 */
   #endif /* end of #ifdef RECOMMEND  */ 
   rDNW_O_1 @= { @ "DNW.O.1 : Min. overlap from a NW edge to a DNW region >= 2.0um";
       internal2( DNW, NWEL, < 2.0, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : DNW.O.1 */
   rDNW_C_1 @= { @ "DNW.C.1 : Min. clearance from DNW to NW >= 3.5um";
       external2( NWEL, DNW, < 3.5, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = ALL, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : DNW.C.1 */
   rDNW_C_4 @= { @ "DNW.C.4 : Min. clearance from DNW to N+OD outside NW >= 3.0um";
       A = PWEL not DNW; 
       B = interacting( NPOD, A ); 
       external2( B, DNW, < 3.0, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       cutting( B, DNW ); 
   } /* end of rule : DNW.C.4 */
   #ifdef RECOMMEND 
      
      // DNW.R.3 is a recommended rule and un-checkable.
      rDNW_E_1 @= { @ "DNW.E.1 : Min. extension of NW beyond DNW for a better noise isolation >= 1.5um";
          enclose( DNW, NWEL, < 1.5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_414 = not_interacting( DNW, SBDDMY ); 
          not_edge( sLAYER_414, NWEL, coincident = false ); 
      } /* end of rule : DNW.E.1 */
   #endif /* end of #ifdef RECOMMEND  */ 
   rDNW_E_2 @= { @ "DNW.E.2 : Min. extension of DNW beyond N+OD outside NW >= 1.5um";
       A = PWEL and DNW; 
       B = interacting( NPOD, A ); 
       enclose( B, DNW, < 1.5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       cutting( B, DNW ); 
   } /* end of rule : DNW.E.2 */
   rDNW_R_4 @= { @ "DNW.R.4 : It is not allowed to use DNW as a resistor";
       DNW and RWDMY; 
   } /* end of rule : DNW.R.4 */
   rDNW_R_5 @= { @ "DNW.R.5 : It is not allowed to use {NW interact DNW} as a resistor";
       interacting( RNWEL, DNW ); 
       interacting( NWRES, DNW ); 
   } /* end of rule : DNW.R.5 */
   #ifdef C016 
      rDNW_W_1 @= { @ "DNW.W.1 : Min. DNW width < 3.3";
          internal1( DNW, < 3.3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DNW.W.1 */
      rDNW_S_1 @= { @ "DNW.S.1 : Min. DNW space < 5.5";
          external1( DNW, < 5.5, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DNW.S.1 */
   #endif /* end of #ifdef C016  */ 
   #ifndef C016 
      #ifdef C0152 
         rDNW_W_1 @= { @ "DNW.W.1 : Min. width of a DNW region >= " + DNW_W_1_0152; 
             internal1( DNW, < DNW_W_1_0152, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : DNW.W.1 */
         rDNW_S_1 @= { @ "DNW.S.1 : Min. space between two DNW regions >= " + DNW_S_1_0152; 
             external1( DNW, < DNW_S_1_0152, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : DNW.S.1 */
      #endif /* end of #ifdef C0152  */ 
   #endif /* end of #ifndef C016  */ 
   
   //VTM_N
   //=====
   rVTM_N_W_1 @= { @ "VTM_N.W.1 : Min. dimension of a VTM_N region >= 0.74um";
       internal1( VTMN, < 0.74, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
   } /* end of rule : VTM_N.W.1 */
   rVTM_N_W_2 @= { @ "VTM_N.W.2 : Min. PO gate dimension of a 1.8V medium Vt NMOS >= 0.3um";
       Z = and_edge( GATE_W, VTMN, false ); 
       internal1( Z, < 0.3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
   } /* end of rule : VTM_N.W.2 */
   rVTM_N_W_3 @= { @ "VTM_N.W.3 : Min. PO gate dimension of a 3.3V medium Vt NMOS >= 0.6um";
       Z = and_edge( HV_NGATE_W, VTMN, false ); 
       internal1( Z, < 0.6, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
   } /* end of rule : VTM_N.W.3 */
   rVTM_N_S_1 @= { @ "VTM_N.S.1 : Min. space between two VTM_N regions >= 0.44um";
       external1( VTMN, < 0.44, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : VTM_N.S.1 */
   rVTM_N_E_1 @= { @ "VTM_N.E.1 : Min. extension from a VTM_N region beyond an N+OD region >= 0.26um";
       enclose( NACT, VTMN, < 0.26, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       cutting( NACT, VTMN ); 
   } /* end of rule : VTM_N.E.1 */
   rVTM_N_C_1 @= { @ "VTM_N.C.1 : Min. clearance from a VTM_N region to an N+OD region >= 0.7um";
       external2( NACT, VTMN, < 0.7, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : VTM_N.C.1 */
   rVTM_N_C_2 @= { @ "VTM_N.C.2 : Min. clearance from a VTM_N region to an NW edge >= 0.43um";
       external2( VTMN, NWEL, < 0.43, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       VTMN and NWEL; 
   } /* end of rule : VTM_N.C.2 */
   rVTM_N_R_2 @= { @ "VTM_N.R.2 : VTM_N interact NT_N is not allowed (butted is allowed)";
       VTMN and NTN; 
   } /* end of rule : VTM_N.R.2 */
   rVTM_N_R_3 @= { @ "VTM_N.R.3 : A P+ Gate is not allowed in VTM_N region";
       VTMN and GATE_PP; 
   } /* end of rule : VTM_N.R.3 */
   rVTM_N_R_4 @= { @ "VTM_N.R.4 : A bent PO region is not allowed in VTM_N region";
       VTMN_PO = POLY and VTMN; 
       vertices( VTMN_PO, != 4 ); 
   } /* end of rule : VTM_N.R.4 */
   rVTM_N_R_5 @= { @ "VTM_N.R.5 : Min. clearance from an OD region in VTM_N region to a PO on field oxide >= 0.26um";
       VTMN_OD = VTMN and OD; 
       external2( VTMN_OD, POLY_ISO, < 0.26, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : VTM_N.R.5 */
   
   // VTM_P
   //======
   rVTM_P_W_1 @= { @ "VTM_P.W.1 : Min. dimension of a VTM_P region >= 0.74um";
       internal1( VTMP, < 0.74, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
   } /* end of rule : VTM_P.W.1 */
   rVTM_P_W_2 @= { @ "VTM_P.W.2 : Min. PO gate dimension of a 1.8V medium Vt PMOS >= 0.25um";
       Z = and_edge( GATE_W, VTMP, false ); 
       internal1( Z, < 0.25, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
   } /* end of rule : VTM_P.W.2 */
   rVTM_P_S_1 @= { @ "VTM_P.S.1 : Min. space between two VTM_P regions >= 0.44um";
       external1( VTMP, < 0.44, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : VTM_P.S.1 */
   rVTM_P_E_1 @= { @ "VTM_P.E.1 : Min. extension from a VTM_P region beyond a P+OD region >= 0.26um";
       enclose( PACT, VTMP, < 0.26, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       cutting( PACT, VTMP ); 
   } /* end of rule : VTM_P.E.1 */
   rVTM_P_C_1 @= { @ "VTM_P.C.1 : Min. clearance from a VTM_P region to a P+OD region >= 0.7um";
       external2( PACT, VTMP, < 0.7, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : VTM_P.C.1 */
   rVTM_P_C_2 @= { @ "VTM_P.C.2 : Min. clearance from a VTM_P region to a PW edge >= 0.43um";
       enclose( VTMP, NWEL, < 0.43, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       VTMP not NWEL; 
   } /* end of rule : VTM_P.C.2 */
   rVTM_P_R_2 @= { @ "VTM_P.R.2 : VTM_P interact NT_N is not allow, butted is allowed";
       VTMP and NTN; 
   } /* end of rule : VTM_P.R.2 */
   rVTM_P_R_3 @= { @ "VTM_P.R.3 : VTM_P interact OD2 is not allowed.";
       VTMP and OD2; 
   } /* end of rule : VTM_P.R.3 */
   rVTM_P_R_4 @= { @ "VTM_P.R.4 : A N+ Gate is not allowed in VTM_P region";
       VTMP and GATE_NP; 
   } /* end of rule : VTM_P.R.4 */
   rVTM_P_R_5 @= { @ "VTM_P.R.5 : A bent PO region is not allowed in VTM_P region";
       VTMP_PO = POLY and VTMP; 
       vertices( VTMP_PO, != 4 ); 
   } /* end of rule : VTM_P.R.5 */
   rVTM_P_R_6 @= { @ "VTM_P.R.6 : Min. clearance from an OD region in VTM_P region to a PO on field oxide >= 0.26um";
       VTMP_OD = VTMP and OD; 
       external2( VTMP_OD, POLY_ISO, < 0.26, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : VTM_P.R.6 */
   
   //HRI  
   //=== 
   rHRI_W_1 @= { @ "HRI.W.1 : Min. width of a HRI region >= 0.44um";
       internal1( HRI, < 0.44, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
   } /* end of rule : HRI.W.1 */
   rHRI_S_1 @= { @ "HRI.S.1 : Min. space between two HRI regions >= 0.44um";
       external1( HRI, < 0.44, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : HRI.S.1 */
   rHRI_C_1 @= { @ "HRI.C.1 : Min. clearance from an HRI region to an NP region >= 0.26um";
       X = external2( HRI, gNP, < 0.26, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       not_interacting( X, BUTT_PTAP ); 
   } /* end of rule : HRI.C.1 */
   rHRI_C_2 @= { @ "HRI.C.2 : Min. clearance from an HRI region to a PP region >= 0.26um";
       external2( HRI, PP, < 0.26, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : HRI.C.2 */
   rHRI_C_3_C_4 @= { @ "HRI.C.3_C.4 : Min. clearance from an HRI edge to Poly gate >= 0.32um";
       external2( HRI, ALL_GATE, < 0.32, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : HRI.C.3_C.4 */
   rHRI_E_1 @= { @ "HRI.E.1 : Min. enclosure from an HRI region beyond a PO resistor region >= 0.26um";
       enclose( PORES, HRI, < 0.26, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       sLAYER_415 = PORES not_outside HRI; 
       sLAYER_415 not HRI; 
   } /* end of rule : HRI.E.1 */
   rHRI_R_1 @= { @ "HRI.R.1 : Overlap of NP and HRI is not allowed";
       HRI and gNP; 
   } /* end of rule : HRI.R.1 */
   rHRI_R_2 @= { @ "HRI.R.2 : Overlap of OD and HRI is not allowed";
       HRI and OD; 
   } /* end of rule : HRI.R.2 */
   rHRI_A_1 @= { @ "HRI.A.1 : Min. area of a HRI region >= 0.3844um2";
       area( HRI, < 0.3844 ); 
   } /* end of rule : HRI.A.1 */
   DCTM = not_interacting( CTM5, VIA5 );    /* Dummy CTM */ 
   DPM5 = interacting( M5, DCTM );       /* M5 as a dummy CBM */ 
   BPM5C = BPM5 coincident_edge M5; 
   rCTM_W_1 @= { @ "CTM.W.1 : Min. width of a CTM region >= " + CTM_W_1 + " um"; 
       internal1( TCTM, < CTM_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
   } /* end of rule : CTM.W.1 */
   rCTM_W_2 @= { @ "CTM.W.2 : Min. width of a dummy CTM region >= " + CTM_W_2 + " um"; 
       internal1( DCTM, < CTM_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
   } /* end of rule : CTM.W.2 */
   rCTM_S_1 @= { @ "CTM.S.1 : Min. space between two CTM regions >= " + CTM_S_1 + " um"; 
       external1( TCTM, < CTM_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : CTM.S.1 */
   rCTM_S_2 @= { @ "CTM.S.2 : Min. space between a dummy CTM and a CTM region or two dummy CTM regions >= " + CTM_S_2 + " um"; 
       external2( DCTM, TCTM, < CTM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       external1( DCTM, < CTM_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : CTM.S.2 */
   rCTM_R_2 @= { @ "CTM.R.2 : Min. density of all CTM area >= 3%";
       sLAYER_471 = chip_extent();
       VAR_12 = density_statistics_file( file = "CTM5i.density" ); 
   _den_con = ( 0, 0.03 );
   _den_polygon_area_clip = true;
   _den_print = true;
   _den_print_only = false;
       density( window_layer = sLAYER_471, layer_hash = { "layer1" => CTM5I }, statistics_files = { VAR_12 }, window_function = den_save_window_7 ); 
   } /* end of rule : CTM.R.2 */
   
   //CTM.R.3 is not necessary to check
   rCTM_W_4 @= { @ "CTM.W.4 : Max. dimension (one side) of a CTM region <= " + CTM_W_4 + " um"; 
       contains( TCTM, { CTM_W_1, CTM_W_4 + GRID } );    /* 4um is min TCTM width */ 
       contains( DCTM, { CTM_W_2, CTM_W_4 + GRID } );    /* 0.4um is min DCTM width */ 
   } /* end of rule : CTM.W.4 */
   rCTM_A_1 @= { @ "CTM.A.1 : Min. area of CTM region >= " + CTM_A_1 + " um2"; 
       area( CTM5, < CTM_A_1 ); 
   } /* end of rule : CTM.A.1 */
   
   //CTM.R.1 is checked by MIM_M5.E.3
   rCTM_R_5 @= { @ "CTM.R.5 : The MIM capacitor must be placed between M6 amd M5";
       copy( CTM2 ); 
       copy( CTM3 ); 
       copy( CTM4 ); 
   } /* end of rule : CTM.R.5 */
   rCTM_R_6 @= { @ "CTM.R.6 : Two Mn connect to CTM without same connection is not allowed";
       interacting( CTM5M, VIACM, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
   } /* end of rule : CTM.R.6 */
   
   // MIM_M5 CHECK
   //==============
   rMIM_M5_W_1 @= { @ "MIM_M5.W.1 : Max. dimension (both width and length) of M5 as MIM capacitor bottom metal <= " + MIM_M5_W_1 + " um"; 
       size( size( BPM5, - ( MIM_M5_W_1 / 2 ), clip_acute = NONE ), MIM_M5_W_1 / 2, clip_acute = NONE ); 
   } /* end of rule : MIM_M5.W.1 */
   rMIM_M5_S_1 @= { @ "MIM_M5.S.1 : Min. space between two M5 regions as MIM capacitor bottom metal >= " + MIM_M5_S_1 + " um"; 
       external1( BPM5C, < MIM_M5_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
   } /* end of rule : MIM_M5.S.1 */
   rMIM_M5_S_2 @= { @ "MIM_M5.S.2 : Min. space between one M5 region as a dummy MIM capacitor bottom metal and "
                                   "the other M5 region as MIM capacitor bottom metal >= " + MIM_M5_S_2 + " um"; 
       external2( BPM5C, DPM5, < MIM_M5_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
   } /* end of rule : MIM_M5.S.2 */
   rMIM_M5_E_3 @= { @ "MIM_M5.E.3 : Minimum extension of an M5 resgion as MIM capacitor bottom metal beyound "
                                   "a CTM resgion and dummy CTM region >= " + MIM_M5_E_3 + " um"; 
       enclose( CTM5, M5, < MIM_M5_E_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       CTM5 not M5; 
   } /* end of rule : MIM_M5.E.3 */
   rMIMVIA_S_1 @= { @ "MIMVIA.S.1 : Min. space between two VIA5 on the same CTM >= " + MIMVIA_S_1 + " um"; 
       external1( CTMV5, < MIMVIA_S_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : MIMVIA.S.1 */
   rMIMVIA_S_2 @= { @ "MIMVIA.S.2 : Min. space between two VIA5 on the same M5 as MIM capacitor bottom metal >= " + MIMVIA_S_2 + " um"; 
       external1( CBMV5, < MIMVIA_S_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : MIMVIA.S.2 */
   rMIMVIA_E_1 @= { @ "MIMVIA.E.1 : Min. extension of a CTM region beyond a VIA5 region >= " + MIMVIA_E_1 + " um"; 
       enclose( VIA5, CTM5, < MIMVIA_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       cutting( VIA5, CTM5 ); 
   } /* end of rule : MIMVIA.E.1 */
   rMIMVIA_E_2 @= { @ "MIMVIA.E.2 : Min. extension of an M5 region as MIM capacitor bottom metal beyond a VIA4 or a VIA5 region >= " + MIMVIA_E_2 + " um"; 
       enclose( VIA4, BPM5C, < MIMVIA_E_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
       enclose( VIA5, BPM5C, < MIMVIA_E_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
   } /* end of rule : MIMVIA.E.2 */
   rMIMVIA_C_1 @= { @ "MIMVIA.C.1 : Min. clearance of a VIA4 or a VIA5 to a CTM region >= " + MIMVIA_C_1 + " um"; 
       external2( VIA4, CTM5, < MIMVIA_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       external2( VIA5, CTM5, < MIMVIA_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : MIMVIA.C.1 */
   rMIMVIA_R_1 @= { @ "MIMVIA.R.1 : Min. density of VIA5 on CTM >= 1%";
       net_area_ratio( CONNECT_DB, < 0.01, { "layer1" => CTMV5, "layer2" => TCTM }, 2, 2, {  }, NAR_SAVE_NET_6, true ); 
   } /* end of rule : MIMVIA.R.1 */
   rMIMVIA_R_3 @= { @ "MIMVIA.R.3 : VIA4 under CTM region is not allowed";
       VIA4 and CTM5; 
   } /* end of rule : MIMVIA.R.3 */
   
   //================SBD rules Check================================
   gLAYER_511 = PPOD and PWEL; 
   gLAYER_510 = gLAYER_511 and RFDUMMY; 
   gLAYER_509 = gLAYER_510 not DNW; 
   gLAYER_508 = donut_holes( gLAYER_509, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY );
   PPOD_SBD_H = enclosing( gLAYER_508, SBDOD ); 
   rSBD_W_1_SBD_W_1_1 @= { @ "SBD.W.1_SBD.W.1.1 : Minimum width of an OD region to define the width of the "
                                                 "P+ active OD region of the SBD. >=1.0um <= 16.0um";
       length_edge( PPOD_SBD_W, ( 0, 1 ) ); 
       length_edge( PPOD_SBD_W, ( 16, 999 ), CONNECT ); 
   } /* end of rule : SBD.W.1_SBD.W.1.1 */
   rSBD_W_2_SBD_W_2_1 @= { @ "SBD.W.2_SBD.W.2.1 : Minimum length of an OD region to define the length of the "
                                                 "P+ active OD region of the SBD. >=1.0um <=4.0um";
       length_edge( PPOD_SBD_L, ( 0, 1 ) ); 
       length_edge( PPOD_SBD_L, ( 4, 999 ), CONNECT ); 
   } /* end of rule : SBD.W.2_SBD.W.2.1 */
   rSBD_W_3 @= { @ "SBD.W.3 : Minimum and Maximum length of an OD region to define "
                             "the length of the NP OD region of the SBD.==0.42um";
       not_rectangles( NPOD_SBD ); 
       internal1( NPOD_SBD, < 0.42, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
       size( size( NPOD_SBD, - ( 0.42 / 2 ), clip_acute = NONE ), 0.42 / 2, clip_acute = NONE ); 
   } /* end of rule : SBD.W.3 */
   rSBD_W_4 @= { @ "SBD.W.4 : The width of NP OD region of the SBD must be equal to P+ "
                             "active OD region of the SBD.";
       NPOD_SBD_W not_coincident_outside_edge PPOD_SBD_G; 
       PPOD_SBD_W not_coincident_outside_edge NPOD_SBD_G; 
   } /* end of rule : SBD.W.4 */
   rSBD_S_1 @= { @ "SBD.S.1 : Space between P+ active OD region and NP OD region of the SBD ==0.48um";
       external2( PPOD_SBD, NPOD_SBD, < 0.48, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       interacting( PPOD_SBD, NPOD ); 
       not_outside_touching( PPOD_SBD, PPOD_SBD_G, == 2 ); 
       A = outside_touching( PPOD_SBD, PPOD_SBD_G, == 2 ); 
       B = A outside_touching_edge PPOD_SBD_G; 
       C = vertex( B, angles = { 90 }, shape = TRIANGLE, shape_size = 0.48 ); 
       interacting( PPOD_SBD, C ); 
   } /* end of rule : SBD.S.1 */
   rSBD_E_1 @= { @ "SBD.E.1 : Minimum and maximum extension from NW edge to an OD "
                             "region used for the SBD. ==0.80um";
       X = PPOD_SBD or NPOD_SBD; 
       Y = size( X, clip_acute = NONE, distance = 0.8 ); 
       Y xor NW_SBD; 
   } /* end of rule : SBD.E.1 */
   rSBD_E_2 @= { @ "SBD.E.2 : Minimum and maximum extension of a PP region beyond "
                             "an enclosed P+ active OD region of the SBD.==0.22um";
       X = size( PPOD_SBD, clip_acute = NONE, distance = 0.22 ); 
       X xor PP_SBD_ALL; 
   } /* end of rule : SBD.E.2 */
   rSBD_O_1 @= { @ "SBD.O.1 : Minimum and maximum overlap from a PP edge to a P+ "
                             "active OD region of the SBD.==0.22um";
       X = size( PPOD_SBD, clip_acute = NONE, distance = - 0.22 ); 
       X xor PP_SBD_HOLE; 
   } /* end of rule : SBD.O.1 */
   rSBD_E_1_1 @= { @ "SBD.E.1.1 : Minimum extension of DNW beyond NW for a better noise isolation.>=0.60um";
       enclose( NW_SBD, DNW_SBD, < 0.6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       cutting( NW_SBD, DNW_SBD ); 
   } /* end of rule : SBD.E.1.1 */
   rSBD_E_3 @= { @ "SBD.E.3 : Maximum and Minimum extension of SBDDMY beyond NW==0.00um";
       SBDDMY xor NW_SBD; 
   } /* end of rule : SBD.E.3 */
   
   //SBD.R.1 is checked by SBD.S.1 
   rSBD_R_2 @= { @ "SBD.R.2 : Maximum Finger Number of the P+ active OD region of the SBD should be <=16um";
       X = interacting( SBDDMY, PPOD_SBD, < 17 ); 
       Y = SBDDMY not X; 
       interacting( PPOD_SBD, Y ); 
   } /* end of rule : SBD.R.2 */
   rSBD_R_3 @= { @ "SBD.R.3 : The each NW of SBD should be surrounded by the P+ Guard Ring (P+ pickup ring).";
       NW_SBD not PPOD_SBD_H; 
       interacting( PPOD_SBD_H, SBDOD_ALL, > 1 ); 
       interacting( PPOD_SBD_H, NW_SBD, > 1 ); 
   } /* end of rule : SBD.R.3 */
   rSBD_R_4 @= { @ "SBD.R.4 : Use RFDUMMY to fully cover SBD and P+ Guard Ring for LVS to recognize RF Device.";
       SBDDMY not RFDUMMY;                /* for P+ guard Ring part is checked by SBD.R.3 */ 
       NW_SBD not RFDUMMY; 
   } /* end of rule : SBD.R.4 */
   rSBD_R_5 @= { @ "SBD.R.5 : PP for SBD must be a rectangle ring. PP rectangle ring must surround OD. Other shape is not allowed.";
       not_rectangles( PP_SBD_HOLE ); 
       not_rectangles( PP_SBD_ALL ); 
   } /* end of rule : SBD.R.5 */
   
   //SBD.R.7R don't need check. 
#endif /* end of #ifdef MIX_MODE  */ 
#ifdef FULL_CHIP 
   gLAYER_515 = RWDMY or FWI; 
   gLAYER_514 = gLAYER_515 or LMARK; 
   gLAYER_513 = gLAYER_514 or LOGO; 
   gLAYER_512 = gLAYER_513 or INDDMY; 
   OD_DEN_EXC = gLAYER_512 or EMPTY_AREA;    /* exclude check */ 
#else /* the reverse of #ifdef FULL_CHIP  */ 
   gLAYER_518 = RWDMY or FWI; 
   gLAYER_517 = gLAYER_518 or LMARK; 
   gLAYER_516 = gLAYER_517 or LOGO; 
   OD_DEN_EXC = gLAYER_516 or INDDMY;     /* exclude check */ 
#endif /* end of #ifdef FULL_CHIP  */ 
#ifdef DENSITY_IN_BLOCKAGE 
   OD_EXC = copy( OD_DEN_EXC ); 
#else /* the reverse of #ifdef DENSITY_IN_BLOCKAGE  */ 
   OD_EXC = OD_DEN_EXC or ODBLK; 
#endif /* end of #ifdef DENSITY_IN_BLOCKAGE  */ 
rDOD_W_1 @= { @ "DOD.W.1 : Minimum width >= " + DOD_W_1 + " um"; 
    internal1( DOD, < DOD_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : DOD.W.1 */
rDOD_S_1 @= { @ "DOD.S.1 : Minimum space between two DOD >= " + DOD_S_1 + " um"; 
    external1( DOD, < DOD_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : DOD.S.1 */
rDOD_C_1 @= { @ "DOD.C.1 : Minimum clearance from DOD to OD (overlap is not allowed) >= " + DOD_C_1 + " um"; 
    external2( DOD, ODI, < DOD_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DOD and ODI; 
} /* end of rule : DOD.C.1 */
rDOD_C_2 @= { @ "DOD.C.2 : Minimum clearance from DOD to PO (overlap is not allowed) >= " + DOD_C_2 + " um"; 
    external2( DOD, POLYI, < DOD_C_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DOD and POLYI; 
} /* end of rule : DOD.C.2 */
rDOD_C_4 @= { @ "DOD.C.4 : Minimum clearance from DOD to NW (cut is not allowed) >= " + DOD_C_4 + " um"; 
    external2( DOD, NWELI, < DOD_C_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    cutting( DOD, NWELI ); 
} /* end of rule : DOD.C.4 */
rDOD_C_5 @= { @ "DOD.C.5 : Minimum clearance from DOD to FW (overlap is not allowed) >= " + DOD_C_5 + " um"; 
    external2( DOD, FWI, < DOD_C_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DOD and FWI; 
} /* end of rule : DOD.C.5 */
rDOD_C_6 @= { @ "DOD.C.6 : Minimum clearance from DOD to LMARK (overlap is not allowed) >= " + DOD_C_6 + " um"; 
    external2( DOD, LMARK, < DOD_C_6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DOD and LMARK; 
} /* end of rule : DOD.C.6 */
rDOD_C_7 @= { @ "DOD.C.7 : Minimum clearance from DOD to RWDMY (overlap is not allowed) >= " + DOD_C_7 + " um"; 
    external2( DOD, RWDMY, < DOD_C_7, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DOD and RWDMY; 
} /* end of rule : DOD.C.7 */
rDOD_C_8 @= { @ "DOD.C.8 : Minimum clearance from DOD to LOGO (overlap is not allowed) >= " + DOD_C_8 + " um"; 
    external2( DOD, LOGO, < DOD_C_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DOD and LOGO; 
} /* end of rule : DOD.C.8 */
rDOD_C_9 @= { @ "DOD.C.9 : Minimum clearance from DOD to INDDMY (overlap is not allowed) >= " + DOD_C_9 + " um"; 
    external2( DOD, INDDMY, < DOD_C_9, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DOD and INDDMY; 
} /* end of rule : DOD.C.9 */
rDOD_C_13 @= { @ "DOD.C.13 : Minimum clearance from DOD to DTi (overlap is not allowed) >= " + DOD_C_13 + " um"; 
    external2( DOD, DTI, < DOD_C_13, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DOD and DTI; 
} /* end of rule : DOD.C.13 */
rDOD_C_14 @= { @ "DOD.C.14 : Minimum clearance from DOD to BJTDUMMY (overlap is not allowed) >= " + DOD_C_14 + " um"; 
    external2( DOD, BJTDUMMY, < DOD_C_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DOD and BJTDUMMY; 
} /* end of rule : DOD.C.14 */
rDOD_C_15 @= { @ "DOD.C.15 : Minimum clearance from DOD to FLASH (overlap is not allowed) >= " + DOD_C_15 + " um"; 
    external2( DOD, FLASH, < DOD_C_15, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DOD and FLASH; 
} /* end of rule : DOD.C.15 */
rDOD_E_1 @= { @ "DOD.E.1 : Minimum extension of NW beyond DOD >= " + DOD_E_1; 
    enclose( DOD, NWELI, < DOD_E_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
} /* end of rule : DOD.E.1 */
#ifdef FULL_CHIP 
   rDOD_E_2 @= { @ "DOD.E.2 : Minimum extension of chip edge beyond DOD >= " + DOD_E_2; 
       sLAYER_416 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DOD_E_2 ); 
       DOD not sLAYER_416; 
   } /* end of rule : DOD.E.2 */
   ODX = ALL_OD not EMPTY_AREA; 
   CHIP_NOT_OD_EXC = copy( CHIP_CHAMFERED ); 
#else /* the reverse of #ifdef FULL_CHIP  */ 
   ODX = copy( ALL_OD ); 
   CHIP_NOT_OD_EXC = copy( gCHIP ); 
#endif /* end of #ifdef FULL_CHIP  */ 
CHIPU_OD25 = size( gCHIP, clip_acute = NONE, distance = 25 ); 
CHIPU_OD50 = size( gCHIP, clip_acute = NONE, distance = 50 ); 
CHIPU_OD75 = size( gCHIP, clip_acute = NONE, distance = 75 ); 
CHIPU_OD100 = size( gCHIP, clip_acute = NONE, distance = 100 ); 
CHIPU_OD125 = size( gCHIP, clip_acute = NONE, distance = 125 ); 
CHIPU_OD150 = size( gCHIP, clip_acute = NONE, distance = 150 ); 
CHIPU_OD175 = size( gCHIP, clip_acute = NONE, distance = 175 ); 
CHIPU_OD200 = size( gCHIP, clip_acute = NONE, distance = 200 ); 
CHIPU_OD225 = size( gCHIP, clip_acute = NONE, distance = 225 ); 
rOD_R_1 @= { @ "OD.R.1 : {OD or DOD} local density (minimum) over window " + OD_R_W + " um x " + OD_R_W + " um stepping OD_R_Sum >= " + OD_R_1; 
    sLAYER_472 = chip_extent();
_den_con = < OD_R_1; 
_den_polygon_area_clip = true;
_den_print = false;
_den_print_only = false;
    D0 = density( window_layer = sLAYER_472, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
    D = rectangles( D0, sides = { == OD_R_W } ); 
    sLAYER_417 = D0 not D; 
    ERR1 = sLAYER_417 not OD_EXC; 
    F1 = area( ERR1, >= OD_R_A ); 
_den_con = < OD_R_1; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D1 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD25, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = < OD_R_1; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D2 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD50, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = < OD_R_1; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D3 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD75, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = < OD_R_1; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D4 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD100, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = < OD_R_1; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D5 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD125, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = < OD_R_1; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D6 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD150, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = < OD_R_1; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D7 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD175, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = < OD_R_1; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D8 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD200, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = < OD_R_1; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D9 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD225, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
    sLAYER_426 = D and D1; 
    sLAYER_425 = sLAYER_426 and D2; 
    sLAYER_424 = sLAYER_425 and D3; 
    sLAYER_423 = sLAYER_424 and D4; 
    sLAYER_422 = sLAYER_423 and D5; 
    sLAYER_421 = sLAYER_422 and D6; 
    sLAYER_420 = sLAYER_421 and D7; 
    sLAYER_419 = sLAYER_420 and D8; 
    sLAYER_418 = sLAYER_419 and D9; 
    ERR2 = interacting( D, sLAYER_418 ); 
    sLAYER_427 = ERR2 not OD_EXC; 
    F2 = area( sLAYER_427, >= OD_R_A ); 
    F = F1 or F2; 
    sLAYER_473 = chip_extent();
    VAR_13 = density_statistics_file( file = "OD_R_1.density" ); 
_den_con = < OD_R_1; 
_den_polygon_area_clip = true;
_den_print = true;
_den_print_only = false;
    density( window_layer = sLAYER_473, layer_hash = { "layer1" => F, "layer2" => ODX, "layer3" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, statistics_files = { VAR_13 }, window_function = den_save_window_17 ); 
} /* end of rule : OD.R.1 */
rOD_R_2 @= { @ "OD.R.2 : {OD or DOD} local density (maximum) over window " + OD_R_W + " um x " + OD_R_W + " um stepping OD_R_Sum <= " + OD_R_2; 
    sLAYER_474 = chip_extent();
_den_con = > OD_R_2; 
_den_polygon_area_clip = true;
_den_print = false;
_den_print_only = false;
    D0 = density( window_layer = sLAYER_474, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
    D = rectangles( D0, sides = { == OD_R_W } ); 
    sLAYER_428 = D0 not D; 
    ERR1 = sLAYER_428 not OD_EXC; 
    F1 = area( ERR1, >= OD_R_A ); 
_den_con = > OD_R_2; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D1 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD25, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = > OD_R_2; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D2 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD50, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = > OD_R_2; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D3 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD75, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = > OD_R_2; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D4 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD100, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = > OD_R_2; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D5 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD125, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = > OD_R_2; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D6 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD150, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = > OD_R_2; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D7 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD175, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = > OD_R_2; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D8 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD200, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
_den_con = > OD_R_2; 
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;
    D9 = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPU_OD225, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, window_function = den_save_window_16 ); 
    sLAYER_437 = D and D1; 
    sLAYER_436 = sLAYER_437 and D2; 
    sLAYER_435 = sLAYER_436 and D3; 
    sLAYER_434 = sLAYER_435 and D4; 
    sLAYER_433 = sLAYER_434 and D5; 
    sLAYER_432 = sLAYER_433 and D6; 
    sLAYER_431 = sLAYER_432 and D7; 
    sLAYER_430 = sLAYER_431 and D8; 
    sLAYER_429 = sLAYER_430 and D9; 
    ERR2 = interacting( D, sLAYER_429 ); 
    sLAYER_438 = ERR2 not OD_EXC; 
    F2 = area( sLAYER_438, >= OD_R_A ); 
    F = F1 or F2; 
    sLAYER_475 = chip_extent();
    VAR_14 = density_statistics_file( file = "OD_R_2.density" ); 
_den_con = > OD_R_2; 
_den_polygon_area_clip = true;
_den_print = true;
_den_print_only = false;
    density( window_layer = sLAYER_475, layer_hash = { "layer1" => F, "layer2" => ODX, "layer3" => CHIP_NOT_OD_EXC }, delta_window = { OD_R_W, OD_R_W }, delta_x = OD_R_S, delta_y = OD_R_S, boundary = ALIGN, statistics_files = { VAR_14 }, window_function = den_save_window_18 ); 
} /* end of rule : OD.R.2 */
#ifdef RECOMMEND 
   rDOD_DN_1 @= { @ "DOD.DN.1 : {OD OR DOD} local density (minimum) over window  " + DOD_DN_1_W + " um x " + DOD_DN_1_W + " stepping DOD_DN_1_S um >= " + DOD_DN_1; 
       sLAYER_476 = chip_extent();
       VAR_15 = density_statistics_file( file = "DOD_DN_1.density" ); 
   _den_con = < DOD_DN_1; 
   _den_polygon_area_clip = true;
   _den_print = true;
   _den_print_only = false;
       density( window_layer = sLAYER_476, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { DOD_DN_1_W, DOD_DN_1_W }, delta_x = DOD_DN_1_S, delta_y = DOD_DN_1_S, boundary = ALIGN, statistics_files = { VAR_15 }, window_function = den_save_window_16 ); 
   } /* end of rule : DOD.DN.1 */
   rDOD_DN_2 @= { @ "DOD.DN.2 : {OD OR DOD} local density (minimum) over window  " + DOD_DN_2_W + " um x " + DOD_DN_2_W + " stepping DOD_DN_2_S um >= " + DOD_DN_2; 
       sLAYER_477 = chip_extent();
       VAR_16 = density_statistics_file( file = "DOD_DN_2.density" ); 
   _den_con = > DOD_DN_2; 
   _den_polygon_area_clip = true;
   _den_print = true;
   _den_print_only = false;
       density( window_layer = sLAYER_477, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_OD_EXC }, delta_window = { DOD_DN_2_W, DOD_DN_2_W }, delta_x = DOD_DN_2_S, delta_y = DOD_DN_2_S, boundary = ALIGN, statistics_files = { VAR_16 }, window_function = den_save_window_16 ); 
   } /* end of rule : DOD.DN.2 */
#endif /* end of #ifdef RECOMMEND  */ 
#ifdef FULL_CHIP 
   rOD_R_3 @= { @ "OD.R.3 : Minimum {OD or DOD} density across full chip >= " + OD_R_3; 
       VAR_17 = density_statistics_file( file = "OD_R_3.density" ); 
   _den_con = < OD_R_3; 
   _den_polygon_area_clip = false;
   _den_print = true;
   _den_print_only = false;
       density( output_type = CLIPPED_DELTA_WINDOW, window_layer = gCHIP, layer_hash = { "layer1" => ODX }, statistics_files = { VAR_17 }, window_function = den_save_window_7 ); 
   } /* end of rule : OD.R.3 */
   rOD_R_4 @= { @ "OD.R.4 : Maximum {OD or DOD} density across full chip <= " + OD_R_4; 
       VAR_18 = density_statistics_file( file = "OD_R_4.density" ); 
   _den_con = > OD_R_4; 
   _den_polygon_area_clip = false;
   _den_print = true;
   _den_print_only = false;
       density( output_type = CLIPPED_DELTA_WINDOW, window_layer = gCHIP, layer_hash = { "layer1" => ODX }, statistics_files = { VAR_18 }, window_function = den_save_window_7 ); 
   } /* end of rule : OD.R.4 */
   rDOD_R_1 @= { @ "DOD.R.1 : DOD is required. "
                             "The DOD CAD layer (TSMC default, 3:1) must be a different layer from the OD CAD layer.";
       not_interacting( CHIP_CHAMFERED, DOD ); 
   } /* end of rule : DOD.R.1 */
   rDOD_R_2 @= { @ "DOD.R.2 : DOD inside chip corner stress relief area is not allowed.";
       interacting( DOD, EMPTY_AREA ); 
   } /* end of rule : DOD.R.2 */
#endif /* end of #ifdef FULL_CHIP  */ 
rDOD_R_3 @= { @ "DOD.R.3 : The only shapes allowed are square(or rectangular) and solid";
    donut_holes( DOD, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
    not_rectangles( DOD, orientation = ORTHOGONAL ); 
} /* end of rule : DOD.R.3 */
rDPO_W_1 @= { @ "DPO.W.1 : Minimum width >= " + DPO_W_1 + " um"; 
    internal1( DPO, < DPO_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
} /* end of rule : DPO.W.1 */
rDPO_S_1 @= { @ "DPO.S.1 : Minimum space between two DPO >= " + DPO_S_1 + " um"; 
    external1( DPO, < DPO_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
} /* end of rule : DPO.S.1 */
rDPO_C_1 @= { @ "DPO.C.1 : Minimum clearance from DPO to OD (overlap is not allowed) >= " + DPO_C_1 + " um"; 
    external2( DPO, ODI, < DPO_C_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DPO and ODI; 
} /* end of rule : DPO.C.1 */
rDPO_C_2 @= { @ "DPO.C.2 : Minimum clearance from DPO to PO (overlap is not allowed) >= " + DPO_C_2 + " um"; 
    external2( DPO, POLYI, < DPO_C_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DPO and POLYI; 
} /* end of rule : DPO.C.2 */
rDPO_C_4 @= { @ "DPO.C.4 : Minimum clearance from DPO to FW (overlap is not allowed) >= " + DPO_C_4 + " um"; 
    external2( DPO, FWI, < DPO_C_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DPO and FWI; 
} /* end of rule : DPO.C.4 */
rDPO_C_5 @= { @ "DPO.C.5 : Minimum clearance from DPO to LMARK (overlap is not allowed) >= " + DPO_C_5 + " um"; 
    external2( DPO, LMARK, < DPO_C_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DPO and LMARK; 
} /* end of rule : DPO.C.5 */
rDPO_C_6 @= { @ "DPO.C.6 : Minimum clearance from DPO to LOGO (overlap is not allowed) >= " + DPO_C_6 + " um"; 
    external2( DPO, LOGO, < DPO_C_6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DPO and LOGO; 
} /* end of rule : DPO.C.6 */
rDPO_C_7 @= { @ "DPO.C.7 : Minimum clearance from DPO to INDDMY (overlap is not allowed) >= " + DPO_C_7 + " um"; 
    external2( DPO, INDDMY, < DPO_C_7, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DPO and INDDMY; 
} /* end of rule : DPO.C.7 */
rDPO_C_9 @= { @ "DPO.C.9 : Minimum clearance from DPO to DOD (overlap is not allowed) >= " + DPO_C_9 + " um"; 
    external2( DPO, DOD, < DPO_C_9, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DPO and DOD; 
} /* end of rule : DPO.C.9 */
rDPO_C_12 @= { @ "DPO.C.12 : Minimum clearance from DPO to BJTDMY (overlap is not allowed) >= " + DPO_C_12 + " um"; 
    external2( DPO, BJTDUMMY, < DPO_C_12, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DPO and BJTDUMMY; 
} /* end of rule : DPO.C.12 */
rDPO_C_13 @= { @ "DPO.C.13 : Minimum clearance from DPO to DTi (overlap is not allowed) >= " + DPO_C_13 + " um"; 
    external2( DPO, DTI, < DPO_C_13, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DPO and DTI; 
} /* end of rule : DPO.C.13 */
rDPO_C_14 @= { @ "DPO.C.14 : Minimum clearance from DPO to FLASH (overlap is not allowed) >= " + DPO_C_14 + " um"; 
    external2( DPO, FLASH, < DPO_C_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
    DPO and FLASH; 
} /* end of rule : DPO.C.14 */
#ifdef FULL_CHIP 
   rDPO_E_1 @= { @ "DPO.E.1 : Minimum extension of chip edge beyond DPO >= " + DPO_E_1; 
       sLAYER_439 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DPO_E_1 ); 
       DPO not sLAYER_439; 
   } /* end of rule : DPO.E.1 */
#endif /* end of #ifdef FULL_CHIP  */ 
rDPO_A_1 @= { @ "DPO.A.1 : Minimum area of DPO >= " + DPO_A_1; 
    area( DPO, < DPO_A_1 ); 
} /* end of rule : DPO.A.1 */
#ifdef FULL_CHIP 
   rPO_R_5 @= { @ "PO.R.5 : Minimum {PO OR DPO} density across full chip >= " + PO_R_5; 
       VAR_19 = density_statistics_file( file = "PO_DN_5.density" ); 
   _den_con = < PO_R_5; 
   _den_polygon_area_clip = false;
   _den_print = true;
   _den_print_only = false;
       density( output_type = CLIPPED_DELTA_WINDOW, window_layer = gCHIP, layer_hash = { "layer1" => ALL_PO }, statistics_files = { VAR_19 }, window_function = den_save_window_7 ); 
   } /* end of rule : PO.R.5 */
   #ifdef RECOMMEND 
      rDPO_R_1 @= { @ "DPO.R.1 : DPO is required. "
                                "The DPO CAD layer (TSMC default, 13:1) must be a different layer from the PO CAD layer.";
          not_interacting( CHIP_CHAMFERED, DPO ); 
      } /* end of rule : DPO.R.1 */
   #endif /* end of #ifdef RECOMMEND  */ 
   rDPO_R_2 @= { @ "DPO.R.2 : DPO inside chip corner stress relief area is not allowed.";
       interacting( DPO, EMPTY_AREA ); 
   } /* end of rule : DPO.R.2 */
#endif /* end of #ifdef FULL_CHIP  */ 
rDPO_R_3 @= { @ "DPO.R.3 : The only shapes allowed are square (or rectangular) and solid";
    donut_holes( DPO, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
    not_rectangles( DPO, orientation = ORTHOGONAL ); 
} /* end of rule : DPO.R.3 */

// Matching check
//================
gLAYER_519 = interacting( POLY, OD ); 
POLY_PAIR_CHECK = interacting( gLAYER_519, MATCHING ); 
POLY_PAIR_CHECK_G_M1 = POLY_PAIR_CHECK inside M1XD; 
POLY_PAIR_CHECK_B_M1 = cutting( POLY_PAIR_CHECK, M1XD ); 
POLY_PAIR_CHECK_O_M1 = POLY_PAIR_CHECK outside M1XD; 
POLY_PAIR_CHECK_G_M2 = POLY_PAIR_CHECK inside M2XD; 
POLY_PAIR_CHECK_B_M2 = cutting( POLY_PAIR_CHECK, M2XD ); 
POLY_PAIR_CHECK_O_M2 = POLY_PAIR_CHECK outside M2XD; 
POLY_PAIR_CHECK_G_M3 = POLY_PAIR_CHECK inside M3XD; 
POLY_PAIR_CHECK_B_M3 = cutting( POLY_PAIR_CHECK, M3XD ); 
POLY_PAIR_CHECK_O_M3 = POLY_PAIR_CHECK outside M3XD; 
POLY_PAIR_CHECK_G_M4 = POLY_PAIR_CHECK inside M4XD; 
POLY_PAIR_CHECK_B_M4 = cutting( POLY_PAIR_CHECK, M4XD ); 
POLY_PAIR_CHECK_O_M4 = POLY_PAIR_CHECK outside M4XD; 
POLY_PAIR_CHECK_G_M5 = POLY_PAIR_CHECK inside M5XD; 
POLY_PAIR_CHECK_B_M5 = cutting( POLY_PAIR_CHECK, M5XD ); 
POLY_PAIR_CHECK_O_M5 = POLY_PAIR_CHECK outside M5XD; 
POLY_PAIR_CHECK_G_M6 = POLY_PAIR_CHECK inside M6XD; 
POLY_PAIR_CHECK_B_M6 = cutting( POLY_PAIR_CHECK, M6XD ); 
POLY_PAIR_CHECK_O_M6 = POLY_PAIR_CHECK outside M6XD; 
POLY_PAIR_CHECK_G_MD = POLY_PAIR_CHECK inside MDXD; 
POLY_PAIR_CHECK_B_MD = cutting( POLY_PAIR_CHECK, MDXD ); 
POLY_PAIR_CHECK_O_MD = POLY_PAIR_CHECK outside MDXD; 
rAN_R_40M_M1 @= { @ "AN.R.40m_M1 : For the critical differential pair inside MATCHING layer, asymmetry metal (M1) shielding is not allowed. "
                                  "DRC only flag: (1) One of differential pair covered by metal layer but without fully covered. "
                                  "(2) One device of the differential pair fully covered by metal layer and the other is not fully covered.";
    interacting( MATCHING, POLY_PAIR_CHECK_B_M1 ); 
    sLAYER_440 = interacting( MATCHING, POLY_PAIR_CHECK_G_M1 ); 
    interacting( sLAYER_440, POLY_PAIR_CHECK_O_M1 ); 
} /* end of rule : AN.R.40m_M1 */
#ifdef RECOMMEND 
   rAN_R_41M_M2 @= { @ "AN.R.41m_M2 : For the critical differential pair inside MATCHING layer, asymmetry metal (M2) shielding is not recommended. "
                                     "DRC only flag: (1) One of differential pair covered by metal layer but without fully covered. "
                                     "(2) One device of the differential pair fully covered by metal layer and the other is not fully covered.";
       interacting( MATCHING, POLY_PAIR_CHECK_B_M2 ); 
       sLAYER_441 = interacting( MATCHING, POLY_PAIR_CHECK_G_M2 ); 
       interacting( sLAYER_441, POLY_PAIR_CHECK_O_M2 ); 
   } /* end of rule : AN.R.41m_M2 */
   rAN_R_41M_M3 @= { @ "AN.R.41m_M3 : For the critical differential pair inside MATCHING layer, asymmetry metal (M3) shielding is not recommended. "
                                     "DRC only flag: (1) One of differential pair covered by metal layer but without fully covered. "
                                     "(2) One device of the differential pair fully covered by metal layer and the other is not fully covered.";
       interacting( MATCHING, POLY_PAIR_CHECK_B_M3 ); 
       sLAYER_442 = interacting( MATCHING, POLY_PAIR_CHECK_G_M3 ); 
       interacting( sLAYER_442, POLY_PAIR_CHECK_O_M3 ); 
   } /* end of rule : AN.R.41m_M3 */
   rAN_R_41M_M4 @= { @ "AN.R.41m_M4 : For the critical differential pair inside MATCHING layer, asymmetry metal (M4) shielding is not recommended. "
                                     "DRC only flag: (1) One of differential pair covered by metal layer but without fully covered. "
                                     "(2) One device of the differential pair fully covered by metal layer and the other is not fully covered.";
       interacting( MATCHING, POLY_PAIR_CHECK_B_M4 ); 
       sLAYER_443 = interacting( MATCHING, POLY_PAIR_CHECK_G_M4 ); 
       interacting( sLAYER_443, POLY_PAIR_CHECK_O_M4 ); 
   } /* end of rule : AN.R.41m_M4 */
   rAN_R_41M_M5 @= { @ "AN.R.41m_M5 : For the critical differential pair inside MATCHING layer, asymmetry metal (M5) shielding is not recommended. "
                                     "DRC only flag: (1) One of differential pair covered by metal layer but without fully covered. "
                                     "(2) One device of the differential pair fully covered by metal layer and the other is not fully covered.";
       interacting( MATCHING, POLY_PAIR_CHECK_B_M5 ); 
       sLAYER_444 = interacting( MATCHING, POLY_PAIR_CHECK_G_M5 ); 
       interacting( sLAYER_444, POLY_PAIR_CHECK_O_M5 ); 
   } /* end of rule : AN.R.41m_M5 */
   rAN_R_41M_M6 @= { @ "AN.R.41m_M6 : For the critical differential pair inside MATCHING layer, asymmetry metal (M6) shielding is not recommended. "
                                     "DRC only flag: (1) One of differential pair covered by metal layer but without fully covered. "
                                     "(2) One device of the differential pair fully covered by metal layer and the other is not fully covered.";
       interacting( MATCHING, POLY_PAIR_CHECK_B_M6 ); 
       sLAYER_445 = interacting( MATCHING, POLY_PAIR_CHECK_G_M6 ); 
       interacting( sLAYER_445, POLY_PAIR_CHECK_O_M6 ); 
   } /* end of rule : AN.R.41m_M6 */
   #ifdef CHECK_ALRDL 
      rAN_R_41M_MD @= { @ "AN.R.41m_MD : For the critical differential pair inside MATCHING layer, asymmetry metal (MD) shielding is not recommended. "
                                        "DRC only flag: (1) One of differential pair covered by metal layer but without fully covered. "
                                        "(2) One device of the differential pair fully covered by metal layer and the other is not fully covered.";
          interacting( MATCHING, POLY_PAIR_CHECK_B_MD ); 
          sLAYER_446 = interacting( MATCHING, POLY_PAIR_CHECK_G_MD ); 
          interacting( sLAYER_446, POLY_PAIR_CHECK_O_MD ); 
      } /* end of rule : AN.R.41m_MD */
   #endif /* end of #ifdef CHECK_ALRDL  */ 
#endif /* end of #ifdef RECOMMEND  */ 
rFPAD_R_1 @= { @ "FPAD.R.1 : Floating PAD is not allowed . please add protection diode to ground . "
                            "Floating PAD in the DRC : {Mn INTERACT CB} don't connect OD or POLY";
    A = interacting( M6, CB ); 
    A1 = stamp( A, M6XD, CONNECT_DB, CONNECT_DB_FPAD_R_1, include_touch = NONE ); 
    B1 = net_select( CONNECT_DB_FPAD_R_1, connected_to_any = { NTAPI }, output_from_layers = { A1 } ); 
    B2 = net_select( CONNECT_DB_FPAD_R_1, connected_to_any = { PTAPI }, output_from_layers = { A1 } ); 
    B3 = net_select( CONNECT_DB_FPAD_R_1, connected_to_any = { NSDI }, output_from_layers = { A1 } ); 
    B4 = net_select( CONNECT_DB_FPAD_R_1, connected_to_any = { PSDI }, output_from_layers = { A1 } ); 
    B5 = net_select( CONNECT_DB_FPAD_R_1, connected_to_any = { ILP1I }, output_from_layers = { A1 } ); 
    sLAYER_450 = B1 or B2; 
    sLAYER_449 = sLAYER_450 or B3; 
    sLAYER_448 = sLAYER_449 or B4; 
    sLAYER_447 = sLAYER_448 or B5; 
    A not sLAYER_447; 
} /* end of rule : FPAD.R.1 */

//3D MIM CHECK
//============
CMM2 = CMM2I not EXCL_S; 
CMM3 = CMM3I not EXCL_S; 
CMM4 = CMM4I not EXCL_S; 
#ifdef MIX_MODE 
   #ifndef C016 
      #ifndef C0152 
         CTMVIA = CTM5 and VIA5; 
         gLAYER_520 = CMM5 and VIA5; 
         CMMVIA = gLAYER_520 not CTMVIA; 
         TCMM = interacting( CMM5, CMMVIA );    /* True CMM */ 
         gLAYER_522 = BPM5_3D and VIA5; 
         gLAYER_521 = gLAYER_522 not CTMVIA; 
         CBMVIA = gLAYER_521 not CMMVIA; 
         DCMM = not_interacting( CMM5, CMMVIA );    /* Dummy CMM */ 
         gLAYER_523 = interacting( M5, DCMM ); 
         DPM5_3D = not_interacting( gLAYER_523, VIA5 );    /* M5 as a dummy CBM */ 
         BPM5C_3D = BPM5_3D coincident_edge M5; 
         r3DMIM_A_2 @= { @ "3DMIM.A.2 : Min. area of CMM or dummy CMM >= " + _3DMIM_A_2; 
             area( CMM5, < _3DMIM_A_2 ); 
         } /* end of rule : 3DMIM.A.2 */
         r3DMIM_DN_1 @= { @ "3DMIM.DN.1 : Min. density of all CMM or dummy CMM area >= 3%";
             sLAYER_478 = chip_extent();
             VAR_20 = density_statistics_file( file = "CMM5i.density" ); 
         _den_con = ( 0, 0.03 );
         _den_polygon_area_clip = true;
         _den_print = true;
         _den_print_only = false;
             density( window_layer = sLAYER_478, layer_hash = { "layer1" => CMM5I }, statistics_files = { VAR_20 }, window_function = den_save_window_7 ); 
         } /* end of rule : 3DMIM.DN.1 */
         r3DMIM_EX_1 @= { @ "3DMIM.EX.1 : Minimum and maximum extension of CMM or dummy CMM beyond CTM or dummy CTM == " + _3DMIM_EX_1; 
             A = interacting( CMM5, CTM5 ); 
             sLAYER_479 = length_edge( A, > 0 ); 
             sLAYER_480 = extend_edge( sLAYER_479, start = - 0.4, end = - 0.4 );
             B = edge_size( sLAYER_480, inside = _3DMIM_EX_1 ); 
             sLAYER_451 = not_interacting( B, VIA5 ); 
             not_outside_touching( sLAYER_451, CTM5 ); 
         } /* end of rule : 3DMIM.EX.1 */
         r3DMIM_EX_2 @= { @ "3DMIM.EX.2 : Minimum and maximum extension of CMM beyond CMMVIA (at least one side) (except 2DMIM) == " + _3DMIM_EX_2; 
             PRE = interacting( CMM5, CTM5 ); 
             D = interacting( CMMVIA, PRE ); 
             enclose_error( D, TCMM, < _3DMIM_EX_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
             A = size( D, clip_acute = NONE, distance = _3DMIM_EX_2 ); 
             B = A touching_edge TCMM; 
             sLAYER_452 = A touching B; 
             not_interacting( D, sLAYER_452 ); 
         } /* end of rule : 3DMIM.EX.2 */
         r3DMIM_EX_3 @= { @ "3DMIM.EX.3 : Min. extension of Mx region beyond CMM or dummy CMM >= " + _3DMIM_EX_3; 
             enclose( CMM5, BPM5_3D, < _3DMIM_EX_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
         } /* end of rule : 3DMIM.EX.3 */
         r3DMIM_EX_4 @= { @ "3DMIM.EX.4 : Min. extension of CMM beyond CMMVIA (for 2DMIM)>= " + _3DMIM_EX_4; 
             PRE = not_interacting( CMM5, CTM5 ); 
             A = interacting( CMMVIA, PRE ); 
             enclose( A, TCMM, < _3DMIM_EX_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
         } /* end of rule : 3DMIM.EX.4 */
         r3DMIM_S_1 @= { @ "3DMIM.S.1 : Minimum and maximum space of CMMVIA TO CTM == " + _3DMIM_S_1; 
             external2_error( TCTM, CMMVIA, < _3DMIM_S_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT ); 
             sLAYER_453 = interacting( TCMM, TCTM ); 
             A = interacting( CMMVIA, sLAYER_453 ); 
             B = edge_size( TCTM, outside = _3DMIM_S_1 ); 
             not_outside_touching( A, B ); 
         } /* end of rule : 3DMIM.S.1 */
         r3DMIM_S_2 @= { @ "3DMIM.S.2 : Min. CTMVIA space >= " + _3DMIM_S_2; 
             external1( CTMVIA, < _3DMIM_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : 3DMIM.S.2 */
         r3DMIM_S_3 @= { @ "3DMIM.S.3 : Min. CMMVIA space >= " + _3DMIM_S_3; 
             external1( CMMVIA, < _3DMIM_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : 3DMIM.S.3 */
         r3DMIM_S_4 @= { @ "3DMIM.S.4 : Min. CMM space >= " + _3DMIM_S_4; 
             external1( TCMM, < _3DMIM_S_4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : 3DMIM.S.4 */
         r3DMIM_S_5 @= { @ "3DMIM.S.5 : Min. space of CMM TO dummy CMM >= " + _3DMIM_S_5; 
             external2( TCMM, DCMM, < _3DMIM_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
         } /* end of rule : 3DMIM.S.5 */
         r3DMIM_S_7 @= { @ "3DMIM.S.7 : Min. space of CBMVIA TO CMM >= " + _3DMIM_S_7; 
             external2( CBMVIA, TCMM, < _3DMIM_S_7, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
         } /* end of rule : 3DMIM.S.7 */
         r3DMIM_W_1 @= { @ "3DMIM.W.1 : Min. width of CTM (At least one side so that would be 2 VIAs for process yield concern)>= " + _3DMIM_W_1; 
             not_contains( TCTM, { GRID, _3DMIM_W_1 }, FORTY_FIVE ); 
         } /* end of rule : 3DMIM.W.1 */
         r3DMIM_W_3 @= { @ "3DMIM.W.3 : Min. width of dummy CMM >= " + _3DMIM_W_3; 
             internal1( DCMM, < _3DMIM_W_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : 3DMIM.W.3 */
         r3DMIM_W_4 @= { @ "3DMIM.W.4 : Min. width of dummy CBM >= " + _3DMIM_W_4; 
             internal1( DPM5_3D, < _3DMIM_W_4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : 3DMIM.W.4 */
         r3DMIM_W_5 @= { @ "3DMIM.W.5 : Max. dimension (one side) of a CMM region <= " + _3DMIM_W_5; 
             contains( TCMM, { GRID, _3DMIM_W_5 + GRID } ); 
             contains( DCMM, { GRID, _3DMIM_W_5 + GRID } ); 
         } /* end of rule : 3DMIM.W.5 */
         r3DMIM_W_6 @= { @ "3DMIM.W.6 : Min. width of CMM >= " + _3DMIM_W_6; 
             internal1( TCMM, < _3DMIM_W_6, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : 3DMIM.W.6 */
         r3DMIM_R_10 @= { @ "3DMIM.R.10 : CTM and CBM termianls must be connected through Mtop";
             sLAYER_454 = interacting( BPM5_3D, CMM5 ); 
BPM5_CHECK=interacting(M5XD,sLAYER_454 );
CONNECT_DB_3DMIM_R_10=incremental_connect(CONNECT_DB,{{{BPM5_CHECK},M5XD}});
             VIA5_CHECK = VIA5I not CMMVIA; 
CONNECT_DB_3DMIM_R_10 = incremental_connect( CONNECT_DB_3DMIM_R_10, {{{ VIA5_CHECK }, VIA5I }} );
             interacting( BPM5_CHECK, VIA5_CHECK, > 1, connect_sequence = CONNECT_DB_3DMIM_R_10, count_by = NET ); 
         } /* end of rule : 3DMIM.R.10 */
         r3DMIM_S_8 @= { @ "3DMIM.S.8 : Min. space between two Mx regions as MIM capacitor bottom metal >= " + _3DMIM_S_8; 
             external1( BPM5C_3D, < _3DMIM_S_8, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
         } /* end of rule : 3DMIM.S.8 */
         r3DMIM_S_9 @= { @ "3DMIM.S.9 : Min. space between one Mx region as a dummy MIM capacitor bottom metal and "
                                       "the other Mx region as MIM capacitor bottom metal >= " + _3DMIM_S_9; 
             external2( BPM5C_3D, DPM5_3D, < _3DMIM_S_9, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
         } /* end of rule : 3DMIM.S.9 */
         r3DMIM_EX_5 @= { @ "3DMIM.EX.5 : Min. extension of an Mx region as MIM capacitor bottom metal beyond a VIA4 or a VIA5 region >= " + _3DMIM_EX_5; 
             enclose( VIA4, BPM5C_3D, < _3DMIM_EX_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
             enclose( VIA5, BPM5C_3D, < _3DMIM_EX_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
         } /* end of rule : 3DMIM.EX.5 */
         r3DMIM_S_10 @= { @ "3DMIM.S.10 : Min. space between two VIA5 on the same Mx as MIM capacitor bottom metal >= " + _3DMIM_S_10; 
             external1( CBMV5_3D, < _3DMIM_S_10, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : 3DMIM.S.10 */
         
         // 3DMIM.R.1 is checked by 3DMIM.S.1
         // 3DMIM.R.2 is not necessary  to check 
      #endif /* end of #ifndef C0152  */ 
   #endif /* end of #ifndef C016  */ 
#endif /* end of #ifdef MIX_MODE  */ 

// ANALOGDMY CHECKS
//=============
#ifndef C016 
   #ifndef C0152 
      rANALOGDMY_A_1 @= { @ "ANALOGDMY.A.1 : Min. area of ANALOGDMY >= " + ANALOGDMY_A_1; 
          area( ANALOGDMY, < ANALOGDMY_A_1 ); 
      } /* end of rule : ANALOGDMY.A.1 */
      rANALOGDMY_EX_1 @= { @ "ANALOGDMY.EX.1 : Min. extension of ANALOGDMY beyond OD >= " + ANALOGDMY_EX_1; 
          enclose( OD, ANALOGDMY, < ANALOGDMY_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : ANALOGDMY.EX.1 */
      rANALOGDMY_EX_2 @= { @ "ANALOGDMY.EX.2 : Min. extension of ANALOGDMY beyond GATE POLY >= " + ANALOGDMY_EX_2; 
          PRE = and_edge( POLY, OD, false ); 
          enclose_error( PRE, ANALOGDMY, < ANALOGDMY_EX_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
      } /* end of rule : ANALOGDMY.EX.2 */
      rANALOGDMY_R_1 @= { @ "ANALOGDMY.R.1 : GATE POLY cut ANALOGDMY is not allowed";
          cutting( ALL_GATE, ANALOGDMY ); 
      } /* end of rule : ANALOGDMY.R.1 */
      rANALOGDMY_S_1 @= { @ "ANALOGDMY.S.1 : Min. ANALOGDMY space >= " + ANALOGDMY_S_1; 
          external1( ANALOGDMY, < ANALOGDMY_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : ANALOGDMY.S.1 */
      rANALOGDMY_S_2 @= { @ "ANALOGDMY.S.2 : Min. space of ANALOGDMY TO active OD >= " + ANALOGDMY_S_2; 
          external2( ANALOGDMY, DACT, < ANALOGDMY_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : ANALOGDMY.S.2 */
      rANALOGDMY_S_3 @= { @ "ANALOGDMY.S.3 : Min. space of ANALOGDMY TO GATE POLY in the same OD >= " + ANALOGDMY_S_3; 
          A = interacting( OD, ANALOGDMY ); 
          B = interacting( ALL_GATE, A ); 
          external2( ANALOGDMY, B, < ANALOGDMY_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : ANALOGDMY.S.3 */
      rANALOGDMY_S_4 @= { @ "ANALOGDMY.S.4 : Min. space of ANALOGDMY TO PO >= " + ANALOGDMY_S_4; 
          external2( ANALOGDMY, POLY, < ANALOGDMY_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : ANALOGDMY.S.4 */
      rANALOGDMY_W_1 @= { @ "ANALOGDMY.W.1 : Min. ANALOGDMY width >= " + ANALOGDMY_W_1; 
          internal1( ANALOGDMY, < ANALOGDMY_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : ANALOGDMY.W.1 */
   #endif /* end of #ifndef C0152  */ 
#endif /* end of #ifndef C016  */ 
MOM_M1 = MOMDMY_1 and M1; 
MOM_M1_EDGE = M1 coincident_inside_edge MOM_M1; 
MOM_M1_LINE_END = adjacent_edge( MOM_M1_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
MOM_M1_SIDE_EDGE = MOM_M1_EDGE not_coincident_inside_edge MOM_M1_LINE_END; 
MOM_M1_CAP_EDGE = external1_edge( MOM_M1_SIDE_EDGE, < ( M1_W_1 + 2 * M1_S_1 ), extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
MOM_M1_CAP_EDGE_EXP = edge_size( MOM_M1_CAP_EDGE, inside = 0.001 ); 
MOM_M1_CAP_EDGE_EXP_C = stamp( MOM_M1_CAP_EDGE_EXP, CHIP_MOM, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
MOM_M2 = MOMDMY_2 and M2; 
MOM_M2_EDGE = M2 coincident_inside_edge MOM_M2; 
MOM_M2_LINE_END = adjacent_edge( MOM_M2_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
MOM_M2_SIDE_EDGE = MOM_M2_EDGE not_coincident_inside_edge MOM_M2_LINE_END; 
MOM_M2_CAP_EDGE = external1_edge( MOM_M2_SIDE_EDGE, < ( M2_W_1 + 2 * M2_S_1 ), extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
MOM_M2_CAP_EDGE_EXP = edge_size( MOM_M2_CAP_EDGE, inside = 0.001 ); 
MOM_M2_CAP_EDGE_EXP_C = stamp( MOM_M2_CAP_EDGE_EXP, CHIP_MOM, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
MOM_M3 = MOMDMY_3 and M3; 
MOM_M3_EDGE = M3 coincident_inside_edge MOM_M3; 
MOM_M3_LINE_END = adjacent_edge( MOM_M3_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
MOM_M3_SIDE_EDGE = MOM_M3_EDGE not_coincident_inside_edge MOM_M3_LINE_END; 
MOM_M3_CAP_EDGE = external1_edge( MOM_M3_SIDE_EDGE, < ( M3_W_1 + 2 * M3_S_1 ), extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
MOM_M3_CAP_EDGE_EXP = edge_size( MOM_M3_CAP_EDGE, inside = 0.001 ); 
MOM_M3_CAP_EDGE_EXP_C = stamp( MOM_M3_CAP_EDGE_EXP, CHIP_MOM, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
MOM_M4 = MOMDMY_4 and M4; 
MOM_M4_EDGE = M4 coincident_inside_edge MOM_M4; 
MOM_M4_LINE_END = adjacent_edge( MOM_M4_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
MOM_M4_SIDE_EDGE = MOM_M4_EDGE not_coincident_inside_edge MOM_M4_LINE_END; 
MOM_M4_CAP_EDGE = external1_edge( MOM_M4_SIDE_EDGE, < ( M4_W_1 + 2 * M4_S_1 ), extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
MOM_M4_CAP_EDGE_EXP = edge_size( MOM_M4_CAP_EDGE, inside = 0.001 ); 
MOM_M4_CAP_EDGE_EXP_C = stamp( MOM_M4_CAP_EDGE_EXP, CHIP_MOM, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
MOM_M5 = MOMDMY_5 and M5; 
MOM_M5_EDGE = M5 coincident_inside_edge MOM_M5; 
MOM_M5_LINE_END = adjacent_edge( MOM_M5_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
MOM_M5_SIDE_EDGE = MOM_M5_EDGE not_coincident_inside_edge MOM_M5_LINE_END; 
MOM_M5_CAP_EDGE = external1_edge( MOM_M5_SIDE_EDGE, < ( M5_W_1 + 2 * M5_S_1 ), extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
MOM_M5_CAP_EDGE_EXP = edge_size( MOM_M5_CAP_EDGE, inside = 0.001 ); 
MOM_M5_CAP_EDGE_EXP_C = stamp( MOM_M5_CAP_EDGE_EXP, CHIP_MOM, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
MOM_M6 = MOMDMY_6 and M6; 
MOM_M6_EDGE = M6 coincident_inside_edge MOM_M6; 
MOM_M6_LINE_END = adjacent_edge( MOM_M6_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
MOM_M6_SIDE_EDGE = MOM_M6_EDGE not_coincident_inside_edge MOM_M6_LINE_END; 
MOM_M6_CAP_EDGE = external1_edge( MOM_M6_SIDE_EDGE, < ( M6_W_1 + 2 * M6_S_1 ), extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
MOM_M6_CAP_EDGE_EXP = edge_size( MOM_M6_CAP_EDGE, inside = 0.001 ); 
MOM_M6_CAP_EDGE_EXP_C = stamp( MOM_M6_CAP_EDGE_EXP, CHIP_MOM, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
rMOM_S_2_M1 @= { @ "MOM.S.2:M1 : Space of metal (M1/Mx) line end in MOMDMY_n >= " + MOM_S_2; 
    external2( MOM_M1_LINE_END, M1, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
} /* end of rule : MOM.S.2:M1 */

// MOM.S.2 is checked by MOM.S.2:M1
rMOM_S_2_M2 @= { @ "MOM.S.2:M2 : Space of metal (M1/Mx) line end in MOMDMY_n >= " + MOM_S_2; 
    external2( MOM_M2_LINE_END, M2, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
} /* end of rule : MOM.S.2:M2 */

// MOM.S.2 is checked by MOM.S.2:M2
rMOM_S_2_M3 @= { @ "MOM.S.2:M3 : Space of metal (M1/Mx) line end in MOMDMY_n >= " + MOM_S_2; 
    external2( MOM_M3_LINE_END, M3, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
} /* end of rule : MOM.S.2:M3 */

// MOM.S.2 is checked by MOM.S.2:M3
rMOM_S_2_M4 @= { @ "MOM.S.2:M4 : Space of metal (M1/Mx) line end in MOMDMY_n >= " + MOM_S_2; 
    external2( MOM_M4_LINE_END, M4, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
} /* end of rule : MOM.S.2:M4 */

// MOM.S.2 is checked by MOM.S.2:M4
rMOM_S_2_M5 @= { @ "MOM.S.2:M5 : Space of metal (M1/Mx) line end in MOMDMY_n >= " + MOM_S_2; 
    external2( MOM_M5_LINE_END, M5, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
} /* end of rule : MOM.S.2:M5 */

// MOM.S.2 is checked by MOM.S.2:M5
rMOM_A_1 @= { @ "MOM.A.1 : Maximum sidewall area of total metals in MOM without Via <= " + MOM_A_1; 
    net_area_ratio( CONNECT_DB, > MOM_A_1, { "layer1" => CHIP_MOM, "layer2" => MOM_M1_CAP_EDGE_EXP_C, "layer3" => MOM_M2_CAP_EDGE_EXP_C, "layer4" => MOM_M3_CAP_EDGE_EXP_C, "layer5" => MOM_M4_CAP_EDGE_EXP_C, "layer6" => MOM_M5_CAP_EDGE_EXP_C, "layer7" => MOM_M6_CAP_EDGE_EXP_C }, 7, 7, {  }, NAR_SAVE_NET_19, false ); 
} /* end of rule : MOM.A.1 */
rMOM_R_1 @= { @ "MOM.R.1 : VIA in MOMDMY is not allowed.";
    MOMDMY_1 and VIA1; 
    MOMDMY_2 and VIA1; 
    MOMDMY_2 and VIA2; 
    MOMDMY_3 and VIA2; 
    MOMDMY_3 and VIA3; 
    MOMDMY_4 and VIA3; 
    MOMDMY_4 and VIA4; 
    MOMDMY_5 and VIA4; 
    MOMDMY_5 and VIA5; 
    MOMDMY_6 and VIA5; 
} /* end of rule : MOM.R.1 */
#ifdef FULL_CHIP 
   rMOM_R_2 @= { @ "MOM.R.2 : Each MOM cell must be covered by MOMDMY_n (n=145;1~6/100). DRC only flags no MOMDMY_n (n=145;1~6/100) in the chip. But if there is no MOM cell in your chip, the violation can be waived.";
       sLAYER_455 = not_interacting( gCHIP, MOMDMY_ALL ); 
       level( sLAYER_455 );
   } /* end of rule : MOM.R.2 */
#endif /* end of #ifdef FULL_CHIP  */ 
rDRM_R_1 @= { @ "DRM.R.1 : DRM.R.1 is a warning message to remind the users to check the related DRMs. Please refer to DRM.R.1 in the DRM for details.";
    copy( CHIPX ); 
} /* end of rule : DRM.R.1 */

#pragma ICV patch_insert patch_checks
